
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for ZegoExpressWebRTC.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="prettify.css" />
    <link rel="stylesheet" href="base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="index.html">All files</a> ZegoExpressWebRTC.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">15.64% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>707/4521</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">9.94% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>541/5443</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">16.57% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>257/1551</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>1/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">82x</span></td><td class="text"><pre class="prettyprint lang-js">!function(e,t){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"==typeof exports&amp;&amp;"object"==typeof module)module.exports=t();else <span class="cstat-no" title="statement not covered" >if("function"==typeof define&amp;&amp;define.amd)<span class="cstat-no" title="statement not covered" >define([],t);e</span>lse{var r=<span class="cstat-no" title="statement not covered" >t();<span class="cstat-no" title="statement not covered" ></span>for(var i in r)<span class="cstat-no" title="statement not covered" >("object"==typeof exports?exports:e)[i]=r[i]}</span></span>}</span>("undefined"!=typeof self?self:<span class="branch-1 cbranch-no" title="branch not covered" >this,</span>(function(){return function(e){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=e,r.c=t,r.d=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,i){<span class="cstat-no" title="statement not covered" >r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})}</span>,r.r=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"undefined"!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}</span>,r.t=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(1&amp;t&amp;&amp;(e=r(e)),8&amp;t)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(4&amp;t&amp;&amp;"object"==typeof e&amp;&amp;e&amp;&amp;e.__esModule)<span class="cstat-no" title="statement not covered" >return e;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&amp;t&amp;&amp;"string"!=typeof e)<span class="cstat-no" title="statement not covered" >for(var s in e)<span class="cstat-no" title="statement not covered" >r.d(i,s,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e[t]}</span>.bind(null,s));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>,r.n=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.__esModule?<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.default}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e}</span>;<span class="cstat-no" title="statement not covered" ></span>return r.d(t,"a",t),t}</span>,r.o=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(e,t)}</span>,r.p="",r(r.s=6)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PROTO_VERSION="1.7.0",t.ROOMVERSION="V1",function(e){e[e.debug=0]="debug",e[e.info=1]="info",e[e.warn=2]="warn",e[e.error=3]="error",e[e.report=99]="report",e[e.disable=100]="disable"}(t.ENUM_LOG_LEVEL||(t.ENUM_LOG_LEVEL={})),t.LOG_LEVEL={debug:0,info:1,warn:2,error:3,report:99,disable:100},function(e){e[e.disable=0]="disable",e[e.websocket=1]="websocket",e[e.https=2]="https"}(t.ENUM_REMOTE_TYPE||(t.ENUM_REMOTE_TYPE={})),t.sdkErrorList={CLIENT:"Client.",SERVER:"Server.",SUCCESS:{code:"Success",msg:"success."},PARAM:{code:"Error.Param",msg:"input error."},HEARTBEAT_TIMEOUT:{code:"Error.Timeout",msg:"heartbeat timeout."},LOGIN_TIMEOUT:{code:"Error.Timeout",msg:"login timeout."},SEND_MSG_TIMEOUT:{code:"Error.Timeout",msg:"send customsg timeout."},RESET_QUEUE:{code:"Error.Timeout",msg:"msg waiting ack is clear when reset."},LOGIN_DISCONNECT:{code:"Error.Network",msg:"network is broken and login fail."},KICK_OUT:{code:"Error.Kickout",msg:"kickout reason="},UNKNOWN:{code:"Error.Unknown",msg:"unknown error."},FREQ_LIMITED:{code:"Error.requencyLimited",msg:"Frequency Limited."}},function(e){e[e.disconnected=0]="disconnected",e[e.connecting=1]="connecting",e[e.connected=2]="connected"}(t.ENUM_SIGNAL_STATE||(t.ENUM_SIGNAL_STATE={})),t.ENUM_RESOLUTION_TYPE={LOW:{width:320,height:240,frameRate:15,bitRate:300},MEDIUM:{width:640,height:480,frameRate:15,bitRate:800},HIGH:{width:1280,height:720,frameRate:20,bitRate:1500}},t.ENUM_SCREEM_RESOLUTION_TYPE={LOW:{frameRate:20,bitRate:800},MEDIUM:{frameRate:15,bitRate:1200},HIGH:{frameRate:5,bitRate:2e3}},t.ENUM_RETRY_STATE={didNotStart:0,retrying:1,finished:2},t.ENUM_PUBLISH_STATE={start:0,waitingSessionRsp:1,waitingOffserRsp:2,waitingServerAnswer:3,waitingServerICE:4,connecting:5,publishing:6,stop:7,didNotStart:8},t.ENUM_PLAY_STATE={start:0,waitingSessionRsp:1,waitingOffserRsp:2,waitingServerAnswer:3,waitingServerICE:4,connecting:5,playing:6,stop:7,didNotStart:8},t.ENUM_PLAY_STATE_NEGO={stop:0,start:1,waiterAnswer:2,waitingCandidate:3,sendCandidate:4,iceConnected:5},t.ENUM_CONNECT_STATE={disconnect:0,connecting:1,connected:2},t.MAX_TRY_CONNECT_COUNT=1,t.SEND_MSG_RESET=2,t.SEND_MSG_TIMEOUT=1,t.MAX_TRY_HEARTBEAT_COUNT=5,t.ENUM_PUBLISH_STREAM_STATE={waiting_url:1,tryPublish:2,update_info:3,publishing:4,stop:5},t.ENUM_STREAM_SUB_CMD={liveNone:0,liveBegin:2001,liveEnd:2002,liveUpdate:2003},t.ENUM_STREAM_UPDATE_TYPE={added:1,deleted:0},function(e){e[e.logout=0]="logout",e[e.trylogin=1]="trylogin",e[e.login=2]="login"}(t.ENUM_RUN_STATE||(t.ENUM_RUN_STATE={})),t.ENUM_PUBLISH_STATE_UPDATE={start:0,error:1,retry:2},t.ENUM_PLAY_STATE_UPDATE={start:0,error:1,retry:2},t.MAX_TRY_LOGIN_COUNT=5,t.TRY_LOGIN_INTERVAL=[2e3,4e3,6e3,8e3,1e4],t.MINIUM_HEARTBEAT_INTERVAL=3e3,t.ENUM_STREAM_UPDATE_CMD={added:12001,deleted:12002,updated:12003},t.SERVER_ERROR_CODE=1e4,t.MIXSTREAM_ERROR_CODE=1e4,function(e){e[e.low=1]="low",e[e.stantard=2]="stantard",e[e.hight=3]="hight",e[e.custome=4]="custome"}(t.QUALITYLEVEL||(t.QUALITYLEVEL={})),t.ENUM_SIGNAL_SUB_CMD={none:0,joinLiveRequest:1001,joinLiveResult:1002,joinLiveInvite:1003,joinLiveStop:1004},t.ENUM_PUSH_SIGNAL_SUB_CMD={none:0,pushJoinLiveRequest:11001,pushJoinLiveResult:11002,pushJoinLiveInvite:11003,pushJoinLiveStop:11004},t.ENUM_PUBLISH_STATE_NEGO={stop:0,start:1,waiterAnswer:2,waitingCandidate:3,sendCandidate:4,iceConnected:5},function(e){e[e.cdn=0]="cdn",e[e.ultra=1]="ultra"}(t.ENUM_PLAY_SOURCE_TYPE||(t.ENUM_PLAY_SOURCE_TYPE={})),function(e){e[e.stop=0]="stop",e[e.start=1]="start"}(t.ENUM_BROADCASTER_STATUS||(t.ENUM_BROADCASTER_STATUS={})),function(e){e[e.cdn=0]="cdn",e[e.ultra=1]="ultra",e[e.customUrl=2]="customUrl"}(t.ENUM_DISPATCH_TYPE||(t.ENUM_DISPATCH_TYPE={})),function(e){e[e.CDN=0]="CDN",e[e.BGP=1]="BGP"}(t.ENUM_SOURCE_TYPE||(t.ENUM_SOURCE_TYPE={})),function(e){e[e.ClientType_None=0]="ClientType_None",e[e.ClientType_H5=1]="ClientType_H5",e[e.ClientType_SmallPragram=2]="ClientType_SmallPragram",e[e.ClientType_Webrtc=3]="ClientType_Webrtc"}(t.E_CLIENT_TYPE||(t.E_CLIENT_TYPE={}));var i=function(){function e(e,t){void 0===e&amp;&amp;(e=null),void 0===t&amp;&amp;(t=null),this._id=null,this.next=null,this.prev=null,this._id=e,this._data=t}return Object.defineProperty(e.prototype,"id",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._id?this._id:null}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._id=e}</span>,enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"data",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._data}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._data=e}</span>,enumerable:!0,configurable:!0}),e.prototype.hasNext=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.next&amp;&amp;this.next.id}</span>,e.prototype.hasPrev=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.prev&amp;&amp;this.prev.id}</span>,e}();t.ListNode=i;var s=function(){function e(){this.start=new i,this.end=new i,this._idCounter=0,this._numNodes=0,this.start.next=this.end,this.start.prev=null,this.end.prev=this.start,this.end.next=null}return e.prototype.insertBefore=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >new i(this._idCounter,t);<span class="cstat-no" title="statement not covered" ></span>return r.next=e,r.prev=e.prev,e.prev&amp;&amp;(e.prev.next=r),e.prev=r,++this._idCounter,++this._numNodes,r}</span>,e.prototype.addLast=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.insertBefore(this.end,e)}</span>,e.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.addLast(e)}</span>,e.prototype.getFirst=function(){return 0===this._numNodes?null:<span class="branch-1 cbranch-no" title="branch not covered" >this.start.next}</span>,e.prototype.getLast=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0===this._numNodes?null:this.end.prev}</span>,e.prototype.size=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._numNodes}</span>,e.prototype.getFromFirst=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >this.start.next;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;=0)<span class="cstat-no" title="statement not covered" >for(;t&lt;e&amp;&amp;null!==r;)<span class="cstat-no" title="statement not covered" >r=r.next,++t;e</span></span>lse <span class="cstat-no" title="statement not covered" >r=null;<span class="cstat-no" title="statement not covered" >i</span></span>f(null===r)<span class="cstat-no" title="statement not covered" >throw"Index out of bounds.";<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,e.prototype.get=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0===e?this.getFirst():e===this._numNodes-1?this.getLast():this.getFromFirst(e)}</span>,e.prototype.remove=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.prev&amp;&amp;(e.prev.next=e.next),e.next&amp;&amp;(e.next.prev=e.prev),--this._numNodes,e}</span>,e.prototype.removeFirst=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return this._numNodes&gt;0&amp;&amp;this.start.next&amp;&amp;(e=this.remove(this.start.next)),e}</span>,e.prototype.removeLast=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return this._numNodes&gt;0&amp;&amp;this.end.prev&amp;&amp;(e=this.remove(this.end.prev)),e}</span>,e.prototype.removeAll=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.start.next=this.end,this.end.prev=this.start,this._numNodes=0,this._idCounter=0}</span>,e.prototype.each=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=this.start;t.hasNext();)<span class="cstat-no" title="statement not covered" >e(t=t.next)}</span></span>,e.prototype.find=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=this.start,r=!1,i=null;t.hasNext()&amp;&amp;!r;)<span class="cstat-no" title="statement not covered" >e(t=t.next)&amp;&amp;(i=t,r=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=this.start,r=[];t.hasNext();)<span class="cstat-no" title="statement not covered" >e(t=t.next)&amp;&amp;r.push(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,e.prototype.push=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.addLast(e)}</span>,e.prototype.unshift=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._numNodes&gt;0?this.insertBefore(this.start.next,e):this.insertBefore(this.end,e)}</span>,e.prototype.pop=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.removeLast()}</span>,e.prototype.shift=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.removeFirst()}</span>,e}();t.LinkedList=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.commonErrorList={SUCCESS:{code:"Success",msg:"success."},INIT:{code:2000000001,msg:"init sdk wrong"},PARAM:{code:2000000002,msg:"input parm error."},DETECT_TIMEOUT:{code:2000000003,msg:"detect time out"},DETECT_FAIL:{code:2000000004,msg:"detect fail"},SCREEN:{code:2000000005,msg:"screen sharing fail"},DEVICE_NO_FOUND:{code:2000000006,msg:"device no found"},ENUMERATE_DEVICES_FAIL:{code:2000000007,msg:"enumerate devices fail"},NOT_LOGIN:{code:2000000008,msg:"not login"},STOP_MIX_FAIL:{code:2000000009,msg:"stop mix stream fail"},MIX_VIDEOC:{code:2000000010,msg:"mix video code type wrong"},MIX_OUTPUT:{code:2000000011,msg:"mix output wrong"}},t.liveRoomErrorList={SERVER:{code:0,msg:"liverooom cmd error"},KICK_OUT:{code:2001000001,msg:"liveroom kick out"},HEARTBEAT_TIMEOUT:{code:2001000002,msg:"heartbeat timeout."},LOGIN_TIMEOUT:{code:2001000003,msg:"login timeout."},SEND_MSG_TIMEOUT:{code:2001000004,msg:"send customsg timeout."},RESET_QUEUE:{code:2001000005,msg:"msg waiting ack is clear when reset."},LOGIN_DISCONNECT:{code:2001000006,msg:"network is broken and login fail."},UNKNOWN:{code:2001000007,msg:"unknown error."},FREQ_LIMITED:{code:2001000008,msg:"frequency limited."}},t.publishErrorList={PARAM:{code:2002000001,msg:"input parm error."},BROWSER_NOT_SUPPORT:{code:2002000002,msg:"browser do not support"},DISPATCH_ERROR:{code:2002000003,msg:"dispatch request error"},DISPATCH_TIMEOUT:{code:2002000004,msg:"dispatch request timeout"},TOKEN_ERROR:{code:2002000005,msg:"login token error"},SEND_SESSION_TIMEOUT:{code:2002000006,msg:"send session request timeout"},CREATE_SESSION_ERROR:{code:2002000007,msg:"create session error"},CREATE_OFFER_ERROR:{code:2002000008,msg:"create offer error"},SET_LOCAL_DESC_ERROR:{code:2002000009,msg:"setLocalDescription error"},SEND_MEDIA_DESC_TIMEOUT:{code:2002000010,msg:"send mediaDesc timeout"},SERVER_MEDIA_DESC_TIMEOUT:{code:2002000011,msg:"waiting server mediaDesc timeout"},SERVER_MEDIA_DESC_ERROR:{code:2002000012,msg:"server mediaDesc type error"},SET_REMOTE_DESC_ERROR:{code:2002000013,msg:"other side offer error"},SEND_CANDIDATE_TIMEOUT:{code:2002000014,msg:"sendIceCandidate error"},SERVER_CANDIDATE_TIMEOUT:{code:2002000015,msg:"waiting candidate timeout"},SERVER_CANDIDATE_ERROR:{code:2002000016,msg:"recv candidate error"},SESSION_CLOSED:{code:2002000017,msg:"server session closed"},MEDIA_CONNECTION_FAILED:{code:2002000018,msg:"Iice Connection state failed"},MEDIA_CONNECTION_CLOSED:{code:2002000019,msg:"ice connection state closed"},WEBSOCKET_ERROR:{code:2002000020,msg:"network error"},CONSTRAINTS_ERROR:{code:2002000021,msg:"constraint error"},MEDIA_CONNECTION_DISCONNECTED:{code:2002000022,msg:"ice connection state disconnected"},SERVER_NEGO_TIMEOUT:{code:2002000023,msg:"negotiation timeout"}},t.playErrorList={PARAM:{code:2003000001,msg:"input parm error."},REPEATED_PULL:{code:2003000002,msg:"repeated pull same stream"},DISPATCH_ERROR:{code:2003000003,msg:"dispatch request error"},DISPATCH_TIMEOUT:{code:2003000004,msg:"dispatch request timeout"},TOKEN_ERROR:{code:2003000005,msg:"login token error"},SEND_SESSION_TIMEOUT:{code:2003000006,msg:"send session request timeout"},CREATE_SESSION_ERROR:{code:2003000007,msg:"create session error"},CREATE_OFFER_ERROR:{code:2003000008,msg:"create offer error"},SERVER_MEDIA_DESC_TIMEOUT:{code:2003000009,msg:"wating server mediaDesc timeout"},SET_REMOTE_DESC_ERROR:{code:2003000010,msg:"other side offer error"},CREATE_ANSWER_ERROR:{code:2003000011,msg:"create offer error"},SET_LOCAL_DESC_ERROR:{code:2003000012,msg:"setLocalDescription error"},SEND_MEDIA_DESC_TIMEOUT:{code:2003000013,msg:"send mediaDesc timeout"},SEND_CANDIDATE_ERROR:{code:2003000014,msg:"send candidate error"},SEND_CANDIDATE_TIMEOUT:{code:2003000015,msg:"send candidate timeout"},SERVER_CANDIDATE_TIMEOUT:{code:2003000016,msg:"waiting candidate timeout"},SERVER_CANDIDATE_ERROR:{code:2003000017,msg:"recv candidate error"},MEDIA_CONNECTION_FAILED:{code:2003000018,msg:"ice Connection state failed"},MEDIA_CONNECTION_CLOSED:{code:2003000019,msg:"ice connection state closed"},SESSION_CLOSED:{code:2003000020,msg:"server session closed"},WEBSOCKET_ERROR:{code:2003000021,msg:"network error"},MEDIA_CONNECTION_DISCONNECTED:{code:2002000022,msg:"ice connection state disconnected"},SERVER_NEGO_TIMEOUT:{code:2002000023,msg:"negotiation timeout"}}},function(e,t,r){"use strict";var i;Object.defineProperty(t,"__esModule",{value:!0}),t.ENUM_PUBLISH_STATE_UPDATE={start:0,error:1,retry:2},t.ENUM_PLAY_STATE_UPDATE={start:0,error:1,retry:2,stop:3},t.ENUM_RETRY_STATE={didNotStart:0,retrying:1,finished:2},t.REPORT_ACTION={eventStart:"eventStart",eventEndWithMsgInfo:"eventEndWithMsgInfo",addEventMsg:"addEventMsg",addEvent:"addEvent",eventEnd:"eventEnd",addMsgInfo:"addMsgInfo"},t.getSeq=(i=1,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i++}</span>),t.getReportSeq=function(){var e=1;return function(){return e++}}()},function(e,t,r){"use strict";var i=this&amp;&amp;this.__awaiter||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >return new(r||(r=Promise))((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){function <span class="fstat-no" title="function not covered" >n(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(i.next(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(i.throw(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){var t;<span class="cstat-no" title="statement not covered" >e.done?s(e.value):(t=e.value,t instanceof r?t:new r((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(t)}</span>))).then(n,a)}<span class="cstat-no" title="statement not covered" ></span>c((i=i.apply(e,t||[])).next())}</span>))}</span>,s=this&amp;&amp;this.__generator||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,i,s,o,n=<span class="cstat-no" title="statement not covered" >{label:0,sent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(1&amp;s[0])<span class="cstat-no" title="statement not covered" >throw s[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s[1]}</span>,trys:[],ops:[]};<span class="cstat-no" title="statement not covered" ></span>return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&amp;&amp;(o[Symbol.iterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>),o;f</span>unction <span class="fstat-no" title="function not covered" >a(</span>o){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >throw new TypeError("Generator is already executing.");<span class="cstat-no" title="statement not covered" >f</span></span>or(;n;)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(r=1,i&amp;&amp;(s=2&amp;o[0]?i.return:o[0]?i.throw||((s=i.return)&amp;&amp;s.call(i),0):i.next)&amp;&amp;!(s=s.call(i,o[1])).done)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>witch(i=0,s&amp;&amp;(o=[2&amp;o[0],s.value]),o[0]){case 0:case 1:<span class="cstat-no" title="statement not covered" >s=o;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >return n.label++,{value:o[1],done:!1};c</span>ase 5:<span class="cstat-no" title="statement not covered" >n.label++,i=o[1],o=[0];<span class="cstat-no" title="statement not covered" >c</span>ontinue;c</span>ase 7:<span class="cstat-no" title="statement not covered" >o=n.ops.pop(),n.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue;d</span>efault:<span class="cstat-no" title="statement not covered" >if(!(s=(s=n.trys).length&gt;0&amp;&amp;s[s.length-1])&amp;&amp;(6===o[0]||2===o[0])){<span class="cstat-no" title="statement not covered" >n=0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(3===o[0]&amp;&amp;(!s||o[1]&gt;s[0]&amp;&amp;o[1]&lt;s[3])){<span class="cstat-no" title="statement not covered" >n.label=o[1];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(6===o[0]&amp;&amp;n.label&lt;s[1]){<span class="cstat-no" title="statement not covered" >n.label=s[1],s=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s&amp;&amp;n.label&lt;s[2]){<span class="cstat-no" title="statement not covered" >n.label=s[2],n.ops.push(o);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>[2]&amp;&amp;n.ops.pop(),n.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>o</span>=t.call(e,n)}</span>catch(e){<span class="cstat-no" title="statement not covered" >o=[6,e],i=0}</span>finally{<span class="cstat-no" title="statement not covered" >r=s=0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(5&amp;o[0])<span class="cstat-no" title="statement not covered" >throw o[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:o[0]?o[1]:void 0,done:!0}}</span>([o,a])}</span>}</span>};Object.defineProperty(t,"__esModule",{value:!0});var o=r(0),n=r(1),a=r(4),c=function(){function <span class="fstat-no" title="function not covered" >e(</span>){}return e.checkConfigParam=function(e,t,r){return e&amp;&amp;"number"==typeof e?!(!t||"string"!=typeof t&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >!Array.isArray(t)|</span>|""==t)||(<span class="branch-1 cbranch-no" title="branch not covered" >r.error("ccp.0 server must be string or string array and not empty"),!1)</span>:(<span class="branch-1 cbranch-no" title="branch not covered" >r.error("ccp.0 appid must be number and not empty"),!1)</span>},e.registerCallback=function(e,t,r){var i,s;t.success&amp;&amp;(i=t.success,r[e+"SuccessCallback"]=i),t.error&amp;&amp;(s=t.error,r[e+"ErrorCallback"]=s)},e.actionErrorCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t[e+"ErrorCallback"]}</span>,e.actionSuccessCallback=function(e,t){return t[e+"SuccessCallback"]},e.logReportCallback=function(t,r,i,s){e.registerCallback(t,{success:function(t,s){for(var o=[],n=2;n&lt;arguments.length;n++)o[n-2]=arguments[n];e.dataReportEvent(r,i,t,s,o)}},s)},e.proxyRes=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i,s){<span class="cstat-no" title="statement not covered" >return{interResolve:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.uploadReport(r),i(e)}</span>,interReject:<span class="fstat-no" title="function not covered" >fu</span>nction(i,o){var n;<span class="cstat-no" title="statement not covered" >if(void 0===o&amp;&amp;(o=""),i.code&lt;2e9)<span class="cstat-no" title="statement not covered" >n=e.decodeServerError(i.code,i.msg);e</span>lse{var c=<span class="cstat-no" title="statement not covered" >a.codeErrMap[i.code];<span class="cstat-no" title="statement not covered" ></span>n=a.errorList[c]}<span class="cstat-no" title="statement not covered" ></span>t</span>.addMsgInfo(r,{error:n.code,message:n.message+o}),t.uploadReport(r),s(i)}</span>}}</span>,e.getServerError=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{1:"parse json error.",1001:"login is processing.",1002:"liveroom request error.",1003:"zpush connect fail.",1004:"zpush handshake fail.",1005:"zpush login fail.",1006:"user login state is wrong.",1007:"got no zpush addr",1008:"token error",1009:"dispatch error",1010:"token expired",1011:"token format error",1012:"subcmd error",1101:"zego auth error",2001:"invalid channel",2002:"biz channel error",1e9:"liveroom cmd error, result="};<span class="cstat-no" title="statement not covered" ></span>if(0===e)<span class="cstat-no" title="statement not covered" >return n.commonErrorList.SUCCESS;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >n.liveRoomErrorList.SERVER;<span class="cstat-no" title="statement not covered" ></span>return r.code=e,r.msg=e&gt;1e9?t[1e9]+e:t[e]?t[e]:"unknown error code:"+e,r}</span>,e.unregisterCallback=function(e,t){delete t[e+"SuccessCallback"],delete t[e+"ErrorCallback"]},e.decodeServerError=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >{code:-1,message:"server error"};<span class="cstat-no" title="statement not covered" ></span>return r.code=e&gt;1e9?e-1e9+52e6:e+2002e6,t&amp;&amp;(r.message=t),r}</span>,e.mixServerError=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{82000001:"kMixStreamFailError",82000002:"kMixStreamInputError",82000003:"kMixStreamAuthError",82000150:"kMixStreamNotExistError",82000151:"kMixStreamStartMixError",82000152:"kMixStreamStopMixError",82000155:"kMixStreamInputFormatError",82000156:"kMixStreamOutputFormatError",82000157:"kMixStreamNotOpenError",82000158:"kMixStreamInputExceedError",82000159:"kMixStreamDispatchError",82000160:"kMixStreamStopMixOwnerError",82000170:"kMixStreamWaterMarkParamError",82000171:"kMixStreamWaterMarkImageError",82000190:"kMixStreamQpsOverloadError"};<span class="cstat-no" title="statement not covered" ></span>if(e&gt;1e9){var r=<span class="cstat-no" title="statement not covered" >e-1e9+82e6;<span class="cstat-no" title="statement not covered" ></span>return t[r]?t[r]:""}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn""}</span>,e.getKickoutError=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>switch(e){case 1:<span class="cstat-no" title="statement not covered" >t.code=63000001,t.message="zpush multiple login kickout";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >t.code=63000002,t.message="zpush manual kickout";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >t.code=63000003,t.message="zpush room session error"}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,e.dataReportEvent=function(e,t,r,i,s){switch(r){case"eventStart":e.eventStart(t,i);break;case"eventEndWithMsgInfo":e.eventEndWithMsgInfo(t,i,s[0]);break;case"addEventMsg":e.addEventMsg(t,i,s[0],s[1]);break;<span class="branch-3 cbranch-no" title="branch not covered" >case"addEvent":<span class="cstat-no" title="statement not covered" >e.addEvent(t,i);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-4 cbranch-no" title="branch not covered" >c</span></span>ase"eventEnd":<span class="cstat-no" title="statement not covered" >e.eventEnd(t,i);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-5 cbranch-no" title="branch not covered" >c</span></span>ase"addMsgInfo":<span class="cstat-no" title="statement not covered" >e.addMsgInfo(t,s[0])}</span></span>},e.isKeepTryLogin=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >switch(e){case 1002:case 1003:<span class="cstat-no" title="statement not covered" >return!0;d</span>efault:<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>,e.mergeStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){<span class="cstat-no" title="statement not covered" >e.debug("msl.0 call");v</span>ar o,n=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i||(i=[]);<span class="cstat-no" title="statement not covered" >f</span>or(var d=0;d&lt;i.length;d++)<span class="cstat-no" title="statement not covered" >if(i[d].anchor_id_name!=t){<span class="cstat-no" title="statement not covered" >o=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var l=0;l&lt;r.length;l++)<span class="cstat-no" title="statement not covered" >if(i[d].stream_id===r[l].stream_id){<span class="cstat-no" title="statement not covered" >i[d].extra_info!==r[l].extra_info&amp;&amp;c.push(i[d]),o=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>o</span></span>||n.push(i[d])}</span>else <span class="cstat-no" title="statement not covered" >e.debug("msl.0 have self stream added");<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var u=0;u&lt;r.length;u++){<span class="cstat-no" title="statement not covered" >o=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var h=0;h&lt;i.length;h++)<span class="cstat-no" title="statement not covered" >if(r[u].stream_id===i[h].stream_id){<span class="cstat-no" title="statement not covered" >o=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>o</span></span>||a.push(r[u])}<span class="cstat-no" title="statement not covered" ></span>r</span>.splice(0);<span class="cstat-no" title="statement not covered" >f</span>or(d=0;d&lt;i.length;d++)<span class="cstat-no" title="statement not covered" >r.push(i[d]);<span class="cstat-no" title="statement not covered" >s</span></span>(n,a,c),e.debug("msl.0 call success")}</span>,e.mergeUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >e.debug("msl.0 call");v</span>ar s,o=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>r||(r=[]);<span class="cstat-no" title="statement not covered" >f</span>or(var a=0;a&lt;r.length;a++){<span class="cstat-no" title="statement not covered" >s=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var c=0;c&lt;t.length;c++)<span class="cstat-no" title="statement not covered" >if(r[a].userID===t[c].userID){<span class="cstat-no" title="statement not covered" >s=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span></span>||o.push(r[a])}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var d=0;d&lt;t.length;d++){<span class="cstat-no" title="statement not covered" >s=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var l=0;l&lt;r.length;l++)<span class="cstat-no" title="statement not covered" >if(t[d].userID===r[l].userID){<span class="cstat-no" title="statement not covered" >s=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span></span>||n.push(t[d])}<span class="cstat-no" title="statement not covered" ></span>t</span>.splice(0);<span class="cstat-no" title="statement not covered" >f</span>or(a=0;a&lt;r.length;a++)<span class="cstat-no" title="statement not covered" >t.push(t[a]);<span class="cstat-no" title="statement not covered" >i</span></span>(o,n),e.debug("msl.0 call success")}</span>,e.checkCustomCommandParam=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!0}</span>,e.generateRandumNumber=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return parseInt(Math.random()*(e+1)+"",10)}</span>,e.uuid=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,i=<span class="cstat-no" title="statement not covered" >"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(t=t||i.length,e)<span class="cstat-no" title="statement not covered" >for(r=0;r&lt;e;r++)<span class="cstat-no" title="statement not covered" >s[r]=i[0|Math.random()*t];e</span></span>lse{var o=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>for(s[8]=s[13]=s[18]=s[23]="-",s[14]="4",r=0;r&lt;36;r++)<span class="cstat-no" title="statement not covered" >s[r]||(o=0|16*Math.random(),s[r]=i[19==r?3&amp;o|8:o])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn s.join("")}</span>,e.supportDetection=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return i(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var r,i,o,n,a;<span class="cstat-no" title="statement not covered" >return s(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >switch(s.label){case 0:<span class="cstat-no" title="statement not covered" >if(r={webRTC:!1,customCapture:!1,camera:!1,microphone:!1,videoCodec:{H264:!1,H265:!1,VP8:!1,VP9:!1},screenSharing:e},((i=document.createElement("video")).captureStream||i.mozCaptureStream)&amp;&amp;(r.customCapture=!0),!(navigator&amp;&amp;navigator.mediaDevices&amp;&amp;navigator.mediaDevices.getUserMedia))<span class="cstat-no" title="statement not covered" >return[3,7];<span class="cstat-no" title="statement not covered" >s</span></span>.label=1;c</span>ase 1:<span class="cstat-no" title="statement not covered" >return s.trys.push([1,6,,7]),"https:"===window.location.protocol||"file:"===window.location.protocol||-1!=window.location.hostname.indexOf("127.0.0.1")||-1!=window.location.hostname.indexOf("localhost")?[3,2]:(r.camera=!1,console.error("webrtc requires https or localhost"),[3,5]);c</span>ase 2:<span class="cstat-no" title="statement not covered" >return[4,navigator.mediaDevices.getUserMedia({video:!0})];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return(o=s.sent())&amp;&amp;(r.camera=!0)&amp;&amp;o.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.stop()}</span>)),[4,navigator.mediaDevices.getUserMedia({audio:!0})];c</span>ase 4:<span class="cstat-no" title="statement not covered" >(n=s.sent())&amp;&amp;(r.microphone=!0)&amp;&amp;n.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.stop()}</span>)),s.label=5;c</span>ase 5:<span class="cstat-no" title="statement not covered" >return[3,7];c</span>ase 6:<span class="cstat-no" title="statement not covered" >return a=s.sent(),console.error("devices detect error: ",a.name,a.message),[3,7];c</span>ase 7:<span class="cstat-no" title="statement not covered" >return this.supportVideoCodeType((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >r.videoCodec.H264=e.H264,r.videoCodec.H265=e.H265,r.videoCodec.VP8=e.VP8,r.videoCodec.VP9=e.VP9,r.webRTC=e.webRTC,i&amp;&amp;console.error("videoCodec detect error: "+i),t&amp;&amp;t(r)}</span>)),[2]}</span>}</span>))}</span>))}</span>,e.compareVersion=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e=e.split("."),t=t.split(".");<span class="cstat-no" title="statement not covered" >f</span>or(var r=Math.max(e.length,t.length);e.length&lt;r;)<span class="cstat-no" title="statement not covered" >e.push("0");<span class="cstat-no" title="statement not covered" >f</span></span>or(;t.length&lt;r;)<span class="cstat-no" title="statement not covered" >t.push("0");<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=0;i&lt;r;i++){var s=<span class="cstat-no" title="statement not covered" >parseInt(e[i]),</span>o=<span class="cstat-no" title="statement not covered" >parseInt(t[i]);<span class="cstat-no" title="statement not covered" ></span>if(s&gt;o)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f(s&lt;o)<span class="cstat-no" title="statement not covered" >return-1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn 0}</span>,e.isSupportLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >"当前微信版本过低，无法使用相关组件",</span>i=<span class="cstat-no" title="statement not covered" >"需要摄像头和录音功能的授权",</span>s=<span class="cstat-no" title="statement not covered" >wx.getSystemInfoSync().SDKVersion,</span>o=<span class="cstat-no" title="statement not covered" >{code:-1,msg:""};<span class="cstat-no" title="statement not covered" ></span>this.compareVersion(s,"1.7.0")&lt;0&amp;&amp;(o={code:10001,msg:r},e&amp;&amp;e(o)),wx.getSetting({success:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >t.authSetting;<span class="cstat-no" title="statement not covered" ></span>r["scope.camera"]&amp;&amp;r["scope.record"]||(o={code:10002,msg:i}),e&amp;&amp;e(o)}</span>,fail:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >console.error("get setting error",e),t&amp;&amp;t(e)}</span>})}</span>,e.supportVideoCodeType=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{webRTC:!1,H264:!1,VP8:!1,VP9:!1,H265:!1};<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >(new RTCPeerConnection).createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0}).then((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >if(t.webRTC=!0,r&amp;&amp;r.sdp){var i=<span class="cstat-no" title="statement not covered" >r.sdp.split("\r\n");<span class="cstat-no" title="statement not covered" ></span>t.H264=i.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.startsWith("a=rtpmap:")&amp;&amp;e.indexOf("H264/")&gt;-1}</span>)),t.VP8=i.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.startsWith("a=rtpmap:")&amp;&amp;e.indexOf("VP8/")&gt;-1}</span>)),t.VP9=i.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.startsWith("a=rtpmap:")&amp;&amp;e.indexOf("VP9/")&gt;-1}</span>)),t.H265=i.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.startsWith("a=rtpmap:")&amp;&amp;e.indexOf("H264/")&gt;-1}</span>)),e&amp;&amp;e(t)}</span>}</span>))}</span>catch(r){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e(t,r)}</span>}</span>,e.inlineWorker=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(Worker&amp;&amp;e){var t=<span class="cstat-no" title="statement not covered" >e.toString().trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1],</span>r=<span class="cstat-no" title="statement not covered" >URL.createObjectURL(new window.Blob([t],{type:"text/javascript"}));<span class="cstat-no" title="statement not covered" ></span>return new Worker(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>,e.getBrowser=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >window.navigator.userAgent,</span>t=<span class="cstat-no" title="statement not covered" >null!=window.ActiveXObject&amp;&amp;-1!=e.indexOf("MSIE"),</span>r=<span class="cstat-no" title="statement not covered" >-1!=e.indexOf("Firefox"),</span>i=<span class="cstat-no" title="statement not covered" >null!=window.opr,</span>s=<span class="cstat-no" title="statement not covered" >e.indexOf("Chrome")&amp;&amp;window.chrome,</span>o=<span class="cstat-no" title="statement not covered" >-1!=e.indexOf("Safari")&amp;&amp;-1!=e.indexOf("Version");<span class="cstat-no" title="statement not covered" ></span>return t?"IE":r?"Firefox":i?"Opera":s?"Chrome":o?"Safari":"Unkown"}</span>,e.setDebug=function(e,t){"string"==typeof e&amp;&amp;-1!=e.indexOf("wss")?-1==e.indexOf("wss://wsliveroom-alpha.zego.im/ws")&amp;&amp;-1==e.indexOf("wss://wssliveroom-test.zego.im/ws")&amp;&amp;-1==e.indexOf("wss://test2-wsliveroom-api.zego.im/ws")&amp;&amp;-1==e.indexOf("wss://wsliveroom-test.zegocloud.com/ws")&amp;&amp;-1==e.indexOf("wss://wsliveroom-test.zego.im/ws")&amp;&amp;-1==e.indexOf("wss://webliveroom-test.zego.im/ws")||(t.debug=!0):<span class="branch-1 cbranch-no" title="branch not covered" >console.error("server wrong")}</span>,e.getPublisherStateType=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0==e||1==e?0==e?"PUBLISHING":"NO_PUBLISH":"PUBLISH_REQUESTING"}</span>,e.getPlayerStateType=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0==e||1==e?0==e?"PLAYING":"NO_PLAY":"PLAY_REQUESTING"}</span>,e.getSteamUpdateType=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0==e?"DELETE":"ADD"}</span>,e.getLogLevel=function(e){return o.LOG_LEVEL[e]},e}();t.ClientUtil=c},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.eventList={kZegoTaskInitSetting:"/sdk/init",kZegoTaskLoginRoom:"/sdk/login",kZegoTaskLogoutRoom:"/sdk/logout",kZegoTaskReLoginRoom:"/sdk/relogin",kZegoTaskSdkDisconnect:"/sdk/disconnect",kZegoTaskKickout:"/sdk/kickout",kZegoTaskSessionClose:"/sdk/session_close",kZegoTaskLiveRoomhHB:"/liveroom/hb",kZegoTaskLiveSendRoomBigIM:"/liveroom/send_big_room_message",kZegoTaskLiveGetRoomBigIM:"/liveroom/get_big_room_message",kZegoTaskLiveRoomGetUserUpdateInfo:"/liveroom/get_user_update_info",kZegoTaskLiveRoomGetRoomMessage:"/liveroom/get_room_message",kZegoTaskLiveRoomSendRoomMessage:"/liveroom/send_room_message",kZegoTaskLiveRoomSendCustomCommand:"/liveroom/send_custom_command",kZegoTaskLiveRoomGetCustomCommand:"/liveroom/get_custom_command",kZegoTaskLiveRoomSendStreamExtraInfo:"/liveroom/send_stream_extra_info",kZegoTaskLiveRoomGetStreamExtraInfo:"/liveroom/get_stream_extra_info",kZegoTaskLiveRoomGetStreamUpdateInfo:"/liveroom/get_stream_update_info",kZegoTaskPublishStart:"/sdk/start_publish",kZegoTaskRePublish:"/sdk/republish",kZegoTaskPublishStop:"/sdk/stop_publish",kZegoTaskPlayStart:"/sdk/start_play",kZegoTaskRePlay:"/sdk/replay",kZegoTaskPlayStop:"/sdk/stop_play",kZegoTaskMixStart:"/mix/start_mix",kZegoTaskMixStop:"/mix/stop_mix",kZegoTaskMixConfig:"/mix/config_mix",kZegoTaskEnumDevices:"/sdk/enum_devices",kZegoTaskSetDebug:"/sdk/set_debug",kZegoTaskSetLog:"/sdk/set_log_config",kZegoTaskUseVideoDevice:"/sdk/use_video_device",kZegoTaskUseAudioDevice:"/sdk/use_audio_device",kZegoTaskCheckSystemRequirements:"/sdk/check_system",kZegoTaskMutePublishVideo:"/sdk/mute_publish_video",kZegoTaskMutePublishAudio:"/sdk/mute_publish_audio",kZegoTaskRemoteCameraUpdate:"/sdk/remote_camera_update",kZegoTaskRemoteMicUpdate:"/sdk/remote_mic_update",kZegoTaskGetSoundLevel:"/sdk/get_sound_level",kZegoTaskStopSoundLevel:"/sdk/stop_sound_level",kZegoTaskAddPublishCdnUrl:"/sdk/add_publish_cdn_url",kZegoTaskRemovePublishCdnUrl:"/sdk/remove_publish_cdn_url",kZegoTaskClearPublishCdnUrl:"/sdk/clear_publish_cdn_url",kZegoTaskCreateStream:"/sdk/create_stream",kZegoTaskDestroyStream:"/sdk/destroy_stream",kZegoTaskScreenSharingEnded:"/sdk/screen_share_end",kZegoEventPublishStat:"/sdk/publish_stat_report",kZegoEventPlayStat:"/sdk/play_stat_report"},t.errorList={kOK:0,kEnd:1,kNoneAppIdError:10000101,kNotLoginError:{code:10000105,message:"sdk error, not login room"},kPublishBadNameError:10000106,kInvalidParamError:{code:10001001,message:"sdk error, invalid param."},kInvalidChannelError:10001002,kNullPointerError:10001003,kInvalidUserIDError:10001004,kInvalidRoomIDError:10001005,kNoFreeChannelError:10001101,kFormatUrlError:10001102,kInvalidExtraUrlError:10001103,kNoPushIpError:10001104,kUnmatchStreamIDError:10002001,kUnmatchSeqError:{code:10002002,message:"sdk error, unmatch seq"},kNoneSeqError:10002003,kUnmatchStateError:10002004,kRedirectError:10003001,kOutOfMemeryError:10004001,kStartThreadError:10004002,kStartRequestError:10005001,kStartUpdateStreamInfoError:10006001,kNoMultiRoomLoginRole:10007001,kMultiRoomIDMappingOther:10007002,kNetWorkProbeNoUrl:10007003,kNetWorkProbeStopPublish:10007004,kNetWorkProbeStopPlay:10007005,kFetalError1:10007101,kFetalError2:10007102,kFetalError3:10007103,kFetalError4:10007104,kFetalError5:10007105,kFetalError6:10007106,kFetalError7:10007107,kSDKNoMoudleFunction:10008001,kDeviceError:10009001,kNetworkNotConnectError:11000101,kNetworkDnsResolveError:11000404,kEngineCreateError:12101001,kEngineStatusError:12101002,kEngineStartError:12101003,kDeniedMaxRetryError:12101004,kDeniedDisableSwitchLineError:12101005,kEngineNoPlayDataError:12102001,kEngineNoPublishDataError:12102002,kEngineUnknownError:122e5,kEngineConnectServerError:12200001,kEngineRtmpHandshakeError:12200002,kEngineRtmpAppConnectError:12200003,kEngineRtmpCreateStreamError:12200004,kEngineRtmpPublishBadNameError:12200005,kEngineServerDisconnectError:12200006,kEngineRtpConnectServerError:12200100,kEngineRtpHelloTimeoutError:12200101,kEngineRtpCreateSessionTimeoutError:12200102,kEngineRtpCreateSessionFailError:12200103,kEngineRtpPlayOrPublishTimeoutError:12200104,kEngineRtpPlayOrPublishDeniedError:12200105,kEngineRtpTimeoutError:12200106,kEngineRtpDecryptError:12200107,kEngineRtpDecryptNotSupport:12200108,kEngineRtpSockError:12200109,kEngineHttpFlvProtocolError:12200200,kEngineHttpFlvHttpCodeError:12200201,kEngineHttpFlvParseFlvError:12200202,kEngineHttpFlvServerDisconnectError:12200203,kEngineHttpFlvRedirectError:12200204,kPlayStreamNotExistError:12301004,kMediaServerForbidError:12301011,kMediaServerPublishBadNameError:12301012,kMediaServerStopPublishError:12301014,kConfigDecryptError:20000001,kConfigOfflineError:20000002,kConfigDomainError:20000003,kConfigMediaNetworkNoneError:20000004,kConfigMediaNetworkNoUrlError:20000005,kConfigServerCouldntConnectError:21200007,kConfigServerTimeoutError:21200028,kConfigServerSslCaCertError:21200060,kDispatchServerInvalidError:30000001,kDispatchNoIpError:30000404,kDispatchServerCouldntConnectError:31200007,kDispatchServerTimeoutError:31200028,kDispatchServerSslCaCertError:31200060,kDispatchNotChangedError:32000001,kDispatchEmptyPublishIpsError:32001002,kDispatchEmptyPlayIpsError:32001003,kDispatchStreamNotExistError:32001004,kDispatchAgentTimeoutError:35500001,kDispatchAgentDroppedError:35500002,kLogicServerNoUrlError:40000404,kLogicServerNoIpError:40000405,kLogicServerNoStreamInfoError:40000406,kLogicServerFetalError1:40700001,kLogicServerCouldntConnectError:41200007,kLogicServerTimeoutError:41200028,kLogicServerSslCaCertError:41200060,kLoginAgentTimeoutError:45500001,kLoginAgentDroppedError:45500002,kLiveRoomRequestParamError:50001001,kLiveRoomHBTimeoutError:{code:50001002,message:"liveroom error, hb timeout"},kLiveRoomNoPushServerAddrError:50001003,kLiveRoomNoPushCryptoKeyError:50001004,kLiveRoomNoPushTokenError:50001005,kLiveRoomAutoRetryMaxTimeOut:50001006,kLiveRoomRetryRightNow:50001009,kLiveRoomWaitNetOKWillRetry:50001010,kLiveRoomLogoutWhenLogining:50001011,kLiveRoomLogoutUserCancel:50001012,kLiveRoomHBErrorNoResp:50001050,kLiveRoomHBErrorByHttpTiemout:50001051,kLiveRoomReliableMessageParseBufError:50001200,kLiveRoomReliableMessageTransChannelError:50001201,kLiveRoomReliableUserMessageBufEmpty:50001202,kLiveRoomReliableUserMessageParseBufError:50001203,kLiveRoomGetUserListParseBufError:50001204,kLiveRoomHttpNullPtrError:50001205,kLiveRoomMultiZPushSessionIDNotMatchError:50005021,kLiveRoomMultiLimitRoomCountError:50005022,kLiveRoomCouldntConnectError:51200007,kLiveRoomTimeoutError:51200028,kLiveRoomSslCaCertError:51200060,kLiveRoomInvalidRspError:51400003,kLiveRoomInputParamsError:52000002,kLiveRoomRoomAuthError:52000101,kLiveRoomRoomNotExistError:52000104,kLiveRoomUserNotExistError:52000105,kLiveRoomSetStreamInfoError:52000123,kLiveRoomStreamInfoNotExist:52000138,kLiveRoomSessionError:52000141,kLiveRoomQpsLimitError:52000201,kLiveRoomLuaSessionError:52001001,kLiveRoomAddUserError:52001002,kLiveRoomDelUserError:52001003,kLiveRoomAddTransError:52001009,kLiveRoomMaxUserCountError:52001105,kLiveRoomPublishBadNameError:52001012,kLiveRoomRequiredReloginError:52002001,kLiveRoomThirdTokenAuthError:52002002,kLiveRoomNetBrokenTimeoutError:52002003,kLiveRoomAgentTimeoutError:55500001,kLiveRoomAgentDroppedError:55500002,kRoomConnectError:60001001,kRoomDoHandShakeReqError:60001002,kRoomDoLoginReqError:60001003,kRoomTimeoutError:60001004,kRoomHbTimeoutError:60001005,kRoomStartConnectError:60001006,kRoomReconnectFailError:60001008,kRoomLoginZPushNoCryptoKey:60001009,kRoomLoginCheckMD5Fail:60001010,kRoomRetryIPOver:60001011,kRoomRetryActiveIPError:60001012,kRoomSendLoginNoZPushRsp:60001013,kRoomDoSendLoginMultiRoomReqError:60001014,kRoomZPushTcpClosed:60001015,kRoomConnectErrorQuic:60001016,kRoomInvalidSocketError:60002001,kRoomInvalidRspError:60003001,kRoomDecodeSignError:62001001,kRoomDecodeLoginError:62001002,kRoomReplayAttacksError:62002001,kRoomThirdTokenAuthError:62002002,kRoomLoginCreateUserError:62010001,kRoomLoginSameCreateUserError:62010002,kRoomStatusTimeoutError:62010005,kRoomStatusRspError:62010006,kRoomDispatchTokenBuildError:62030011,kRoomDispatchTokenDecodeError:62030012,kRoomDispatchTokenInvalidError:62030013,kRoomDispatchTokenExpiredError:62030014,kRoomMultipleLoginKickoutError:{code:63000001,message:"zpush multiple login kickout"},kRoomManualKickoutError:{code:63000002,message:"zpush manual kickout"},kRoomSessionErrorKickoutError:{code:63000003,message:"zpush room session error"},kRoomDispatchError:64000001,kRoomDispatchResultNotMatch:64000002,kRoomNoDispatchToken:64000003,kRoomSdkZpushError:65000001,kMixStreamNoneMixConfigError:80000001,kMixStreamCouldntConnectError:81200007,kMixStreamTimeoutError:81200028,kMixStreamSslCaCertError:81200060,kMixStreamFailError:{code:82000001,message:"failure"},kMixStreamInputError:{code:82000002,message:"input params error"},kMixStreamAuthError:{code:82000003,message:"Auth Failure"},kMixStreamNotExistError:{code:82000150,message:"mix stream not exist"},kMixStreamStartMixError:{code:82000151,message:"mix stream fail"},kMixStreamStopMixError:{code:82000152,message:"unmix stream fail"},kMixStreamInputFormatError:{code:82000155,message:"mix stream input format error"},kMixStreamOutputFormatError:{code:82000156,message:"mix stream output format error"},kMixStreamNotOpenError:{code:82000157,message:"mix not open"},kMixStreamInputExceedError:{code:82000158,message:"mix stream input exceed"},kMixStreamDispatchError:{code:82000159,message:"mix_dispatch fail"},kMixStreamStopMixOwnerError:{code:82000160,message:"unmix owner fail"},kMixStreamWaterMarkParamError:{code:82000170,message:"water mark params error"},kMixStreamWaterMarkImageError:{code:82000171,message:"water mark image empty"},kMixStreamQpsOverloadError:{code:82000190,message:"mix_start qps overload"},kMixStreamAgentTimeoutError:85500001,kMixStreamAgentDroppedError:85500002,kInitSdkError:{code:2001100001,message:"login but init sdk wrong"},kScreenSharingFail:{code:2001100002,message:"screen share fail"},kEnumerateDevicesFail:{code:2001100003,message:"enumerate devices fail"},kMixVideocError:{code:2001100004,message:"mix video code type wrong"},kWxGetSettingFail:{code:2001100005,message:"wx getsetting fail"},kDevicesDetectError:{code:2001100006,message:"devices detect error"},kVideoCodecDetectError:{code:2001100007,message:"videoCodec detect error"},kMixStopFail:{code:2001100008,message:"stop mix stream fail"},kLoginTimeoutError:{code:2001110001,message:"login timeout"},kSendMsgTimeout:{code:2001110002,message:"send customsg timeout."},kLiveRoomDisconnect:{code:2001110003,message:"network is broken and login fail."},kMsgFrequencyLimited:{code:2001110004,message:"send msg freq error"},kLiveRoomNotLoginError:{code:2001110005,message:"liveroom not login"},kLiveRoomMessageParseError:{code:2001110006,message:"message parse error"},kLiveRoomMessageNoneError:{code:2001110007,message:"message none error"},kBrowserNotSupport:{code:2001120001,message:"browser do not support"},kHttpsRequired:{code:2001120002,message:"https or localhost required"},kDispatchError:{code:2001120003,message:"dispatch request error"},kDispatchTimeout:{code:2001120004,message:"dispatch request timeout"},kTokenError:{code:2001120005,message:"login token error"},kSendSessionTimeout:{code:2001120006,message:"send session request timeout"},kCreateSessionError:{code:2001120007,message:"create session error"},kCreateOfferError:{code:2001120008,message:"create offer error"},kSetLocalDescError:{code:2001120009,message:"setLocalDescription error"},kSendMediaDescTimeout:{code:2001120010,message:"send mediaDesc timeout"},kServerMediaDescTimeout:{code:2001120011,message:"waiting server mediaDesc timeout"},kServerMediaDescError:{code:2001120012,message:"server mediaDesc type error"},kSetRemoteDescError:{code:2001120013,message:"other side offer error"},kSendCandidateTimeout:{code:2001120014,message:"sendIceCandidate error"},kServerCandidateTimeout:{code:2001120015,message:"waiting candidate timeout"},kServerCandidateError:{code:2001120016,message:"recv candidate error"},kSessionClosed:{code:2001120017,message:"server session closed"},kMediaConnectionFailed:{code:2001120018,message:"Iice Connection state failed"},kMediaConnectionClosed:{code:2001120019,message:"ice connection state closed"},kWebsocketError:{code:2001120020,message:"network error"},kConstraintError:{code:2001120021,message:"constraint error"},kMediaConnectionDisconnected:{code:2001120022,message:"ice connection state disconnected"},kServerNegoTimeout:{code:2001120023,message:"negotiation timeout"},kLocalStreamError:{code:2001120024,message:"local stream error"},kPublishConstraintsNotSupport:{code:2001120025,message:"publish constraints is not supported"},kGetSoundLevelError:{code:2001120026,message:"get sound level error"},kPublishStreamNotFound:{code:2001120027,message:"publish stream not found"},kPublisherRepeatError:{code:2001120028,message:"publisher already exist, publish repeat"},kPlayerRepeatError:{code:2001120029,message:"player already exist, play repeat"},kStopWhenPublishing:{code:2001120030,message:"stop publish when publishing error"},kStopWhenPlaying:{code:2001120031,message:"stop play when playing error"},kPublishRetryFail:{code:2001120032,message:"publish retry fail"},kPlayRetryFail:{code:2001120033,message:"play retry fail"},kUrlsNone:{code:2001120034,message:"url none"},kIsPublishing:{code:2001120035,message:"stream is publishing"},kIsPlaying:{code:2001120035,message:"stream is pulling"},kDecodeAudioDataFail:{code:2001120036,message:"decode audio fail"},kNoPreviewBeforePublish:{code:2001120037,message:"stream is not created by zego"}},t.codeErrMap={2000000001:"kInitSdkError",2000000002:"kInvalidParamError",2000000005:"kScreenSharingFail",2000000007:"kEnumerateDevicesFail",2000000008:"kNotLoginError",2000000009:"kMixStopFail",2000000010:"kMixVideocError",2001000002:"kLiveRoomHBTimeoutError",2001000003:"kLoginTimeoutError","Error.Network":"kLiveRoomDisconnect","Error.requencyLimited":"kMsgFrequencyLimited",2002000001:"kInvalidParamError",2002000002:"kBrowserNotSupport",2002000003:"kDispatchError",2002000004:"kDispatchTimeout",2002000005:"kTokenError",2002000006:"kSendSessionTimeout",2002000007:"kCreateSessionError",2002000008:"kCreateOfferError",2002000009:"kSetLocalDescError",2002000010:"kSendMediaDescTimeout",2002000011:"kServerMediaDescTimeout",2002000012:"kServerMediaDescError",2002000013:"kSetRemoteDescError",2002000014:"kSendCandidateTimeout",2002000015:"kServerCandidateTimeout",2002000016:"kServerCandidateError",2002000017:"kSessionClosed",2002000018:"kMediaConnectionFailed",2002000019:"kMediaConnectionClosed",2002000020:"kWebsocketError",2002000021:"kConstraintError",2002000022:"kMediaConnectionDisconnected",2002000023:"kServerNegoTimeout",2003000003:"kDispatchError",2003000004:"kDispatchTimeout",2003000005:"kTokenError",2003000006:"kSendSessionTimeout",2003000007:"kCreateSessionError",2003000008:"kCreateOfferError",2003000009:"kSetLocalDescError",2003000010:"kSendMediaDescTimeout",2003000011:"kServerMediaDescTimeout",2003000012:"kServerMediaDescError",2003000013:"kSetRemoteDescError",2003000014:"kSendCandidateTimeout",2003000015:"kServerCandidateTimeout",2003000016:"kServerCandidateError",2003000017:"kSessionClosed",2003000018:"kMediaConnectionFailed",2003000019:"kMediaConnectionClosed",2003000020:"kWebsocketError",2003000021:"kConstraintError",2003000022:"kMediaConnectionDisconnected",2003000023:"kServerNegoTimeout"}},function(e,t,r){"use strict";var i=this&amp;&amp;this.__spreadArrays||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=0,t=0,r=arguments.length;t&lt;r;t++)<span class="cstat-no" title="statement not covered" >e+=arguments[t].length;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Array(e),</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;r;t++)<span class="cstat-no" title="statement not covered" >for(var o=arguments[t],n=0,a=o.length;n&lt;a;n++,s++)<span class="cstat-no" title="statement not covered" >i[s]=o[n];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>;Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function <span class="fstat-no" title="function not covered" >e(</span>){}return e.zegoSdp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.split("\r\n"),</span>r=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.match(/a=rtpmap:(\d+)\s+((H264\/90000)|(opus\/48000\/2))/);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t[1]&amp;&amp;t[2]&amp;&amp;("H264/90000"===t[2]&amp;&amp;r.push(t[1]),"opus/48000/2"===t[2]&amp;&amp;s.push(t[1]))}</span>));v</span>ar o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >!0,</span>n=<span class="cstat-no" title="statement not covered" >e.match(/((a=rtcp-fb:)|(a=rtpmap:)|(a=fmtp:))(\d+)/);<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n[5]&amp;&amp;(i(r,s).some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e==n[5]}</span>))||(t=!1)),e.indexOf("m=video")&gt;-1){var a=<span class="cstat-no" title="statement not covered" >e.split(" ");<span class="cstat-no" title="statement not covered" ></span>e=i([a[0],a[1],a[2]],r).join(" ")}</span>else <span class="cstat-no" title="statement not covered" >if(e.indexOf("m=audio")&gt;-1){<span class="cstat-no" title="statement not covered" >a=e.split(" ");<span class="cstat-no" title="statement not covered" >e</span>=i([a[0],a[1],a[2]],s).join(" ")}<span class="cstat-no" title="statement not covered" ></span>t</span></span>&amp;&amp;o.push(e)}</span>)),o.join("\r\n")}</span>,e.getSDPByVideDecodeType=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >{str:"",arr:[],obj:{H264:[],H265:[],VP8:[],VP9:[],OHTER:[]}};<span class="cstat-no" title="statement not covered" ></span>if(!e.includes("m=video"))<span class="cstat-no" title="statement not covered" >return e;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >/m=video.+/.exec(e)[0];<span class="cstat-no" title="statement not covered" ></span>s=s.match(/[\s|\d]+/g)[1].replace(" ",""),r.str=s,r.arr=r.str.split(" "),r.arr.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >new RegExp("a=rtpmap:"+t+".+").exec(e)[0];<span class="cstat-no" title="statement not covered" ></span>i.includes("H264")?r.obj.H264.push(t):i.includes("H265")?r.obj.H265.push(t):i.includes("VP8")?r.obj.VP8.push(t):i.includes("VP9")?r.obj.VP9.push(t):r.obj.OHTER.push(t)}</span>)),r.obj.OHTER.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >new RegExp("a=fmtp:"+t+".+apt=(\\d+)").exec(e),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i[1];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;(r.obj.H264.includes(s)?r.obj.H264.push(t):r.obj.H265.includes(s)?r.obj.H265.push(t):r.obj.VP8.includes(s)?r.obj.VP8.push(t):r.obj.VP9.includes(s)&amp;&amp;r.obj.VP9.push(t))}</span>));v</span>ar o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return"VP9"===t?o=i(r.obj.H265,r.obj.H264,r.obj.VP8):"VP8"===t?o=i(r.obj.H265,r.obj.H264,r.obj.VP9):"H264"===t?o=i(r.obj.H265,r.obj.VP8,r.obj.VP9):"H265"===t&amp;&amp;(o=i(r.obj.VP8,r.obj.H264,r.obj.VP9)),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >r.arr.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>r.arr.splice(i,1);v</span>ar s=<span class="cstat-no" title="statement not covered" >new RegExp("a=rtpmap:"+t+".+\\s\\n","g"),</span>o=<span class="cstat-no" title="statement not covered" >new RegExp("a=rtcp-fb:"+t+".+\\s\\n","g"),</span>n=<span class="cstat-no" title="statement not covered" >new RegExp("a=fmtp:"+t+".+\\s\\n","g");<span class="cstat-no" title="statement not covered" ></span>e=(e=(e=e.replace(s,"")).replace(o,"")).replace(n,"")}</span>)),e=e.replace(s,r.arr.join(" "))}</span>,e}();t.SdpUtil=s},function(e,t,r){"use strict";var i,s=this&amp;&amp;this.__extends||(i=function(e,t){return(i=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.__proto__=t}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(r)&amp;&amp;(e[r]=t[r])}</span></span>)</span>(e,t)},function(e,t){function r(){this.constructor=e}i(e,t),e.prototype=null===t?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(t):</span>(r.prototype=t.prototype,new r)}),o=this&amp;&amp;this.__assign||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(o=Object.assign||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t,r=1,i=arguments.length;r&lt;i;r++)<span class="cstat-no" title="statement not covered" >for(var s in t=arguments[r])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,s)&amp;&amp;(e[s]=t[s]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>).apply(this,arguments)}</span>;Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(7),c=r(9),d=r(3),l=r(18),u=r(26),h=r(27),p=r(28),g=r(1),m=r(29),f=r(2),v=r(4),S=function(e){function t(t,r){var i=e.call(this)||<span class="branch-1 cbranch-no" title="branch not covered" >this,</span>s=new u.StateCenter,o=new a.LoggerWeb(s);i.dataReport=new m.ZegoDataReport(o),i.ac=new("undefined"!=typeof webkitAudioContext?<span class="branch-0 cbranch-no" title="branch not covered" >webkitAudioContext:</span>AudioContext);var l=new c.ZegoStreamCenterWeb(o,s,i.dataReport,i.ac);i.streamCenter=l,i.logger=o,i.stateCenter=s,i.stateCenter.clientType="rtc";var h=f.getReportSeq();return i.dataReport.newReport(h),i.init(),d.ClientUtil.setDebug(r,i.stateCenter),d.ClientUtil.checkConfigParam(t,r,o)?(i.stateCenter.appid=t,"string"==typeof r?(i.stateCenter.server=r,i.stateCenter.serverBak=r):<span class="branch-1 cbranch-no" title="branch not covered" >Array.isArray(r)&amp;&amp;r.length&gt;0&amp;&amp;(i.stateCenter.server=r[0],i.stateCenter.serverBak=r[1]||r[0]),</span>i.stateCenter.configOK=!0,i.bindWindowListener(),o.info("zc.0 "+navigator.appVersion),i.dataReport.addMsgInfo(h,{system_info:navigator.appVersion})):(<span class="branch-1 cbranch-no" title="branch not covered" >o.error("zc.0 init sdk error"),i.dataReport.addMsgInfo(h,{error:v.errorList.kInvalidParamError.code,message:v.errorList.kInvalidParamError.message}))</span>,i.logger.setSessionInfo(i.stateCenter.appid,"","","","",n.PROTO_VERSION),i.dataReport.uploadReport(h,v.eventList.kZegoTaskInitSetting),i}return s(t,e),t.prototype.getSocket=function(e){return new WebSocket(e)},t.prototype.on=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.bindListener(e,t)}</span>,t.prototype.off=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.deleteListener(e,t)}</span>,t.prototype.mutePublishStreamVideo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>this.dataReport.newReport(r,v.eventList.kZegoTaskMutePublishVideo);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.enableStream(e,{video:!t});<span class="cstat-no" title="statement not covered" ></span>return this.dataReport.uploadReport(r),i}</span>,t.prototype.mutePublishStreamAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>this.dataReport.newReport(r,v.eventList.kZegoTaskMutePublishAudio);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.enableStream(e,{audio:!t});<span class="cstat-no" title="statement not covered" ></span>return this.dataReport.uploadReport(r),i}</span>,t.prototype.enableStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zc.p.ec.0 call"),"boolean"!=typeof t.video&amp;&amp;"boolean"!=typeof t.audio)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.es.0 option error"),!1;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >!0,</span>i=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>return"boolean"==typeof t.video&amp;&amp;(r=this.streamCenter.enableCamera(e,t.video)),"boolean"==typeof t.audio&amp;&amp;(i=this.streamCenter.enableMicrophone(e,t.audio)),r&amp;&amp;i}</span>,t.prototype.setAudioOutput=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.p.slao call"),"string"!=typeof t?(console.error("audiooutput is not string"),!1):this.streamCenter.setStreamAudioOutput(e,t)}</span>,t.prototype.setCustomSignalUrl=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zc.p.scs.0 call: "+e),!e||0==e.length)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.scs.0 param error"),!1;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0!=e.indexOf("wss://")&amp;&amp;(t=!1)}</span>)),t?this.stateCenter.customUrl=e:this.logger.error("zc.p.scs.0 url is not correct")}</span>,t.prototype.setQualityMonitorCycle=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"number"==typeof e&amp;&amp;e&gt;=1e3?(this.streamCenter.setQualityMonitorCycle(e),!0):(this.logger.error("zc.sqmc.0 time must be number and bigger than 1000"),!1)}</span>,t.prototype.startPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zc.p.sps.0 call");v</span>ar i=<span class="cstat-no" title="statement not covered" >this.streamCenter.getTotalStreamId(e);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){var a=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(r.stateCenter.reportSeqList.startPlay[i]=a,r.dataReport.newReport(a,v.eventList.kZegoTaskPlayStart),"string"!=typeof e||""===e)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sps.0 streamID must be string and not empty"),r.dataReport.uploadReport(a,void 0,v.errorList.kInvalidParamError,"stream id type error"),o(v.errorList.kInvalidParamError),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0!==t&amp;&amp;"object"!=typeof t)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sps.0 playOption must be object"),r.dataReport.uploadReport(a,void 0,v.errorList.kInvalidParamError,"playOption must be object"),o(v.errorList.kInvalidParamError),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.stateCenter.customUrl&amp;&amp;r.stateCenter.customUrl.length&gt;0)<span class="cstat-no" title="statement not covered" >return r.streamCenter.setPlayStateStart(e,t)?r.streamCenter.startPlayingStream(e,r.stateCenter.customUrl,s):(r.logger.error("zc.p.sps.0 cannot start play"),o(g.playErrorList.REPEATED_PULL),!1);<span class="cstat-no" title="statement not covered" >i</span></span>f(r.dataReport.addMsgInfo(a,{streamID:e,playOption:t}),!r.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sps.0 not login"),r.dataReport.uploadReport(a,void 0,v.errorList.kNotLoginError),o(v.errorList.kNotLoginError),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var c=!1,d=0;d&lt;r.stateCenter.streamList.length;d++)<span class="cstat-no" title="statement not covered" >if(r.stateCenter.streamList[d].stream_id===e){<span class="cstat-no" title="statement not covered" >c=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(0==c&amp;&amp;r.logger.info("zc.p.sps.0 cannot find stream"),r.stateCenter.pullLimited||(e=NaN+e),t&amp;&amp;t.videoCodec&amp;&amp;(t.videoCodec=t.videoCodec.toUpperCase()),!r.streamCenter.setPlayStateStart(e,t))<span class="cstat-no" title="statement not covered" >return r.logger.info("zc.p.sps.0 cannot start play"),o(g.playErrorList.REPEATED_PULL),!1;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >{stream_id:e,ptype:"pull",signals:r.streamCenter.getAllInUseUrl()};<span class="cstat-no" title="statement not covered" ></span>return r.streamCenter.playSuccessCallBackList[e]=s,r.socketCenter.registerRouter("webrtc_url",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handleFetchWebRtcUrlRsp(e)}</span>)),r.socketCenter.sendMessage("webrtc_url",l,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >r.logger.info("zc.p.sps.0 dispatch error"),t==n.sdkErrorList.SEND_MSG_TIMEOUT?r.streamCenter.onPlayStateUpdate(n.ENUM_PLAY_STATE_UPDATE.error,e,g.playErrorList.DISPATCH_TIMEOUT):r.streamCenter.onPlayStateUpdate(n.ENUM_PLAY_STATE_UPDATE.error,e,g.playErrorList.DISPATCH_ERROR),r.streamCenter.stopPlayingStream(e)}</span>)),!0}</span>))}</span>,t.prototype.stopPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zc.p.sps.1.0 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >this.streamCenter.getTotalStreamId(e),</span>r=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.reportSeqList.stopPlay[t]=r,this.dataReport.newReport(r,v.eventList.kZegoTaskPlayStop),"string"!=typeof e||""===e)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1.0 streamid must be string and not empty"),this.dataReport.uploadReport(r,void 0,v.errorList.kInvalidParamError,"stream id type error"),void delete this.stateCenter.reportSeqList.stopPlay[t];v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[t];<span class="cstat-no" title="statement not covered" ></span>if(!i||0==i.serverUrls.length)<span class="cstat-no" title="statement not covered" >return i&amp;&amp;this.logger.error("zc.p.sps.1.0 stream can not be destroyed"),this.dataReport.uploadReport(r,void 0,v.errorList.kIsPlaying,"can not be destroyed"),void delete this.stateCenter.reportSeqList.stopPlay[t];<span class="cstat-no" title="statement not covered" >f</span></span>or(var s in this.streamCenter.stopPlayingStream(e),this.stateCenter.streamUrlMap)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.streamUrlMap[s]===e){<span class="cstat-no" title="statement not covered" >delete this.stateCenter.streamUrlMap[s];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.dataReport.uploadReport(r),this.logger.debug("zc.p.sps.1.0 call success")}</span>,t.prototype.createStream=function(e){var r=this;return this.logger.debug("zc.p.sp.0 call"),e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.camera&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.camera.audioBitRate&amp;</span>&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >e.camera.audioBitrate=e.camera.audioBitRate)</span>,e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.camera&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.camera.bitrate&amp;</span>&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >e.camera.bitRate=e.camera.bitrate)</span>,e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.screen&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >"object"==typeof e.screen&amp;</span>&amp;<span class="branch-3 cbranch-no" title="branch not covered" >e.screen.bitrate&amp;</span>&amp;(<span class="branch-4 cbranch-no" title="branch not covered" >e.screen.bitRate=e.screen.bitrate)</span>,e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.custom&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.custom.bitrate&amp;</span>&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >e.custom.bitRate=e.custom.bitrate)</span>,new Promise((function(i,s){var o=f.getReportSeq();r.dataReport.newReport(o,v.eventList.kZegoTaskCreateStream);var n=function(e){r.dataReport.uploadReport(o),i(e)},a=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >void 0===t&amp;&amp;(t="");v</span>ar i=<span class="cstat-no" title="statement not covered" >v.codeErrMap[e.code];<span class="cstat-no" title="statement not covered" ></span>i?r.dataReport.addMsgInfo(o,{error:v.errorList[i].code,message:v.errorList[i].message+t}):r.dataReport.addMsgInfo(o,{error:e.code,message:e.msg}),r.dataReport.uploadReport(o),s(e)}</span>;<span class="missing-if-branch" title="if path not taken" >I</span>if("https:"!==window.location.protocol&amp;&amp;"file:"!==window.location.protocol&amp;&amp;-1==window.location.hostname.indexOf("127.0.0.1")&amp;&amp;-1==window.location.hostname.indexOf("localhost"))<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 https or localhost required "),r.dataReport.addMsgInfo(o,{error:v.errorList.kHttpsRequired.code,message:v.errorList.kHttpsRequired.message}),r.dataReport.uploadReport(o),void s(g.publishErrorList.BROWSER_NOT_SUPPORT);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.screen)</span>{<span class="cstat-no" title="statement not covered" >if("object"==typeof e.screen&amp;&amp;e.screen.bitRate){<span class="cstat-no" title="statement not covered" >if("number"!=typeof e.screen.bitRate)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 bitrate must be number"),void a(g.publishErrorList.PARAM," bitrate must be number");<span class="cstat-no" title="statement not covered" >i</span></span>f(e.screen.bitRate&gt;10240)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 bitrate cannot greater than 10 Mbps"),void s(g.publishErrorList.PARAM+" bitrate cannot greater than 10 Mbps")}</span></span>v</span>ar c=<span class="cstat-no" title="statement not covered" >d.ClientUtil.getBrowser(),</span>l=<span class="cstat-no" title="statement not covered" >r.streamCenter.getScreenConstrains(e.screen);<span class="cstat-no" title="statement not covered" ></span>r.dataReport.addMsgInfo(o,{stream_type:"screen",screen:l}),"Firefox"==c&amp;&amp;r.startScreenShotFirFox("screen",l,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,i){<span class="cstat-no" title="statement not covered" >e?(r.streamCenter.createScreenPreviewer(t,l)&amp;&amp;n(t),t.getVideoTracks()[0].onended=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>r.dataReport.newReport(e),r.dataReport.uploadReport(e,v.eventList.kZegoTaskScreenSharingEnded),t&amp;&amp;r.streamCenter.stopPreview(t),r.stateCenter.actionListener("screenSharingEnded",t)}</span>):i&amp;&amp;a(i)}</span>)),("Chrome"==c||"Safari"==c)&amp;&amp;r.startScreenSharing(l,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,s){<span class="cstat-no" title="statement not covered" >e?(r.streamCenter.createScreenPreviewer(i,l)&amp;&amp;n(i),i.getVideoTracks()[0].onended=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>r.dataReport.newReport(e),r.dataReport.uploadReport(e,v.eventList.kZegoTaskScreenSharingEnded),i&amp;&amp;r.streamCenter.stopPreview(i),r.stateCenter.actionListener("screenSharingEnded",i)}</span>):"Chrome"!=c||!t.screenShotReady||s&amp;&amp;-1!==s.msg.indexOf("NotAllowedError")?s&amp;&amp;a(s):r.startScreenShotChrome((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,i){<span class="cstat-no" title="statement not covered" >e?(r.streamCenter.createScreenPreviewer(t)&amp;&amp;n(t),t.getVideoTracks()[0].onended=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>r.dataReport.newReport(e),r.dataReport.uploadReport(e,v.eventList.kZegoTaskScreenSharingEnded),t&amp;&amp;r.streamCenter.stopPreview(t),r.stateCenter.actionListener("screenSharingEnded",t)}</span>):i&amp;&amp;a(i)}</span>))}</span>))}</span>else{<span class="missing-if-branch" title="if path not taken" >I</span>if(e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.camera&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.camera.audioBitrate)</span>{<span class="cstat-no" title="statement not covered" >if("number"!=typeof e.camera.audioBitrate)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 audioBitrate must be number"),void a(g.publishErrorList.PARAM," audioBitrate must be number");<span class="cstat-no" title="statement not covered" >i</span></span>f(e.camera.audioBitrate&lt;6)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 audioBitrate cannot less 6 kbps"),void a(g.publishErrorList.PARAM," audioBitrate cannot less 6 kbps");<span class="cstat-no" title="statement not covered" >i</span></span>f(e.camera.audioBitrate&gt;510)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 audioBitrate cannot greater than 510 kbps"),void a(g.publishErrorList.PARAM," audioBitrate cannot greater than 510 kbps");<span class="cstat-no" title="statement not covered" >r</span></span>.stateCenter.audioBitRate=1e3*e.camera.audioBitrate}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.camera&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.camera.bitRate)</span>{<span class="cstat-no" title="statement not covered" >if("number"!=typeof e.camera.bitRate)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 bitrate must be number"),void a(g.publishErrorList.PARAM," bitrate must be number");<span class="cstat-no" title="statement not covered" >i</span></span>f(e.camera.bitRate&gt;10240)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 bitrate cannot greater than 10 Mbps"),void a(g.publishErrorList.PARAM," bitrate cannot greater than 10 Mbps")}<span class="missing-if-branch" title="if path not taken" >I</span></span></span>if(e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.custom&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.custom.bitRate)</span>{<span class="cstat-no" title="statement not covered" >if("number"!=typeof e.custom.bitRate)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 bitrate must be number"),void a(g.publishErrorList.PARAM," bitrate must be number");<span class="cstat-no" title="statement not covered" >i</span></span>f(e.custom.bitRate&gt;10240)<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.p.sp.0 bitrate cannot greater than 10 Mbps"),void a(g.publishErrorList.PARAM," bitrate cannot greater than 10 Mbps")}</span></span>var u={};e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.camera?</span>(<span class="branch-0 cbranch-no" title="branch not covered" >u=e.camera,r.dataReport.addMsgInfo(o,{stream_type:"camera",camera:e.camera}),"boolean"!=typeof u.video&amp;&amp;(u.video=!0),"boolean"!=typeof u.audio&amp;&amp;(u.audio=!0))</span>:e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.custom&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >u=e.custom,r.dataReport.addMsgInfo(o,{stream_type:"custom",custom:e.custom}))</span>,r.streamCenter.startPreview(u,n,a)}}))},t.prototype.destroyStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zc.p.sp.1 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.newReport(t),!(e instanceof MediaStream)||e instanceof MediaStream&amp;&amp;0==e.getTracks().length)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sp.1 localStream is not mediaStream or tracks is null"),this.dataReport.addMsgInfo(t,{error:v.errorList.kLocalStreamError.code,message:v.errorList.kLocalStreamError.message}),void this.dataReport.uploadReport(t,v.eventList.kZegoTaskDestroyStream);<span class="cstat-no" title="statement not covered" >t</span></span>his.streamCenter.stopPreview(e),this.dataReport.uploadReport(t,v.eventList.kZegoTaskDestroyStream)}</span>,t.prototype.startPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zc.sps.0 call");v</span>ar s=<span class="cstat-no" title="statement not covered" >this.streamCenter.getTotalStreamId(e),</span>o=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.reportSeqList.startPublish[s]=o,this.dataReport.newReport(o,v.eventList.kZegoTaskPublishStart),!e||"string"!=typeof e){var a=<span class="cstat-no" title="statement not covered" >"stream id type wrong";<span class="cstat-no" title="statement not covered" ></span>return this.logger.error("zc.sps.0 "+a),this.dataReport.uploadReport(o,void 0,v.errorList.kInvalidParamError,a),delete this.stateCenter.reportSeqList.startPublish[s],!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t||t instanceof MediaStream&amp;&amp;0==t.getTracks().length){<span class="cstat-no" title="statement not covered" >a="localStream wrong";<span class="cstat-no" title="statement not covered" >r</span>eturn this.logger.error("zc.sps.0 "+a),this.dataReport.uploadReport(o,void 0,v.errorList.kInvalidParamError,a),delete this.stateCenter.reportSeqList.startPublish[s],!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.streamCenter.checkPreview(t)){<span class="cstat-no" title="statement not covered" >a="stream is not from zego";<span class="cstat-no" title="statement not covered" >r</span>eturn this.logger.error("zc.sps.0 "+a),this.dataReport.uploadReport(o,void 0,v.errorList.kNoPreviewBeforePublish,a),delete this.stateCenter.reportSeqList.startPublish[s],!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(void 0!==r&amp;&amp;"object"!=typeof r)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.0 publishOption must be object"),this.dataReport.uploadReport(o,void 0,v.errorList.kInvalidParamError,"publishOption must be object"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1 not login"),this.dataReport.uploadReport(o,void 0,v.errorList.kNotLoginError),delete this.stateCenter.reportSeqList.startPublish[s],!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r||(r={}),r.audioBitRate=this.stateCenter.audioBitRate,r&amp;&amp;r.videoCodec&amp;&amp;(r.videoCodec=r.videoCodec.toUpperCase()),this.dataReport.addMsgInfo(o,{streamID:e,publishOption:r}),this.stateCenter.customUrl&amp;&amp;0!=this.stateCenter.customUrl.length)<span class="cstat-no" title="statement not covered" >return this.stateCenter.publishStreamList[e]={state:n.ENUM_PUBLISH_STREAM_STATE.tryPublish,extra_info:r.extraInfo?r.extraInfo:null},this.streamCenter.setPublishStateStart(e,t,r)?this.streamCenter.startPublishingStream(e,this.stateCenter.customUrl):(this.logger.info("zc.p.sps.1 cannot start publish"),!1);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.stateCenter.publishStreamList[e]={state:n.ENUM_PUBLISH_STREAM_STATE.tryPublish,extra_info:r.extraInfo?r.extraInfo:null},!this.streamCenter.setPublishStateStart(e,t,r))<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1 cannot start publish"),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.info("zc.p.sps.1 start publish");v</span>ar c=<span class="cstat-no" title="statement not covered" >{stream_id:e,ptype:"push",signals:this.streamCenter.getAllInUseUrl(),header_kvs:[{key:"grpc-metadata-push",value:r&amp;&amp;r.cdnUrl||""}]};<span class="cstat-no" title="statement not covered" ></span>return this.socketCenter.registerRouter("webrtc_url",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.handleFetchWebRtcUrlRsp(e)}</span>)),this.socketCenter.sendMessage("webrtc_url",c,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.logger.info("zc.p.sps.1 dispatch error"),t==n.sdkErrorList.SEND_MSG_TIMEOUT?i.streamHandler.onPublishStateUpdate(n.ENUM_PUBLISH_STATE_UPDATE.error,e,g.publishErrorList.DISPATCH_TIMEOUT):i.streamHandler.onPublishStateUpdate(n.ENUM_PUBLISH_STATE_UPDATE.error,e,g.publishErrorList.DISPATCH_ERROR),i.streamCenter.stopPublishingStream(e)}</span>)),!0}</span>,t.prototype.stopPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zc.p.sps.1.1 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >this.streamCenter.getTotalStreamId(e),</span>r=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.reportSeqList.stopPublish[t]=r,this.dataReport.newReport(r,v.eventList.kZegoTaskPublishStop),"string"!=typeof e||""==e)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1.1 streamID must be string and not empty"),this.dataReport.uploadReport(r,void 0,v.errorList.kInvalidParamError,"stream id type error"),delete this.stateCenter.reportSeqList.stopPublish[t],!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.streamCenter.publisherList[t];<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;0!=i.serverUrls.length&amp;&amp;i.publisher.signal?(this.streamCenter.stopPublishingStream(e),this.stateCenter.publishStreamList[e]&amp;&amp;(this.stateCenter.publishStreamList[e].state&gt;=n.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;this.streamHandler.updateStreamInfo(e,n.ENUM_STREAM_SUB_CMD.liveEnd),delete this.stateCenter.publishStreamList[e]),this.dataReport.uploadReport(r),!0):(i&amp;&amp;this.logger.error("zc.p.sps.1.1 stream can not be destroyed"),this.dataReport.uploadReport(r,void 0,v.errorList.kIsPublishing,"can not be destroyed"),delete this.stateCenter.reportSeqList.stopPublish[t],!1)}</span>,t.prototype.setPublishStreamConstraints=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this.logger.info("zc.spsc.0 call"),new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(i,s){var o=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(t.videoInput?r.dataReport.newReport(o,v.eventList.kZegoTaskUseVideoDevice):r.dataReport.newReport(o,v.eventList.kZegoTaskUseAudioDevice),!(e instanceof MediaStream))<span class="cstat-no" title="statement not covered" >return r.logger.error("zc.sc.0 localStream not found"),r.dataReport.addMsgInfo(o,{error:v.errorList.kLocalStreamError.code,message:v.errorList.kLocalStreamError.message}),r.dataReport.uploadReport(o),void s(g.publishErrorList.PARAM);<span class="cstat-no" title="statement not covered" >r</span></span>.streamCenter.setPublishStreamConstraints(e,t,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >r.dataReport.uploadReport(o),i()}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;1==e.code?(r.dataReport.addMsgInfo(o,{error:v.errorList.kPublishConstraintsNotSupport.code,checkMessageTimeout:v.errorList.kPublishConstraintsNotSupport.message}),r.dataReport.uploadReport(o)):v.codeErrMap[e.code]&amp;&amp;(r.dataReport.addMsgInfo(o,{error:v.errorList.kConstraintError.code,checkMessageTimeout:v.errorList.kConstraintError.message}),r.dataReport.uploadReport(o)),s(e)}</span>))}</span>))}</span>,t.prototype.preloadEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >e&amp;&amp;"number"==typeof e&amp;&amp;t&amp;&amp;"string"==typeof t?this.stateCenter.audioEffectBuffer[e]?this.logger.error("zc.pe.0 audio buffer already exists"):(this.logger.info("zc.pe.0 start preload effect"),this.streamCenter.preloadEffect(this.ac,e,t,r)):this.logger.error("zc.pe.0 params error")}</span>,t.prototype.playEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >e.streamID&amp;&amp;"string"==typeof e.streamID&amp;&amp;e.effectId&amp;&amp;"number"==typeof e.effectId?this.stateCenter.audioEffectBuffer[e.effectId]?this.streamCenter.playEffect(e,t,r):this.logger.error("zc,pe.1 audio buffer dosesn't exists"):this.logger.error("zc.pe.1 params error")}</span>,t.prototype.pauseEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;"string"==typeof e?this.streamCenter.pauseEffect(e):this.logger.error("zc.pe.2 streamID format error")}</span>,t.prototype.resumeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;"string"==typeof e?this.streamCenter.resumeEffect(e):this.logger.error("zc.re.0 streamID format error")}</span>,t.prototype.unloadEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"number"==typeof e?(delete this.stateCenter.audioEffectBuffer[e],!0):(this.logger.error("zc.ue.0 params error"),!1)}</span>,t.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.sma.0 call"),e&amp;&amp;"string"==typeof e?t?Array.isArray(t)&amp;&amp;0!==t.length?this.streamCenter.startMixingAudio(e,t):(this.logger.error("zc.sma.0 audio param type error"),!1):(this.logger.error("zc.sma.0 no audio"),!1):(this.logger.error("zc.sma.0 stream id type error"),!1)}</span>,t.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"string"==typeof e?Array.isArray(t)&amp;&amp;0!==t.length||void 0===t?this.streamCenter.stopMixingAudio(e,t):(this.logger.error("zc.sma.0 audio param type error"),!1):(this.logger.error("zc.sma.1 param streamID format error"),!1)}</span>,t.prototype.mixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >return this.logger.info("zc.mb.0 call "+t),e&amp;&amp;"string"==typeof e?t&amp;&amp;"string"==typeof t?void this.streamCenter.mixingBuffer(e,t,r,i):(this.logger.error("zc.mb.0 param source id format error"),!1):(this.logger.error("zc.mb.0 param streamid format error"),!1)}</span>,t.prototype.stopMixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.logger.info("zc.smb.0 call "+t),e&amp;&amp;"string"==typeof e?t&amp;&amp;"string"==typeof t?this.streamCenter.stopMixingBuffer(e,t):(this.logger.error("zc.sma.1 param source id format error"),!1):(this.logger.error("zc.sma.1 param streamid format error"),!1)}</span>,t.prototype.setMixingAudioVolume=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.sma.2 call"),"string"!=typeof e||""==e?(this.logger.error("zc.sma.2 stream ID must be string and not empty"),!1):"number"!=typeof t||t&lt;0||t&gt;100?(this.logger.error("zc.sma.2 volume must be a number between 0 and 100"),!1):this.streamCenter.setMixingAudioVolume(e,t)}</span>,t.prototype.startScreenShotChrome=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(t.screenShotReady)<span class="cstat-no" title="statement not covered" >window.postMessage({type:"SS_UI_REQUEST",text:"start"},"*"),d.ClientUtil.registerCallback("screenShare",{success:e},this.stateCenter.callbackList);e</span>lse{var r=<span class="cstat-no" title="statement not covered" >'zc.b.ss Please install the extension:1. Go to chrome://extensions  2. Check: "Enable Developer mode   3. Click: "Load the unpacked extension... 4. Choose "extension" folder from the repository 5. Reload this page';<span class="cstat-no" title="statement not covered" ></span>this.logger.error(r),e(!1,null,{code:g.commonErrorList.SCREEN.code,msg:g.commonErrorList.SCREEN.msg+" "+r})}</span>}</span>,t.prototype.startScreenSharing=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>"getDisplayMedia"in navigator.mediaDevices?navigator.mediaDevices.getDisplayMedia({audio:e.audio,video:{frameRate:e.frameRate}}).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t(!0,e)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.logger.error("zc.b.sss "+e),t(!1,null,{code:g.commonErrorList.SCREEN.code,msg:g.commonErrorList.SCREEN.msg+" "+e})}</span>)):this.logger.error("zc.b.sss brower does not support getDisplayMedia")}</span>,t.prototype.startScreenShotFirFox=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >{video:{frameRate:t.frameRate,bitRate:t.bitRate},audio:t.audio};<span class="cstat-no" title="statement not covered" ></span>s.video.mediaSource=e,navigator.mediaDevices.getUserMedia(s).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r(!0,e)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.logger.error("zc.b.ssf "+e),r(!1,null,{code:g.commonErrorList.SCREEN.code,msg:g.commonErrorList.SCREEN.msg+" "+e})}</span>))}</span>,t.prototype.stopScreenShot=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.stateCenter.screenShotStream.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.stop()}</span>)),window.postMessage({type:"SS_UI_CANCEL",text:"start"},"*")}</span>,t.prototype.WebrtcOnPublishStateUpdateHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.stateCenter.publishStreamList[t].state==n.ENUM_PUBLISH_STREAM_STATE.publishing&amp;&amp;this.streamHandler.onPublishStateUpdate(e,t,r)}</span>,t.prototype.setCDNInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.urlFlv=t.urls_flv instanceof Array?t.urls_flv[0]:"string"==typeof t.urls_flv?t.urls_flv:"",e.urlHls=t.urls_m3u8 instanceof Array?t.urls_m3u8[0]:"string"==typeof t.urls_m3u8?t.urls_m3u8:"",e.urlHttpsFlv=t.urls_https_flv instanceof Array?t.urls_https_flv[0]:"string"==typeof t.urls_https_flv?t.urls_https_flv:"",e.urlHttpsHls=t.urls_https_m3u8 instanceof Array?t.urls_https_m3u8[0]:"string"==typeof t.urls_https_m3u8?t.urls_https_m3u8:"",e.urlRtmp=t.urls_rtmp instanceof Array?t.urls_rtmp[0]:"string"==typeof t.urls_rtmp?t.urls_rtmp:""}</span>,t.prototype.loginBodyData=function(){return{id_name:this.stateCenter.idName,nick_name:this.stateCenter.nickName,role:this.stateCenter.role,token:this.stateCenter.token,version:n.PROTO_VERSION,room_name:this.stateCenter.roomid,user_state_flag:this.stateCenter.userStateUpdate?<span class="branch-0 cbranch-no" title="branch not covered" >1:</span>0,room_create_flag:this.stateCenter.roomCreateFlag,client_type:n.E_CLIENT_TYPE.ClientType_Webrtc,third_token:this.stateCenter.third_token,user_count_limit:this.stateCenter.maxMemberCount}},t.prototype.screenStreamFrom=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>s.audio={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:e}},s.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:e,maxWidth:window.screen.width,maxHeight:window.screen.height}},!t&amp;&amp;(s.audio=!1),navigator.mediaDevices.getUserMedia(s).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r(!0,e)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.logger.error("zc.b.ssf "+e),r(!1,null,e)}</span>))}</span>,t.prototype.filterStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{},</span>r=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var n in this.stateCenter.streamList.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >t.stream_id==e&amp;&amp;(o=r)}</span>)),this.stateCenter.streamList[o])<span class="cstat-no" title="statement not covered" >"urls_flv"!=n&amp;&amp;"urls_https_flv"!=n||(t[n]=this.stateCenter.streamList[o][n]),"urls_m3u8"!=n&amp;&amp;"urls_https_m3u8"!=n||(r[n]=this.stateCenter.streamList[o][n]),"urls_rtmp"==n&amp;&amp;(i[n]=this.stateCenter.streamList[o][n]);v</span></span>ar a=<span class="cstat-no" title="statement not covered" >window.location.protocol,</span>c=<span class="cstat-no" title="statement not covered" >window.navigator.userAgent;<span class="cstat-no" title="statement not covered" ></span>if(/Safari/.test(c)&amp;&amp;!/Chrome/.test(c))<span class="cstat-no" title="statement not covered" >for(var n in r)<span class="cstat-no" title="statement not covered" >r[n]&amp;&amp;r[n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >-1!==e.indexOf(a)&amp;&amp;s.push(e)}</span>));e</span></span>lse <span class="cstat-no" title="statement not covered" >if("http:"==a)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >t[n]&amp;&amp;t[n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >-1===e.indexOf("http")&amp;&amp;-1===e.indexOf("https")||s.push(e)}</span>));e</span></span>lse <span class="cstat-no" title="statement not covered" >if("https:"==a)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >t[n]&amp;&amp;t[n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >-1!==e.indexOf(a)&amp;&amp;s.push(e)}</span>));e</span></span>lse <span class="cstat-no" title="statement not covered" >if("rtmp:"==a)<span class="cstat-no" title="statement not covered" >for(var n in i)<span class="cstat-no" title="statement not covered" >i[n]&amp;&amp;i[n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >-1!==e.indexOf(a)&amp;&amp;s.push(e)}</span>));<span class="cstat-no" title="statement not covered" >r</span></span></span></span></span></span>eturn s.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return r.indexOf(e)==t}</span>))}</span>,t.prototype.voiceChange=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"number"==typeof e?t&amp;&amp;"string"==typeof t?this.streamCenter.voiceChange(e,t):(this.logger.error("zc.vc.0 stream id error"),!1):(this.logger.error("zc.vc.0 mult error"),!1)}</span>,t.prototype.voiceBack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.streamCenter.voiceBack(e)}</span>,t.prototype.checkSystemRequirements=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >navigator&amp;&amp;navigator.mediaDevices&amp;&amp;(t.screenShotReady||"getDisplayMedia"in navigator.mediaDevices);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(i,v.eventList.kZegoTaskCheckSystemRequirements);<span class="cstat-no" title="statement not covered" >d</span>.ClientUtil.supportDetection(r,(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >e.dataReport.addMsgInfo(i,{capability:r}),e.dataReport.uploadReport(i),t(r)}</span>))}</span>))}</span>,t.prototype.enumDevices=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(r,i){var s=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(s,v.eventList.kZegoTaskEnumDevices);<span class="cstat-no" title="statement not covered" >t</span>.getDevices((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.dataReport.addMsgInfo(s,{microphones:t.microphone,speakers:t.speaker,cameras:t.cameras}),e.dataReport.uploadReport(s),r(t)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >v.codeErrMap[t.code];<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;e.dataReport.addMsgInfo(s,{error:v.errorList[r].code,message:v.errorList[r].message}),e.dataReport.uploadReport(s),i(t)}</span>))}</span>))}</span>,t.getDevices=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >void 0!==navigator.mediaDevices&amp;&amp;void 0!==navigator.mediaDevices.enumerateDevices?navigator.mediaDevices.enumerateDevices().then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var r=[],i=[],s=[],o=0;o&lt;t.length;o++){var n=<span class="cstat-no" title="statement not covered" >t[o];<span class="cstat-no" title="statement not covered" ></span>"audioinput"===n.kind&amp;&amp;r.push({deviceName:n.label,deviceID:n.deviceId}),"audiooutput"===n.kind&amp;&amp;i.push({deviceName:n.label,deviceID:n.deviceId}),"videoinput"===n.kind&amp;&amp;s.push({deviceName:n.label,deviceID:n.deviceId})}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;e({microphones:r,speakers:i,cameras:s})}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >console.error("enumerate devices wrong "+e),t&amp;&amp;t(g.commonErrorList.ENUMERATE_DEVICES_FAIL)}</span>)):t&amp;&amp;t(g.publishErrorList.BROWSER_NOT_SUPPORT)}</span>,t.prototype.getAudioInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return console.error("loclStream is empty!"),!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >o({},r);<span class="cstat-no" title="statement not covered" ></span>return new h.MediaUtil(this.ac,i).connectToSource(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t(e)}</span>))}</span>,t.prototype.getSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.info("zc.gsl call");v</span>ar i=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>this.dataReport.newReport(i,v.eventList.kZegoTaskGetSoundLevel);<span class="cstat-no" title="statement not covered" >t</span>ry{var s=<span class="cstat-no" title="statement not covered" >this.ac.createMediaStreamSource(e),</span>o=<span class="cstat-no" title="statement not covered" >this.ac.createScriptProcessor(4096,1,1);<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.audioStreamList[e.id]={mic:s,script:o},s.connect(o),o.connect(this.ac.destination),o.onaudioprocess=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=e.inputBuffer.getChannelData(0),i=0,s=0;s&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >i&lt;r[s]&amp;&amp;(i=r[s]);<span class="cstat-no" title="statement not covered" >t</span></span>(i)}</span>,this.dataReport.uploadReport(i)}</span>catch(e){<span class="cstat-no" title="statement not covered" >r(e),this.dataReport.addMsgInfo(i,{error:v.errorList.kGetSoundLevelError.code,message:v.errorList.kGetSoundLevelError.message}),this.dataReport.uploadReport(i)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.info("zc.gsl call success")}</span>,t.prototype.stopSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zc.ssl call");v</span>ar t=<span class="cstat-no" title="statement not covered" >f.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>this.dataReport.newReport(t,v.eventList.kZegoTaskStopSoundLevel);v</span>ar r=<span class="cstat-no" title="statement not covered" >this.stateCenter.audioStreamList[e.id];<span class="cstat-no" title="statement not covered" ></span>r.mic.disconnect(),r.script.disconnect(),delete this.stateCenter.audioStreamList[e.id],this.dataReport.uploadReport(t)}</span>,t.handleDataAvailable=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.data&amp;&amp;e.data.size&gt;0&amp;&amp;t.recordedBlobs.push(e.data)}</span>,t.prototype.startRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.captureStream();<span class="cstat-no" title="statement not covered" ></span>t.recordedBlobs=[];v</span>ar i=<span class="cstat-no" title="statement not covered" >{mimeType:"video/webm;codecs=vp9"};<span class="cstat-no" title="statement not covered" ></span>p.MediaRecorder.isTypeSupported(i.mimeType)||(i={mimeType:"video/webm;codecs=vp8"},p.MediaRecorder.isTypeSupported(i.mimeType)||(i={mimeType:"video/webm"},p.MediaRecorder.isTypeSupported(i.mimeType)||(i={mimeType:""})));<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >t.mediaRecorder=new p.MediaRecorder(r,i)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void console.error("Exception while creating ZegoMediaRecorder:",e)}<span class="cstat-no" title="statement not covered" ></span>t</span>.mediaRecorder.onstop=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >console.log("Recorder stopped: ",e)}</span>,t.mediaRecorder.ondataavailable=t.handleDataAvailable,t.mediaRecorder.start(10)}</span>,t.prototype.stopRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.mediaRecorder?t.mediaRecorder.stop():console.warn("please invoke startRecord first")}</span>,t.prototype.resumeRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.mediaRecorder?t.mediaRecorder.resume():console.warn("please invoke startRecord first")}</span>,t.prototype.pauseRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.mediaRecorder?t.mediaRecorder.pause():console.warn("please invoke startRecord first")}</span>,t.prototype.saveRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(t.mediaRecorder&amp;&amp;t.recordedBlobs){var r=<span class="cstat-no" title="statement not covered" >new Blob(t.recordedBlobs,{type:"video/webm"}),</span>i=<span class="cstat-no" title="statement not covered" >window.URL.createObjectURL(r),</span>s=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>s.style.display="none",s.href=i,s.download=e+".webm",document.body.appendChild(s),s.click(),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >document.body.removeChild(s),window.URL.revokeObjectURL(i)}</span>),100)}</span>else <span class="cstat-no" title="statement not covered" >console.warn("please invoke startRecord first")}</span></span>,t.prototype.takeSnapShot=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;0!==e.videoHeight){var r=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>r.width=e.videoWidth,r.height=e.videoHeight;v</span>ar i=<span class="cstat-no" title="statement not covered" >r.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.drawImage(e,0,0,r.width,r.height),t.src=r.toDataURL("image/jpeg")}</span>else <span class="cstat-no" title="statement not covered" >console.error("video can not empty")}</span></span>,t.prototype.saveSnapShot=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;0!==e.videoHeight){var r=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>r.width=e.videoWidth,r.height=e.videoHeight;v</span>ar i=<span class="cstat-no" title="statement not covered" >r.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.drawImage(e,0,0,r.width,r.height),r.toBlob((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >window.URL.createObjectURL(e),</span>i=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>i.style.display="none",i.href=r,i.download=t+".jpeg",document.body.appendChild(i),i.click(),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >document.body.removeChild(i),window.URL.revokeObjectURL(r)}</span>),100)}</span>))}</span>else <span class="cstat-no" title="statement not covered" >console.error("video can not empty")}</span></span>,t.prototype.useVideoDevice=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.logger.info("zc.uvd.0 call"),this.setPublishStreamConstraints(e,{videoInput:t})}</span>,t.prototype.useAudioDevice=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.logger.info("zc.uad.0 call"),this.setPublishStreamConstraints(e,{audioInput:t})}</span>,t.prototype.setSoundLevelDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.logger.info("zc.ssd.0 call"),"boolean"==typeof e?t&amp;&amp;("number"!=typeof t||t&lt;100||t&gt;3e3)?this.logger.error("zc.ssd.0 soundLevel interval must be number which is between 100 and 3000"):this.streamCenter.setSoundLevelDelegate(e,t):this.logger.error("zc.ssd.0 param 1 must be boolean")}</span>,t.prototype.bindWindowListener=function(){var e=this,t=navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPhone/i)?<span class="branch-0 cbranch-no" title="branch not covered" >"pagehide":</span>"beforeunload";window.addEventListener(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in window.event&amp;&amp;(window.event.cancelBubble=!0),e.streamCenter.publisherList)<span class="cstat-no" title="statement not covered" >e.stopPublishingStream(t);<span class="cstat-no" title="statement not covered" >f</span></span>or(var t in e.streamCenter.playerList)<span class="cstat-no" title="statement not covered" >e.stopPlayingStream(t);<span class="cstat-no" title="statement not covered" >c</span></span>onsole.log(e.streamCenter.playerList),console.log(e.streamCenter.publisherList),e.logoutRoom(e.stateCenter.roomid)}</span>)),window.addEventListener("message",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >t.data,</span>i=<span class="cstat-no" title="statement not covered" >r.type,</span>s=<span class="cstat-no" title="statement not covered" >r.streamID,</span>o=<span class="cstat-no" title="statement not covered" >r.canRequestAudioTrack;<span class="cstat-no" title="statement not covered" ></span>"SS_DIALOG_SUCCESS"===i&amp;&amp;e.screenStreamFrom(s,o,d.ClientUtil.actionSuccessCallback("screenShare",e.stateCenter.callbackList)),"SS_DIALOG_CANCEL"===i&amp;&amp;(e.logger.error("zc.b.ss "+i),d.ClientUtil.actionSuccessCallback("screenShare",e.stateCenter.callbackList)(!1,null,i))}</span>))},t.screenShotReady=!1,t}(l.BaseCenter);t.ZegoExpressEngine=S,window.addEventListener("message",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.data.type,</span>r=<span class="cstat-no" title="statement not covered" >e.origin;<span class="cstat-no" title="statement not covered" ></span>r!==window.location.origin&amp;&amp;console.warn("ScreenStream: you should discard foreign event from origin:",r),"SS_PING"===t&amp;&amp;(S.screenShotReady=!0)}</span>))},function(e,t,r){"use strict";var i,s=this&amp;&amp;this.__extends||(i=function(e,t){return(i=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.__proto__=t}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(r)&amp;&amp;(e[r]=t[r])}</span></span>)</span>(e,t)},function(e,t){function r(){this.constructor=e}i(e,t),e.prototype=null===t?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(t):</span>(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(8),n=function(e){function t(){return null!==e&amp;&amp;e.apply(this,arguments)||this}return s(t,e),t.prototype.openWebSocketLogServer=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.url!=e){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.url=e,!e)<span class="cstat-no" title="statement not covered" >return;t</span>his.stopWebSocketServer(),this.websocket=new WebSocket(e),this.websocket.onopen=function(e){},this.websocket.onclose=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >console.error("onclose   websocket error:",e)}</span>,this.websocket.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >console.error("open log websocket error:"+e)}</span>}},t.prototype.SendHttpsLog=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(0!=this.logCacheSend.length){var t=<span class="cstat-no" title="statement not covered" >this.logCacheSend.join("\n"),</span>r=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>r.onreadystatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(4==r.readyState)<span class="cstat-no" title="statement not covered" >if(200==r.status){<span class="cstat-no" title="statement not covered" >if(0==r.responseText.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>ry{var t=<span class="cstat-no" title="statement not covered" >JSON.parse(r.responseText).interval;<span class="cstat-no" title="statement not covered" ></span>"number"==typeof t&amp;&amp;e.logUploadInterval!==t&amp;&amp;(e.timeInterval=t,e.openHttpsLogServer(e.url))}</span>catch(e){<span class="cstat-no" title="statement not covered" >console.log("send result failed "+e)}</span>}</span>else <span class="cstat-no" title="statement not covered" >console.log("send failed "+r.status)}</span></span></span>,r.open("POST",this.url,!0),r.send(t),this.logCacheSend=[]}</span>}</span>,t.prototype.logReportParamList=function(e,t){var r=new Date,i=r.getFullYear()+"/";return i+=(o.D[r.getMonth()+1]||<span class="branch-1 cbranch-no" title="branch not covered" >r.getMonth()+1)</span>+"/",i+=(o.D[r.getDate()]||r.getDate())+" ",i+=(o.D[r.getHours()]||r.getHours())+":",i+=(o.D[r.getMinutes()]||r.getMinutes())+":",i+=o.D[r.getSeconds()]||r.getSeconds(),i+="."+r.getTime()%1e3,t.time=i,t.level=e,t.console="rtc",t.appid=this.appid,t.room_id=this.roomid,t.userid=this.userid,t.id_name=this.userid,t.userName=this.userName,t.sessionid=this.sessionid,t.sdk_version=this.version,this.appid&amp;&amp;this.userid&amp;&amp;(t.event_id=this.appid+"_"+this.userid+"_"+t.event_time+"_"+t.seq),[JSON.stringify(t)]},t}(o.Logger);t.LoggerWeb=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0);t.D=["00","01","02","03","04","05","06","07","08","09"];var s=function(){function e(e){this.logLevel=i.ENUM_LOG_LEVEL.info,this.logRemoteLevel=0,this.logUploadTimer=null,this.logUploadInterval=1e4,this.logCache=[],this.logCacheSend=[],this.logCacheMax=100,this.existUserID=!1,this.stateCenter=e}return e.prototype.setLogLevel=function(e){this.logLevel&lt;i.ENUM_LOG_LEVEL.debug||this.logLevel&gt;i.ENUM_LOG_LEVEL.report?<span class="branch-0 cbranch-no" title="branch not covered" >this.logLevel=i.ENUM_LOG_LEVEL.disable:</span>this.logLevel=e},e.prototype.setRemoteLogLevel=function(e){this.logRemoteLevel&lt;i.ENUM_LOG_LEVEL.debug||this.logRemoteLevel&gt;i.ENUM_LOG_LEVEL.report?this.logRemoteLevel=i.ENUM_LOG_LEVEL.disable:this.logRemoteLevel=e},e.prototype.setSessionInfo=function(e,t,r,i,s,o){this.appid=e,this.roomid=t,this.sessionid=r,this.userid=i,this.userName=s,this.version=o},e.prototype.openLogServer=function(e){try{e.startsWith("wss:")?(this.logType=i.ENUM_REMOTE_TYPE.websocket,this.openWebSocketLogServer(e)):<span class="branch-1 cbranch-no" title="branch not covered" >e.startsWith("https:")?(this.logType=i.ENUM_REMOTE_TYPE.https,this.openHttpsLogServer(e)):this.logType=i.ENUM_REMOTE_TYPE.disable}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.error(JSON.stringify(e))}</span>},e.prototype.stopLogServer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logType==i.ENUM_REMOTE_TYPE.websocket?this.stopWebSocketServer():this.logType==i.ENUM_REMOTE_TYPE.https&amp;&amp;(this.SendHttpsLog(),this.stopHttpsServer()),this.logType=i.ENUM_REMOTE_TYPE.disable}</span>,e.prototype.stopWebSocketServer=function(){this.websocket&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null)</span>},e.prototype.openHttpsLogServer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.url=e,e&amp;&amp;(this.stopHttpsServer(),this.logUploadTimer||(this.logUploadTimer=setInterval((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.SendHttpsLog()}</span>),this.logUploadInterval)))}</span>,e.prototype.stopHttpsServer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logUploadTimer&amp;&amp;(clearInterval(this.logUploadTimer),this.logUploadTimer=null)}</span>,e.prototype.report=function(e){var t=this.logReportParamList(i.ENUM_LOG_LEVEL.report,e);this.logLevel!==i.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=i.ENUM_LOG_LEVEL.report&amp;&amp;console.debug(t),this.RemoteLog(i.ENUM_LOG_LEVEL.report,t,!0)},e.prototype.debug=function(){for(var e=[],t=0;t&lt;arguments.length;t++)e[t]=arguments[t];var r=this.logParamList(i.ENUM_LOG_LEVEL.debug,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.disable&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.logLevel&lt;=i.ENUM_LOG_LEVEL.debug&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >console.debug(r),</span>this.log(i.ENUM_LOG_LEVEL.debug,r)},e.prototype.info=function(){for(var e=[],t=0;t&lt;arguments.length;t++)e[t]=arguments[t];var r=this.logParamList(i.ENUM_LOG_LEVEL.info,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=i.ENUM_LOG_LEVEL.info&amp;&amp;console.info(r),this.log(i.ENUM_LOG_LEVEL.info,r)},e.prototype.warn=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=[],t=0;t&lt;arguments.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=arguments[t];v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.logParamList(i.ENUM_LOG_LEVEL.warn,e.join(""));<span class="cstat-no" title="statement not covered" ></span>this.logLevel!==i.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=i.ENUM_LOG_LEVEL.warn&amp;&amp;console.warn(r),this.log(i.ENUM_LOG_LEVEL.warn,r)}</span>,e.prototype.error=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=[],t=0;t&lt;arguments.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=arguments[t];v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.logParamList(i.ENUM_LOG_LEVEL.error,e.join(""));<span class="cstat-no" title="statement not covered" ></span>this.logLevel!==i.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=i.ENUM_LOG_LEVEL.error&amp;&amp;(console.error(r),window?this.stateCenter.debug&amp;&amp;window.alert(e.join("").substr(e.join("").indexOf(" ")+1,4500)):wx&amp;&amp;this.stateCenter.debug&amp;&amp;wx.showModal({title:"",content:e.join("").substr(e.join("").indexOf(" ")+1,4500)})),this.log(i.ENUM_LOG_LEVEL.error,r)}</span>,e.prototype.log=function(e,t){this.logRemoteLevel!==i.ENUM_LOG_LEVEL.disable&amp;&amp;this.logRemoteLevel&lt;=e&amp;&amp;this.RemoteLog(e,t)},e.prototype.RemoteLog=function(e,t,r){<span class="missing-if-branch" title="else path not taken" >E</span>if(void 0===r&amp;&amp;(r=!1),""!=this.url)if(this.logType==i.ENUM_REMOTE_TYPE.websocket)this.RemoteWebSocketLog(e,t);else <span class="missing-if-branch" title="if path not taken" >I</span>if(this.logType==i.ENUM_REMOTE_TYPE.https)<span class="cstat-no" title="statement not covered" >this.RemoteHttpsLog(e,t,r);e</span>lse if(this.logLevel!==i.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=e)for(this.logCacheSend.push(t);this.logCacheSend.length&gt;this.logCacheMax;)<span class="cstat-no" title="statement not covered" >this.logCacheSend.shift()}</span>,e.prototype.RemoteWebSocketLog=function(e,t){<span class="missing-if-branch" title="if path not taken" >I</span>if("string"==typeof t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t.length&gt;4e3)<span class="cstat-no" title="statement not covered" ></span>console.info("log over maximum, ignore");e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if(null==this.websocket||2==this.websocket.readyState||3==this.websocket.readyState){var r=<span class="cstat-no" title="statement not covered" >this.url;<span class="cstat-no" title="statement not covered" ></span>this.url="",this.openLogServer(r),this.logCacheSend.length&lt;this.logCacheMax&amp;&amp;this.logCacheSend.push(t)}</span>else if(0==this.websocket.readyState)this.logCacheSend.length&lt;this.logCacheMax&amp;&amp;this.logCacheSend.push(t);else <span class="missing-if-branch" title="else path not taken" >E</span>if(1==this.websocket.readyState)<span class="missing-if-branch" title="else path not taken" >E</span>if(this.logCacheSend.length&gt;0){for(var i="",s=0;s&lt;this.logCacheSend.length;s++)(i+this.logCacheSend[s]).length&gt;4e3&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.websocket.send(i),i="")</span>,i=i+this.logCacheSend[s]+"\n";t=i+t,this.logCacheSend=[],this.websocket.send(t)}else <span class="cstat-no" title="statement not covered" >this.websocket.send(t);e</span>lse <span class="cstat-no" title="statement not covered" >console.warn("wrong socket state:"+this.websocket.readyState),this.logCacheSend.length&lt;this.logCacheMax&amp;&amp;this.logCacheSend.push(t)}</span>,e.prototype.RemoteHttpsLog=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logCacheSend.push(t),(this.logCacheSend.length&gt;=this.logCacheMax||!0===r)&amp;&amp;this.SendHttpsLog()}</span>,e.prototype.logParamList=function(e,r){var i=new Date,s=i.getFullYear()+"/";s+=(t.D[i.getMonth()+1]||<span class="branch-1 cbranch-no" title="branch not covered" >i.getMonth()+1)</span>+"/",s+=(t.D[i.getDate()]||i.getDate())+" ",s+=(t.D[i.getHours()]||i.getHours())+":",s+=(t.D[i.getMinutes()]||i.getMinutes())+":",s+=t.D[i.getSeconds()]||i.getSeconds(),s+="."+i.getTime()%1e3;var o=r.substr(0,r.indexOf(" "));0==o.length&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o=r)</span>;var n=r.substr(r.indexOf(" ")+1,4500);0==n.length&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >n="")</span>;var a={time:s,level:e,action:o,content:n,appid:this.appid,roomid:this.roomid,userid:this.userid,userName:this.userName,sessionid:this.sessionid};return JSON.stringify(a)},e}();t.Logger=s},function(e,t,r){"use strict";var i,s=this&amp;&amp;this.__extends||(i=function(e,t){return(i=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.__proto__=t}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(r)&amp;&amp;(e[r]=t[r])}</span></span>)</span>(e,t)},function(e,t){function r(){this.constructor=e}i(e,t),e.prototype=null===t?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(t):</span>(r.prototype=t.prototype,new r)}),o=this&amp;&amp;this.__spreadArrays||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=0,t=0,r=arguments.length;t&lt;r;t++)<span class="cstat-no" title="statement not covered" >e+=arguments[t].length;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Array(e),</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;r;t++)<span class="cstat-no" title="statement not covered" >for(var o=arguments[t],n=0,a=o.length;n&lt;a;n++,s++)<span class="cstat-no" title="statement not covered" >i[s]=o[n];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>;Object.defineProperty(t,"__esModule",{value:!0});var n=r(10),a=r(11),c=r(1),d=r(2),l=r(0),u=r(15),h=r(16),p=r(17),g=r(4),m=function(e){function t(t,r,i,s){var o=e.call(this,t,r)||this;return o.testEnvironment=!1,o.heartbeatTimer=null,o.heartbeatInterval=1e4,o.qualityTimerInterval=3e3,o.maxRetryCount=5,o.previewVideoList=[],o.signalList={},o.chargeInfos={itemtype:"ChargeInfos",timestamp_begin:0,timestamp_end:0,timestamp_diff_flag:0,timestamp_diff:0,infos:[]},o.chargeInfosTimer=null,o.chargeInfosInterval=6e4,o.chargeInfoSeq=0,o.soundLevelDelegate=!1,o.soundLevelInterval=1e3,o.tryCountConnectInterval=3e3,o.checkMessageTimeout=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e in o.signalList)<span class="cstat-no" title="statement not covered" >o.signalList[e].signal&amp;&amp;o.signalList[e].signal.checkMessageTimeout()}</span></span>,o.getAllInUseUrl=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var t in o.signalList)<span class="cstat-no" title="statement not covered" >e.push(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,o.onDisconnectHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(o.logger.info("zsc.od.0 call"),o.signalList[e]){<span class="cstat-no" title="statement not covered" >for(var t=o.signalList[e],r=0;r&lt;t.publishConnectedList.length;r++){var i=<span class="cstat-no" title="statement not covered" >o.publisherList[t.publishConnectedList[r]];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.publisher&amp;&amp;i.publisher.onDisconnect()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(r=0;r&lt;t.playConnectedList.length;r++){var s=<span class="cstat-no" title="statement not covered" >o.playerList[t.playConnectedList[r]];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;s.player&amp;&amp;s.player.onDisconnect()}<span class="cstat-no" title="statement not covered" ></span>d</span>elete o.signalList[e],o.stopSignalHeartbeat(),o.stopChargeInfosUpload(),o.stopSoundLevel()}</span>}</span>,o.logger=t,o.stateCenter=r,o.dataReport=i,o.ac=s,o}return s(t,e),t.prototype.onSignalDisconnected=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},t.prototype.setQualityMonitorCycle=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this.logger.debug("zsc.qmc.0 timeInterval "+e),0==Object.keys(this.publisherList).length?this.qualityTimerInterval=e:Object.keys(this.publisherList).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >t.publisherList[r].publisher.qualityTimeInterval=e,t.publisherList[r].publisher.setPublishQualityTimer()}</span>)),!0}</span>,t.prototype.setSessionInfo=function(e,t,r,i){this.logger.debug("zsc.ssi.0 called"),this.appid=e,this.userid=t,this.token=r,this.testEnvironment=i},t.prototype.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},t.prototype.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},t.prototype.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},t.prototype.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},t.prototype.onUpdateHeartBeartIntervalHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e!=this.heartbeatInterval&amp;&amp;(this.logger.debug("zsc.uhb.0 update "+e),this.heartbeatTimer&amp;&amp;(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null),this.heartbeatInterval=e,this.startSignalHeartbeat())}</span>,t.prototype.enableMicrophone=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.checkPreview(e);<span class="cstat-no" title="statement not covered" ></span>return r?r.enableMicrophone(t,this):(this.logger.error("zsc.em.0 no preview"),!1)}</span>,t.prototype.enableCamera=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.checkPreview(e);<span class="cstat-no" title="statement not covered" ></span>return r?r.enableCamera(t,this):(this.logger.error("zsc.ec.0 no preview"),!1)}</span>,t.prototype.startPreview=function(e,t,r){var i=this,s=null;return s=new n.ZegoPreview(this.logger),this.previewVideoList.push(s),s.startPreview(e,(function(e){i.logger.debug("zsc.sp.0 call success"),t&amp;&amp;t(e)}),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.previewVideoList=i.previewVideoList.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e!==s}</span>)),r&amp;&amp;r(e)}</span>)),!0},t.prototype.stopPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return this.logger.warn("zsc.sp.0 localStream null"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var t in this.publisherList)<span class="cstat-no" title="statement not covered" >this.publisherList[t].localStream===e&amp;&amp;(this.publisherList[t].localStream=null);v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.checkPreview(e);<span class="cstat-no" title="statement not covered" ></span>return r?(r.previewSuc&amp;&amp;(r.stopPreview(),this.removePreview(r)),!0):(this.logger.warn("zsc.sp.0 no preview"),!1)}</span>,t.prototype.setPublishStateStart=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(e),</span>o=<span class="cstat-no" title="statement not covered" >this.publisherList[s],</span>n=<span class="cstat-no" title="statement not covered" >this.stateCenter.reportSeqList.startPublish[s];<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.eventStart(n,"setPublishState"),o)<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.pss.0 publisher already exist"),this.dataReport.eventEndWithMsgInfo(n,"setPublishState",{message:"publisher already exist"}),this.dataReport.uploadReport(n,void 0,g.errorList.kIsPublishing),delete this.stateCenter.reportSeqList.startPublish[s],!1;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >new a.ZegoPublish(this.logger,null,this.dataReport,this.qualityTimerInterval,this,this.ac);<span class="cstat-no" title="statement not covered" ></span>return c.reportSeq=this.stateCenter.reportSeqList.startPublish[s]||0,c.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,s){var o=<span class="cstat-no" title="statement not covered" >i.publisherList[r];<span class="cstat-no" title="statement not covered" ></span>o?i.onPublishStateUpdate(t,o.streamID,s):i.logger.error("zsc.psuh.0 cannot find publish "+e)}</span>,c.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var s=<span class="cstat-no" title="statement not covered" >i.publisherList[t];<span class="cstat-no" title="statement not covered" ></span>s?i.onPublishQualityUpdate(s.streamID,r):i.logger.error("zsc.psuh.0 cannot find publish "+e)}</span>,this.publisherList[s]={localStream:t,publisher:c,serverUrls:[],retryCount:0,streamID:e,publishOption:r,tryCountConnect:1,countConnectTimer:void 0},this.dataReport.eventStart(c.reportSeq,"GetSignalUrl"),!0}</span>,t.prototype.getTotalStreamId=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.testEnvironment){var t=<span class="cstat-no" title="statement not covered" >"zegotest-"+this.appid+"-"+e;<span class="cstat-no" title="statement not covered" ></span>return this.logger.info("zsc.gts.0 test streamid "+t),t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,t.prototype.startPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.sps.0 call");v</span>ar r=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(e),</span>i=<span class="cstat-no" title="statement not covered" >this.publisherList[r];<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.sps.0 publisher don't exist"),!1;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >i.publisher;<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.eventEndWithMsg(s.reportSeq,"GetSignalUrl",{urls:t}),!t||0===t.length)<span class="cstat-no" title="statement not covered" >return this.onPublishStateUpdate(d.ENUM_PUBLISH_STATE_UPDATE.error,e,c.publishErrorList.DISPATCH_ERROR),this.logger.info("zsc.sps.0 server don't have signal url"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>.serverUrls=o(i.serverUrls,t);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.indexOf(this.server);<span class="cstat-no" title="statement not covered" ></span>return-1!==n&amp;&amp;(i.serverUrls.splice(n,1),i.serverUrls.unshift(this.server)),this.connectPublishServer(r)}</span>,t.prototype.updateWaitingList=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){<span class="cstat-no" title="statement not covered" >t?e.publishWaitingList.push({streamID:r,success:i,error:s}):e.playWaitingList.push({streamID:r,success:i,error:s})}</span>,t.prototype.publishStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.publisherList[e].publisher;<span class="cstat-no" title="statement not covered" ></span>if(t){var r=<span class="cstat-no" title="statement not covered" >null,</span>i=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >this.publisherList[e].publishOption,</span>o=<span class="cstat-no" title="statement not covered" >this.checkPreview(this.publisherList[e].localStream);<span class="cstat-no" title="statement not covered" ></span>o?(r=o.localStream,i=o.videoInfo,r?(this.logger.debug("zsc.ps.0 call success"),t.startPublish(e,r,i,o.mediaStreamConfig,s)):this.logger.error("zsc.ps.0 no localStream found")):this.logger.error("zsc.ps.0 no preview found")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zsc.ps.0 publisher don't exist")}</span></span>,t.prototype.connectPublishServer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.publisherList[e];<span class="cstat-no" title="statement not covered" ></span>return i?(this.dataReport.eventStart(t?i.publisher.retrySeq:i.publisher.reportSeq,"ConnectServer"),this.connetWithReuseSignalServerTimer(e,!0,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,s){var o=<span class="cstat-no" title="statement not covered" >r.publisherList[e];<span class="cstat-no" title="statement not covered" ></span>if(o){var n=<span class="cstat-no" title="statement not covered" >o.publisher;<span class="cstat-no" title="statement not covered" ></span>if(n){<span class="cstat-no" title="statement not covered" >r.dataReport.eventEndWithMsg(t?n.retrySeq:n.reportSeq,"ConnectServer",{result:0,server:s});v</span>ar a=<span class="cstat-no" title="statement not covered" >i.tokenInfo;<span class="cstat-no" title="statement not covered" ></span>r.logger.info("zsc.cps.0 update token success"),a&amp;&amp;a.report&amp;&amp;(n.qualityUpload=a.report,n.qualityUploadInterval=a.report_interval),n.signal=i.signal,o.retryCount=0,r.server=s,r.publishStream(e),r.getTokenSuccess()}</span>else <span class="cstat-no" title="statement not covered" >r.logger.info("zsc.cps.1 check publisher don't exist")}</span></span>else <span class="cstat-no" title="statement not covered" >r.logger.info("zsc.cps.0 after connect publisher don't exist")}</span></span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >r.logger.error("zsc.cps.0 update token failed "+i);v</span>ar s=<span class="cstat-no" title="statement not covered" >r.publisherList[e];<span class="cstat-no" title="statement not covered" ></span>if(s){var o=<span class="cstat-no" title="statement not covered" >s.publisher;<span class="cstat-no" title="statement not covered" ></span>o?r.shouldRetry(s,i)?(r.logger.info("zsc.cps.1 retry connect"),s.serverUrls.splice(0,1),s.retryCount+=1,r.connectPublishServer(e)):(t?(r.dataReport.eventEndWithMsg(o.retrySeq,"ConnectServer",{result:i}),r.dataReport.uploadReport(o.retrySeq),delete r.stateCenter.reportSeqList.rePublish[e]):(r.dataReport.eventEndWithMsg(o.reportSeq,"ConnectServer",{result:i}),r.dataReport.uploadReport(o.reportSeq),delete r.stateCenter.reportSeqList.startPublish[e]),r.onPublishStateUpdate(d.ENUM_PUBLISH_STATE_UPDATE.error,e,c.publishErrorList.TOKEN_ERROR)):r.logger.info("zsc.cps.1 check publisher don't exist")}</span>else <span class="cstat-no" title="statement not covered" >r.logger.info("zsc.cps.0 after connect publisher don't exist")}</span></span>),t),!0):(this.logger.error("zsc.cps.0 publisher don't exist"),!1)}</span>,t.prototype.shouldRetry=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return 0!=e.serverUrls.length&amp;&amp;(!(e.retryCount&gt;=this.maxRetryCount)&amp;&amp;3==t)}</span>,t.prototype.getTokenSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.gts.0 call")}</span>,t.prototype.stopPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(e),</span>r=<span class="cstat-no" title="statement not covered" >this.publisherList[t];<span class="cstat-no" title="statement not covered" ></span>r?(delete this.publisherList[t],r.publisher&amp;&amp;(r.publisher.stopPublish(),delete r.publisher),this.removeStreamFromSignal(!0,t),this.stopSignalHeartbeat(),this.stopChargeInfosUpload(),this.stopSoundLevel(),this.logger.debug("zsc.sps.0.1 call success")):this.logger.warn("zsc.sps.0.1 publisher don't exist")}</span>,t.prototype.setStreamAudioOutput=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return!(null==t||0==t.length||!e)&amp;&amp;(this.logger.debug("zsc.ssao.0 device "+t),e?"undefined"!==e.sinkId?(e.setSinkId(t).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >r.logger.info("zsc.ssao.0 success device: "+t)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.logger.info("zsc.ssao.0 "+e.name)}</span>)),!0):(this.logger.error("zsc.ssao.0 browser does not suppport"),!1):(this.logger.error("zsc.ssao.0 no localVideo"),!1))}</span>,t.prototype.connetWithReuseSignalServer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s,o){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zsc.crss.0 begin "+r);v</span>ar a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.signalList[r]&amp;&amp;!o)<span class="cstat-no" title="statement not covered" >(a=this.signalList[r]).state==l.ENUM_SIGNAL_STATE.connected?(this.logger.info("zsc.crss.0 already connected "+r+" streamId: "+e),t?a.publishConnectedList.push(e):a.playConnectedList.push(e),i(e,a)):a.state==l.ENUM_SIGNAL_STATE.connecting&amp;&amp;(this.logger.debug("zsc.crss.0 signal is connecting "+r+" streamId: "+e),this.updateWaitingList(a,t,e,i,s));e</span>lse{<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.crss.0 new signal "+r+" streamId: "+e);v</span>ar c=<span class="cstat-no" title="statement not covered" >new u.ZegoSignal(this.logger,this.stateCenter);<span class="cstat-no" title="statement not covered" ></span>c.setSessionInfo(this.appid,this.userid),c.onUpdateHeartBeartInterval=this.onUpdateHeartBeartIntervalHandle,c.onDisconnect=this.onDisconnectHandle,this.signalList[r]={signal:c,state:l.ENUM_SIGNAL_STATE.connecting,publishWaitingList:[],playWaitingList:[],publishConnectedList:[],playConnectedList:[],tokenInfo:null},this.updateWaitingList(this.signalList[r],t,e,i,s),c.connectServer(this.token,r,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,i){<span class="cstat-no" title="statement not covered" >a=n.signalList[r];v</span>ar s,o,c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(0!=e){<span class="cstat-no" title="statement not covered" >for(n.logger.debug("zsc.crss.0 connect failed "+t),c=0;c&lt;a.publishWaitingList.length;c++)<span class="cstat-no" title="statement not covered" >(s=a.publishWaitingList[c]).error&amp;&amp;s.error(s.streamID,e);<span class="cstat-no" title="statement not covered" >f</span></span>or(c=0;c&lt;a.playWaitingList.length;c++)<span class="cstat-no" title="statement not covered" >(o=a.playWaitingList[c]).error&amp;&amp;o.error(o.streamID,e);<span class="cstat-no" title="statement not covered" >d</span></span>elete n.signalList[r]}</span>else{<span class="cstat-no" title="statement not covered" >for(n.logger.debug("zsc.crss.0 connected success "+t),a.state=l.ENUM_SIGNAL_STATE.connected,a.tokenInfo=i,c=0;c&lt;a.publishWaitingList.length;c++)<span class="cstat-no" title="statement not covered" >(s=a.publishWaitingList[c]).success&amp;&amp;s.success(s.streamID,a),a.publishConnectedList.push(s.streamID);<span class="cstat-no" title="statement not covered" >f</span></span>or(c=0;c&lt;a.playWaitingList.length;c++)<span class="cstat-no" title="statement not covered" >(o=a.playWaitingList[c]).success&amp;&amp;o.success(o.streamID,a),a.playConnectedList.push(o.streamID);<span class="cstat-no" title="statement not covered" >a</span></span>.publishWaitingList=[],a.playWaitingList=[],null==n.heartbeatTimer&amp;&amp;n.startSignalHeartbeat(),null==n.chargeInfosTimer&amp;&amp;n.startChargeInfosUpload(),null==n.soundLevelTimer&amp;&amp;n.soundLevelDelegate&amp;&amp;n.startSoundLevel()}</span>}</span>))}</span>}</span>,t.prototype.setPlayStateStart=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(e),</span>s=<span class="cstat-no" title="statement not covered" >this.playerList[i],</span>o=<span class="cstat-no" title="statement not covered" >this.stateCenter.reportSeqList.startPlay[i];<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.eventStart(o,"setPlayState"),s)<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.pss.1 player already exist"),this.dataReport.eventEndWithMsgInfo(o,"setPlayState",{message:"player already exist"}),this.dataReport.uploadReport(o,void 0,g.errorList.kIsPlaying),delete this.stateCenter.reportSeqList.startPlay[i],!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >new h.ZegoPlayWeb(this.logger,null,this.dataReport,this.qualityTimerInterval,this,this.ac);<span class="cstat-no" title="statement not covered" ></span>return n.reportSeq=this.stateCenter.reportSeqList.startPlay[i],this.playerList[i]={player:n,signal:null,serverUrls:[],retryCount:0,streamID:e,playOption:t,tryCountConnect:1,countConnectTimer:void 0},n.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,i){var s=<span class="cstat-no" title="statement not covered" >r.playerList[t];<span class="cstat-no" title="statement not covered" ></span>s?r.onPlayStateUpdate(e,s.streamID,i):r.logger.error("zsc.pss.1 cannot find play "+t)}</span>,n.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var i=<span class="cstat-no" title="statement not covered" >r.playerList[e];<span class="cstat-no" title="statement not covered" ></span>i?r.onPlayQualityUpdate(i.streamID,t):r.logger.error("zsc.pss.1 cannot find play "+e)}</span>,n.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var i=<span class="cstat-no" title="statement not covered" >r.playerList[e];<span class="cstat-no" title="statement not covered" ></span>i?r.onRemoteCameraStatusUpdate(i.streamID,t):r.logger.error("zsc.pss.1 cannot find play "+e)}</span>,n.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var i=<span class="cstat-no" title="statement not covered" >r.playerList[e];<span class="cstat-no" title="statement not covered" ></span>i?r.onRemoteMicStatusUpdate(i.streamID,t):r.logger.error("zsc.pss.1 cannot find play "+e)}</span>,this.dataReport.eventStart(n.reportSeq,"GetSignalUrl"),!0}</span>,t.prototype.startPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.sps.1 start play called");v</span>ar i=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(e),</span>s=<span class="cstat-no" title="statement not covered" >this.playerList[i];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.sps.1 player don't exist"),!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >s.player;<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.eventEndWithMsg(n.reportSeq,"GetSignalUrl",{urls:t}),0==t.length)<span class="cstat-no" title="statement not covered" >return this.onPlayStateUpdate(d.ENUM_PLAY_STATE_UPDATE.error,e,c.playErrorList.DISPATCH_ERROR),this.logger.info("zsc.sps.1 server don't have signal url"),!1;<span class="cstat-no" title="statement not covered" >s</span></span>.serverUrls=o(s.serverUrls,t);v</span>ar a=<span class="cstat-no" title="statement not covered" >t.indexOf(this.server);<span class="cstat-no" title="statement not covered" ></span>return-1!==a&amp;&amp;(s.serverUrls.splice(a,1),s.serverUrls.unshift(this.server)),this.connectPlayServer(i,r)}</span>,t.prototype.connectPlayServer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >this.playerList[e];<span class="cstat-no" title="statement not covered" ></span>return s?(this.dataReport.eventStart(r?s.player.retrySeq:s.player.reportSeq,"ConnectServer"),this.connetWithReuseSignalServerTimer(e,!1,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,s,o){var n=<span class="cstat-no" title="statement not covered" >i.playerList[e];<span class="cstat-no" title="statement not covered" ></span>if(n){var a=<span class="cstat-no" title="statement not covered" >n.player;<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEndWithMsg(r?a.retrySeq:a.reportSeq,"ConnectServer",{result:0,server:o});v</span>ar c=<span class="cstat-no" title="statement not covered" >s.tokenInfo;<span class="cstat-no" title="statement not covered" ></span>i.logger.info("zsc.cps.1 update token success"),c&amp;&amp;c.report&amp;&amp;(a.qualityUpload=c.report,a.qualityUploadInterval=c.report_interval),a.signal=s.signal,n.retryCount=0,i.server=o,i.playStream(e,t),i.getTokenSuccess()}</span>else <span class="cstat-no" title="statement not covered" >i.logger.error("zsc.cps.1 checkplayer don't exist")}</span></span>else <span class="cstat-no" title="statement not covered" >i.logger.error("zsc.cps.1 after connect player don't exist")}</span></span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){var n=<span class="cstat-no" title="statement not covered" >i.playerList[s];<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >if(i.shouldRetry(n,o)){<span class="cstat-no" title="statement not covered" >i.logger.info("zsc.cps.1 retry connect");<span class="cstat-no" title="statement not covered" >n</span>.serverUrls[0];<span class="cstat-no" title="statement not covered" >n</span>.serverUrls.splice(0,1),n.retryCount+=1,i.connectPlayServer(s,t)}</span>else <span class="cstat-no" title="statement not covered" >r?(i.dataReport.eventEndWithMsg(n.player.retrySeq,"ConnectServer",{result:o}),i.dataReport.uploadReport(n.player.retrySeq),delete i.stateCenter.reportSeqList.rePlay[e]):(i.dataReport.eventEndWithMsg(n.player.reportSeq,"ConnectServer",{result:o}),i.dataReport.uploadReport(n.player.reportSeq),delete i.stateCenter.reportSeqList.startPlay[e]),i.onPlayStateUpdate(d.ENUM_PLAY_STATE_UPDATE.error,s,c.playErrorList.TOKEN_ERROR);e</span></span>lse <span class="cstat-no" title="statement not covered" >i.logger.error("zsc.cps.1 after connect player don't exist")}</span></span>),r),!0):(this.logger.error("zsc.cps.1 player don't exist"),!1)}</span>,t.prototype.connetWithReuseSignalServerTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){var o,n,a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(t&amp;&amp;this.publisherList[e]){<span class="cstat-no" title="statement not covered" >if(o=this.publisherList[e].serverUrls,this.publisherList[e].tryCountConnect&gt;3*o.length)<span class="cstat-no" title="statement not covered" >return void this.logger.error("zs.crsst.0 beyond max limit");<span class="cstat-no" title="statement not covered" >t</span></span>his.publisherList[e].countConnectTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.connetWithReuseSignalServerTimer(e,t,r,i,s)}</span>),this.tryCountConnectInterval),n=o[(this.publisherList[e].tryCountConnect-1)%o.length],this.logger.info("zs.crsst.0 called "+this.publisherList[e].tryCountConnect+" "+n),this.connetWithReuseSignalServer(e,t,n,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >clearTimeout(a.publisherList[e].countConnectTimer),a.publisherList[e].tryCountConnect=1,r(t,i,n)}</span>),this.publisherList[e].tryCountConnect===3*o.length?i:void 0,s),++this.publisherList[e].tryCountConnect}</span>else <span class="cstat-no" title="statement not covered" >if(!t&amp;&amp;this.playerList[e]){<span class="cstat-no" title="statement not covered" >if(o=this.playerList[e].serverUrls,this.playerList[e].tryCountConnect&gt;3*o.length)<span class="cstat-no" title="statement not covered" >return void this.logger.error("zs.crsst.0 beyond max limit");<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.info("zs.crsst.0 called "+this.playerList[e].tryCountConnect),this.playerList[e].countConnectTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.connetWithReuseSignalServerTimer(e,t,r,i,s)}</span>),this.tryCountConnectInterval),n=o[(this.playerList[e].tryCountConnect-1)%o.length],this.connetWithReuseSignalServer(e,t,n,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >clearTimeout(a.playerList[e].countConnectTimer),a.playerList[e].tryCountConnect=1,r(t,i,n)}</span>),this.playerList[e].tryCountConnect===3*o.length?i:void 0,s),++this.playerList[e].tryCountConnect}</span>}</span></span>,t.prototype.playStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.playerList[e].player;<span class="cstat-no" title="statement not covered" ></span>r?(this.logger.info("zsc.ps.1 call success"),r.startPlay(e,t,this.playerList[e].playOption)):this.logger.warn("zsc.ps.1 player don't exist")}</span>,t.prototype.removeStreamFromSignal=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var i in this.signalList){var s=<span class="cstat-no" title="statement not covered" >this.signalList[i];<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >for(var o=0;o&lt;s.publishConnectedList.length;o++)<span class="cstat-no" title="statement not covered" >if(s.publishConnectedList[o]===t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.rsfs.0 found from publish"),s.publishConnectedList.splice(o,1);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;s.playConnectedList.length;n++)<span class="cstat-no" title="statement not covered" >if(s.playConnectedList[n]===t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.rsfs.0 found from play"),s.playConnectedList.splice(n,1);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>0</span></span></span>==s.publishConnectedList.length&amp;&amp;0==s.playConnectedList.length&amp;&amp;(s.signal.disconnectServer(),r.push(i))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var a=0;a&lt;r.length;a++)<span class="cstat-no" title="statement not covered" >delete this.signalList[r[a]]}</span></span>,t.prototype.stopSignalHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.ssh.1 call");v</span>ar e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var t in this.signalList)<span class="cstat-no" title="statement not covered" >e+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.heartbeatTimer&amp;&amp;0==e&amp;&amp;(this.logger.info("zsc.ssh.1 stop"),clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null)}</span>,t.prototype.stopPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(e),</span>r=<span class="cstat-no" title="statement not covered" >this.playerList[t];<span class="cstat-no" title="statement not covered" ></span>r?(delete this.playerList[t],r.player&amp;&amp;(r.player.stopPlay(),delete r.player),this.removeStreamFromSignal(!1,t),this.stopSignalHeartbeat(),this.stopChargeInfosUpload(),this.stopSoundLevel(),delete this.playSuccessCallBackList[e],this.logger.debug("zsc.sps.1.1 call success")):this.logger.info("zsc.sps.1.1 player don't exist")}</span>,t.prototype.reset=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e in this.publisherList)<span class="cstat-no" title="statement not covered" >this.publisherList[e].publisher&amp;&amp;this.publisherList[e].publisher.stopPublish();<span class="cstat-no" title="statement not covered" >f</span></span>or(var t in this.playerList)<span class="cstat-no" title="statement not covered" >this.playerList[t].player&amp;&amp;this.playerList[t].player.stopPlay();<span class="cstat-no" title="statement not covered" >f</span></span>or(var r in this.signalList)<span class="cstat-no" title="statement not covered" >this.signalList[r].signal&amp;&amp;this.signalList[r].signal.disconnectServer();<span class="cstat-no" title="statement not covered" >t</span></span>his.playerList={},this.publisherList={},this.signalList={},this.server="",this.heartbeatTimer&amp;&amp;(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null)}</span>,t.prototype.startSignalHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zsc.ssh.0 call"),this.heartbeatTimer&amp;&amp;(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null),this.heartbeatTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.checkSignalHeartbeat()}</span>),this.heartbeatInterval)}</span>,t.prototype.startChargeInfosUpload=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zsc.sciu.0 call"),this.chargeInfosTimer&amp;&amp;(clearTimeout(this.chargeInfosTimer),this.chargeInfosTimer=null),this.chargeInfosTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.checkChargeInfos()}</span>),this.chargeInfosInterval)}</span>,t.prototype.checkChargeInfos=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.cci.0 call");v</span>ar e=<span class="cstat-no" title="statement not covered" >{is_publishing:0,play_max_audio_bitrate:0,play_stream_resolution_infos:[]};<span class="cstat-no" title="statement not covered" ></span>for(var t in this.chargeInfos.timestamp_begin=(new Date).getTime(),this.publisherList){<span class="cstat-no" title="statement not covered" >this.publisherList[t].publisher.state===l.ENUM_PUBLISH_STATE.publishing&amp;&amp;(e.is_publishing=1);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>e</span>.play_max_audio_bitrate=0;v</span>ar r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >i.playerList[t].player.playStream,</span>s=<span class="cstat-no" title="statement not covered" >r&amp;&amp;0!==r.getVideoTracks().length?r.getVideoTracks()[0].getSettings():void 0,</span>o=<span class="cstat-no" title="statement not covered" >{video_width:s&amp;&amp;s.width?s.width:0,video_height:s&amp;&amp;s.height?s.height:0,count:1};<span class="cstat-no" title="statement not covered" ></span>if(!e.play_stream_resolution_infos.find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.video_width==o.video_width&amp;&amp;e.video_height==o.video_height&amp;&amp;(e.count++,!0)}</span>))&amp;&amp;e.play_stream_resolution_infos.push(o),0==o.video_width&amp;&amp;0==o.video_height){var n=<span class="cstat-no" title="statement not covered" >1e3*i.playerList[t].player.lastPlayStats.audioBitrate;<span class="cstat-no" title="statement not covered" ></span>n&gt;e.play_max_audio_bitrate&amp;&amp;(e.play_max_audio_bitrate=n)}</span>}</span>,</span>i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var s in this.playerList)<span class="cstat-no" title="statement not covered" >r(s);<span class="cstat-no" title="statement not covered" >0</span></span>!==this.chargeInfos.timestamp_end?(this.chargeInfos.timestamp_diff=this.chargeInfos.timestamp_begin-this.chargeInfos.timestamp_end,this.chargeInfos.timestamp_diff_flag=1):(this.chargeInfos.timestamp_diff=0,this.chargeInfos.timestamp_diff_flag=0),this.chargeInfos.timestamp_end=(new Date).getTime(),this.chargeInfos.infos=[e],0!==e.play_stream_resolution_infos.length&amp;&amp;this.logger.report(this.chargeInfos),this.chargeInfosTimer&amp;&amp;this.startChargeInfosUpload()}</span>,t.prototype.checkSignalHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e in this.logger.debug("zsc.csh.0 call"),this.signalList)<span class="cstat-no" title="statement not covered" >this.signalList[e].signal&amp;&amp;this.signalList[e].signal.sendHeartbeat();<span class="cstat-no" title="statement not covered" >t</span></span>his.heartbeatTimer&amp;&amp;this.startSignalHeartbeat()}</span>,t.prototype.stopChargeInfosUpload=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.sciu.0 call");v</span>ar e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var t in this.signalList)<span class="cstat-no" title="statement not covered" >e+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.chargeInfosTimer&amp;&amp;0==e&amp;&amp;(this.logger.info("zsc.sciu.0 stop"),clearTimeout(this.chargeInfosTimer),this.chargeInfosTimer=null)}</span>,t.prototype.getPublisher=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >null,</span>r=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(e);<span class="cstat-no" title="statement not covered" ></span>return this.publisherList[r]&amp;&amp;this.publisherList[r].publisher&amp;&amp;(t=this.publisherList[r].publisher),t}</span>,t.prototype.checkPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=0;t&lt;this.previewVideoList.length;t++)<span class="cstat-no" title="statement not covered" >if(this.previewVideoList[t].localStream===e)<span class="cstat-no" title="statement not covered" >return this.previewVideoList[t];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn null}</span>,t.prototype.removePreview=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=0;t&lt;this.previewVideoList.length;t++)<span class="cstat-no" title="statement not covered" >if(this.previewVideoList[t]===e){<span class="cstat-no" title="statement not covered" >this.previewVideoList.splice(t,1);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>,t.prototype.onPlayerStreamUrlUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},t.prototype.getScreenConstrains=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if("boolean"==typeof e&amp;&amp;e)<span class="cstat-no" title="statement not covered" >t={audio:!1,frameRate:15,bitRate:1500};e</span>lse <span class="cstat-no" title="statement not covered" >if("object"==typeof e){<span class="cstat-no" title="statement not covered" >switch(e.videoQuality){case 1:<span class="cstat-no" title="statement not covered" >t={frameRate:l.ENUM_SCREEM_RESOLUTION_TYPE.LOW.frameRate,bitRate:l.ENUM_SCREEM_RESOLUTION_TYPE.LOW.bitRate};<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >t={frameRate:l.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.frameRate,bitRate:l.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.bitRate};<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >t={frameRate:l.ENUM_SCREEM_RESOLUTION_TYPE.HIGH.frameRate,bitRate:l.ENUM_SCREEM_RESOLUTION_TYPE.HIGH.bitRate};<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >"number"!=typeof e.frameRate&amp;&amp;(this.logger.error("zc.gsc.0 screen frameRate must be number "),e.frameRate=15),("number"!=typeof e.bitRate||e.bitRate&gt;3e3)&amp;&amp;(this.logger.error("zc.gsc.0 screen bitRate must be number and lower than 3000"),e.bitRate=1500),t={frameRate:e.frameRate,bitRate:e.bitRate}}<span class="cstat-no" title="statement not covered" ></span>t</span>.audio="boolean"==typeof e.audio&amp;&amp;e.audio}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t}</span>,t.prototype.createScreenPreviewer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >new n.ZegoPreview(this.logger),</span>i=<span class="cstat-no" title="statement not covered" >e.getVideoTracks()[0].getSettings();<span class="cstat-no" title="statement not covered" ></span>return this.previewVideoList.push(r),r.mediaStreamConfig=t,r.localStream=e,r.videoInfo={width:i.width,height:i.height,frameRate:i.frameRate||0,bitRate:t.bitRate||0},r.previewSuc=!0,r}</span>,t.prototype.setPublishStreamConstraints=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){var s=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >/Safari/.test(navigator.userAgent)&amp;&amp;!/Chrome/.test(navigator.userAgent),</span>n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>for(var a in this.publisherList)<span class="cstat-no" title="statement not covered" >this.publisherList[a].localStream==e&amp;&amp;(n=this.publisherList[a]);<span class="cstat-no" title="statement not covered" >i</span></span>f(n){var d=<span class="cstat-no" title="statement not covered" >this.checkPreview(e);<span class="cstat-no" title="statement not covered" ></span>if(d)<span class="cstat-no" title="statement not covered" >if(!t||0==Object.keys(t).length||t.width&amp;&amp;t.width&lt;120||t.height&amp;&amp;t.height&lt;120)<span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 constraints wrong");e</span>lse{<span class="cstat-no" title="statement not covered" >t.videoInput&amp;&amp;d.mediaStreamConfig.videoInput!==t.videoInput&amp;&amp;delete d.mediaStreamConfig.facingMode&amp;&amp;delete t.facingMode;v</span>ar l=<span class="cstat-no" title="statement not covered" >Object.assign(d.mediaStreamConfig,t);<span class="cstat-no" title="statement not covered" ></span>if(l.externalCapture||l.externalMediaStream)<span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 do not support external stream");e</span>lse{var u=<span class="cstat-no" title="statement not covered" >d.getMediaStreamConstraints(l),</span>h=<span class="cstat-no" title="statement not covered" >n.publisher.localStream,</span>p=<span class="cstat-no" title="statement not covered" >h.clone();<span class="cstat-no" title="statement not covered" ></span>if(!n.publisher.peerConnection.getSenders||!n.publisher.peerConnection.getSenders()[0].replaceTrack)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.spsc.0 set publish constraints is not supported"),void(i&amp;&amp;i({code:1,msg:"not supported"}));<span class="cstat-no" title="statement not covered" >!</span></span>o&amp;&amp;h.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.stop()}</span>)),navigator.mediaDevices.getUserMedia(u).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >h.getTracks().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.kind===e.kind}</span>));<span class="cstat-no" title="statement not covered" ></span>n.publisher.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null!==t.track&amp;&amp;t.track.kind===e.kind}</span>)).replaceTrack(e),h.removeTrack(t),h.addTrack(e)}</span>)),s.logger.info("zc.spsc.0 set constraints success"),p.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.stop()}</span>)),r&amp;&amp;r()}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.logger.error("zc.spsc.0 fail reason ",e.name),p.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >h.getTracks().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.kind===e.kind}</span>));<span class="cstat-no" title="statement not covered" ></span>n.publisher.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null!==t.track&amp;&amp;t.track.kind===e.kind}</span>)).replaceTrack(e),h.removeTrack(t),h.addTrack(e)}</span>)),i&amp;&amp;i({code:c.publishErrorList.CONSTRAINTS_ERROR.code,msg:e.name+" "+(e.constraint?"constraint:"+e.constraint:"")})}</span>))}</span>}</span>e</span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 preview no found")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 publisher not found")}</span></span>,t.prototype.preloadEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){var s=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>o.open("GET",r,!0),o.responseType="arraybuffer",o.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(200==o.status||304==o.status){var r=<span class="cstat-no" title="statement not covered" >o.response;<span class="cstat-no" title="statement not covered" ></span>e.decodeAudioData(r,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.logger.info("zc.pe.0 effect preload success"),s.stateCenter.audioEffectBuffer[t]=e,i&amp;&amp;i()}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.logger.error("zc.pe.0 effect preload fail "+e),i&amp;&amp;i(e)}</span>))}</span>else{var n=<span class="cstat-no" title="statement not covered" >o.statusText;<span class="cstat-no" title="statement not covered" ></span>s.logger.error("zc.pe.0 effect preload fail "+n),i&amp;&amp;i(n)}</span>}</span>,o.send()}</span>,t.prototype.playEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this.stateCenter.audioEffectBuffer[e.effectId],</span>s=<span class="cstat-no" title="statement not covered" >this.getPublisher(e.streamID);<span class="cstat-no" title="statement not covered" ></span>s?i?s.playEffect(e,i,t,r):this.logger.error("zc.pe.1 no audio buffer found"):this.logger.error("zc.pe.1 publisher doesn't exist")}</span>,t.prototype.pauseEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.getPublisher(e);<span class="cstat-no" title="statement not covered" ></span>t?t.pauseEffect():this.logger.error("zc.pe.2 publisher doesn't exist")}</span>,t.prototype.resumeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.getPublisher(e);<span class="cstat-no" title="statement not covered" ></span>t?t.resumeEffect():this.logger.error("zc.re.0 publisher doesn't exist")}</span>,t.prototype.setMixingAudioVolume=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return!!this.getPublisher(e)||(this.logger.error("zc.sma.2 publisher doesn't exist"),!1)}</span>,t.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.getPublisher(e);<span class="cstat-no" title="statement not covered" ></span>return r?r.startMixingAudio(t):(this.logger.error("zc.sma.0 publisher doesn't exist"),!1)}</span>,t.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.getPublisher(e);<span class="cstat-no" title="statement not covered" ></span>return r?r.stopMixingAudio(t):(this.logger.error("zc.sma.1 publisher doesn't exist"),!1)}</span>,t.prototype.voiceChange=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r.voiceChange(e)}</span></span>,t.prototype.voiceBack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.getPublisher(e);<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t.voiceBack()}</span></span>,t.prototype.mixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){var s=<span class="cstat-no" title="statement not covered" >this.getPublisher(e);<span class="cstat-no" title="statement not covered" ></span>s?r instanceof ArrayBuffer?s.mixingBuffer(t,r,i):this.logger.error("zc.mb.0 array buffer not found"):this.logger.error("zc.mb.0 publisher doesn't exist")}</span>,t.prototype.stopMixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.getPublisher(e);<span class="cstat-no" title="statement not covered" ></span>return r?r.stopMixingBuffer(t):(this.logger.error("zc.sma.1 publisher doesn't exist"),!1)}</span>,t.prototype.setSoundLevelDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var r in this.logger.info("zsc.ssd.0 call"),t&amp;&amp;(this.soundLevelInterval=t),this.soundLevelDelegate=e,this.publisherList){var i=<span class="cstat-no" title="statement not covered" >this.publisherList[r].publisher;<span class="cstat-no" title="statement not covered" ></span>e?i.startSoundLevel():i.stopSoundLevel()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var r in this.playerList){var s=<span class="cstat-no" title="statement not covered" >this.playerList[r].player;<span class="cstat-no" title="statement not covered" ></span>e?s.startSoundLevel():s.stopSoundLevel()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.ssd.0 start getting sound");v</span>ar o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var n in this.signalList)<span class="cstat-no" title="statement not covered" >o+=1;<span class="cstat-no" title="statement not covered" >n</span></span>ull==this.soundLevelTimer&amp;&amp;o&gt;0&amp;&amp;this.startSoundLevel()}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zsc.ssd.0 stop getting sound"),this.soundLevelTimer&amp;&amp;clearTimeout(this.soundLevelTimer),this.soundLevelTimer=null,this.soundLevelInterval=1e3}</span></span>,t.prototype.startSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zsc.ssl.0 call"),this.soundLevelTimer&amp;&amp;(clearTimeout(this.soundLevelTimer),this.soundLevelTimer=null),this.soundLevelTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.checkSoundLevel()}</span>),this.soundLevelInterval)}</span>,t.prototype.checkSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.csl.0 call");v</span>ar e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var t in this.publisherList){var r=<span class="cstat-no" title="statement not covered" >this.publisherList[t].publisher;<span class="cstat-no" title="statement not covered" ></span>e.push({streamID:this.getBackStreamId(r.streamId),soundLevel:r.soundLevel,type:"push"})}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var t in this.playerList){var i=<span class="cstat-no" title="statement not covered" >this.playerList[t].player;<span class="cstat-no" title="statement not covered" ></span>e.push({streamID:this.getBackStreamId(i.streamId),soundLevel:i.soundLevel,type:"pull"})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.soundLevelDelegate&amp;&amp;e.length&gt;0&amp;&amp;this.onSoundLevelUpdate(e),this.soundLevelDelegate&amp;&amp;this.startSoundLevel()}</span>,t.prototype.getBackStreamId=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.testEnvironment&amp;&amp;e?e.replace("zegotest-"+this.appid+"-",""):e}</span>,t.prototype.onSoundLevelUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},t.prototype.stopSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var t in this.signalList)<span class="cstat-no" title="statement not covered" >e+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.soundLevelTimer&amp;&amp;0==e&amp;&amp;(this.logger.info("zsc.ssl.0 stop"),clearTimeout(this.soundLevelTimer),this.soundLevelTimer=null,this.soundLevelInterval=1e3)}</span>,t}(p.ZegoStreamCenter);t.ZegoStreamCenterWeb=m},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(1),o=r(2),n=function(){function e(e){var t=this;this.log=e,this.localStream=null,this.videoInfo={},this.previewSuc=!1,this.enableMicrophone=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!t.localStream)<span class="cstat-no" title="statement not covered" >return t.logger.error("zp.em.2 no localStream"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i in t.localStream.getAudioTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.enabled=e}</span>)),r.publisherList){var s=<span class="cstat-no" title="statement not covered" >r.publisherList[i].publisher;<span class="cstat-no" title="statement not covered" ></span>s.localStream==t.localStream&amp;&amp;s.signal.sendStreamStatus(o.getSeq(),s.sessionId,t.localStream.getVideoTracks()[0]&amp;&amp;!0===t.localStream.getVideoTracks()[0].enabled?0:2,e?0:2)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logger.debug("zp.em.2 call success"),!0}</span>,this.enableCamera=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!t.localStream)<span class="cstat-no" title="statement not covered" >return t.logger.error("zp.ec.2 no localStream"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i in t.localStream.getVideoTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.enabled=e}</span>)),r.publisherList){var s=<span class="cstat-no" title="statement not covered" >r.publisherList[i].publisher;<span class="cstat-no" title="statement not covered" ></span>s.localStream==t.localStream&amp;&amp;s.signal.sendStreamStatus(o.getSeq(),s.sessionId,e?0:2,t.localStream.getAudioTracks()[0]&amp;&amp;1==t.localStream.getAudioTracks()[0].enabled?0:2)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logger.debug("zp.ec.2 call success"),!0}</span>,this.logger=e}return e.prototype.getMediaStreamConstraints=function(e){var t={audio:null,video:null};<span class="missing-if-branch" title="if path not taken" >I</span>if(t.audio=!0,t.video={width:640,height:480,frameRate:15,bitRate:800},console.log("mediaStreamConfig",e),e.audio?<span class="branch-0 cbranch-no" title="branch not covered" >void 0===e.audioInput&amp;&amp;void 0===e.ANS&amp;&amp;void 0===e.AGC&amp;&amp;void 0===e.AEC?(t.audio={},t.audio.noiseSuppression=!0,t.audio.autoGainControl=!0,t.audio.echoCancellation=!0):(t.audio={},void 0!==e.audioInput&amp;&amp;null!==e.audioInput&amp;&amp;(t.audio.deviceId=e.audioInput),void 0!==e.ANS&amp;&amp;(t.audio.noiseSuppression=e.ANS),void 0!==e.AGC&amp;&amp;(t.audio.autoGainControl=e.AGC),void 0!==e.AEC&amp;&amp;(t.audio.echoCancellation=e.AEC)):</span>!1===e.audio&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t.audio=!1)</span>,e.video){var r=<span class="cstat-no" title="statement not covered" >640,</span>s=<span class="cstat-no" title="statement not covered" >480,</span>o=<span class="cstat-no" title="statement not covered" >15,</span>n=<span class="cstat-no" title="statement not covered" >800;<span class="cstat-no" title="statement not covered" ></span>if(1===e.videoQuality?(r=i.ENUM_RESOLUTION_TYPE.LOW.width,s=i.ENUM_RESOLUTION_TYPE.LOW.height,o=i.ENUM_RESOLUTION_TYPE.LOW.frameRate,n=i.ENUM_RESOLUTION_TYPE.LOW.bitRate):2===e.videoQuality?(r=i.ENUM_RESOLUTION_TYPE.MEDIUM.width,s=i.ENUM_RESOLUTION_TYPE.MEDIUM.height,o=i.ENUM_RESOLUTION_TYPE.MEDIUM.frameRate,n=i.ENUM_RESOLUTION_TYPE.MEDIUM.bitRate):3===e.videoQuality?(r=i.ENUM_RESOLUTION_TYPE.HIGH.width,s=i.ENUM_RESOLUTION_TYPE.HIGH.height,o=i.ENUM_RESOLUTION_TYPE.HIGH.frameRate,n=i.ENUM_RESOLUTION_TYPE.HIGH.bitRate):4===e.videoQuality?(r=e.width,s=e.height,o=e.frameRate,n=e.bitRate||800):this.logger.info("zp.gmsc.2 use default"),!1===e.horizontal){var a=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>s=r,r=a}<span class="cstat-no" title="statement not covered" ></span>t</span>.video={width:r,height:s,frameRate:o,bitRate:n},null!=e.facingMode?t.video.facingMode=e.facingMode:null!=e.videoInput&amp;&amp;null!=e.videoInput&amp;&amp;(t.video.deviceId={exact:e.videoInput}),this.logger.info("zp.gmsc.2 width: "+r+" height: "+s+" rate: "+o)}</span>else!1===e.video&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t.video=!1)</span>;return t},e.prototype.startPreview=function(e,t,r){var i=this;<span class="missing-if-branch" title="else path not taken" >E</span>if(this.logger.debug("zp.sv.2 called"),this.mediaStreamConfig=e,void 0!==navigator.mediaDevices&amp;&amp;null!=navigator.mediaDevices.getUserMedia){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.source instanceof MediaStream){var o=<span class="cstat-no" title="statement not covered" >e.source.getVideoTracks(),</span>n=<span class="cstat-no" title="statement not covered" >o.length&gt;0?o[0].getSettings():{width:0,height:0,frameRate:0};<span class="cstat-no" title="statement not covered" ></span>return this.logger.debug("zp.sv.2 use external media stream"),this.previewSuc=!0,this.localStream=e.source,this.videoInfo={width:n.width,height:n.height,frameRate:n.frameRate,bitRate:e.bitRate||0},void(t&amp;&amp;t(this.localStream))}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(e.source instanceof HTMLMediaElement){var a=<span class="cstat-no" title="statement not covered" >this.captureStream(e.source);<span class="cstat-no" title="statement not covered" ></span>a?(this.videoInfo.bitRate=e.bitRate||0,this.previewSuc=!0,t&amp;&amp;t(a)):r&amp;&amp;r(s.publishErrorList.BROWSER_NOT_SUPPORT)}</span>else{var c=this.getMediaStreamConstraints(e);this.videoInfo=c.video,this.mediaStreamConfig.video=!!c.video,this.mediaStreamConfig.audio=!!c.audio,this.logger.info("zp.sv.2 ",JSON.stringify(c)),navigator.mediaDevices.getUserMedia(c).then((function(e){i.logger.info("zp.sv.2 success"),i.localStream=e,i.previewSuc=!0,t&amp;&amp;t(e)}),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.sv.2 failed ",e.message),console.error("sv",e),r&amp;&amp;r(e)}</span>))}}else <span class="cstat-no" title="statement not covered" >r&amp;&amp;r(s.publishErrorList.BROWSER_NOT_SUPPORT)}</span>,e.prototype.captureStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return this.logger.info("zp.cs.2 no local video"),null;v</span></span>ar t;<span class="cstat-no" title="statement not covered" >if(e.captureStream)<span class="cstat-no" title="statement not covered" >t=e.captureStream(),this.logger.debug("zp.cs.2 captureStream");e</span>lse{<span class="cstat-no" title="statement not covered" >if(!e.mozCaptureStream)<span class="cstat-no" title="statement not covered" >return this.logger.info("zp.cs.2 don't support"),null;<span class="cstat-no" title="statement not covered" >t</span></span>=e.mozCaptureStream(),this.logger.debug("zp.cs.2 mozCaptureStream")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0==t.getTracks().length?(this.logger.error("zp.cs.2 external capture tracks no found"),null):(this.localStream=t,this.videoInfo={width:e.videoWidth,height:e.videoHeight,frameRate:0,bitRate:0},this.logger.debug("zp.cs.2 called success"),this.localStream)}</span>,e.prototype.stopPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.sv.2.1 called"),this.localStream){var e=<span class="cstat-no" title="statement not covered" >this.localStream.getTracks();<span class="cstat-no" title="statement not covered" ></span>e.reverse(),e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.stop()}</span>)),this.localStream=null,this.videoInfo={}}</span>}</span>,e}();t.ZegoPreview=n},function(e,t,r){"use strict";var i=this&amp;&amp;this.__importStar||function(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(e&amp;&amp;e.__esModule)<span class="cstat-no" title="statement not covered" >return e;v</span>ar t={};<span class="missing-if-branch" title="else path not taken" >E</span>if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});var s=r(0),o=r(2),n=r(1),a=i(r(12)),c=r(13),d=r(5),l=r(14),u=r(4),h=function(){function <span class="fstat-no" title="function not covered" >e(</span>e,t,r,i,n,a){<span class="cstat-no" title="statement not covered" >this.state=s.ENUM_PUBLISH_STATE.stop,this.sessionId=0,this.waitingICETimeInterval=5e3,this.waitingAnswerTimeInterval=5e3,this.candidateInfo=[],this.waitingICETimer=null,this.waitingAnswerTimer=null,this.qualityTimer=null,this.publishQualityList=[],this.maxQualityListCount=10,this.lastPublishStats={},this.reportSeq=o.getSeq(),this.retrySeq=0,this.qualityUpload=!1,this.qualityUploadInterval=3e4,this.qualityUploadLastTime=0,this.qualitySeq=0,this.maxRetryCount=3,this.currentRetryCount=0,this.retryState=s.ENUM_RETRY_STATE.didNotStart,this.waitingServerTimerInterval=3e3,this.waitingServerTimer=null,this.videoInfo={width:0,height:0,frameRate:0,bitRate:0},this.mediaStreamConfig=null,this.offerSeq=0,this.audioMixList=[],this.arrayBufferMap={},this.qualityCount=0,this.closeSessionSignal=!1,this.audioBitRate=48e3,this.localSdpRevert=!1,this.videoCodec="H264",this.stateNego=s.ENUM_PUBLISH_STATE_NEGO.stop,this.negoInterval=25e3,this.negoTryCount=1,this.negoTryMaxCount=2,this.publishEvent=!1,this.nextSignalTryCount=1,this.waittingConnectedTimer=null,this.waittingConnectedInerval=15e3,this.tryingNexitSignal=!1,this.soundLevel=0,this.script=null,this.mic=null,this.logger=e,this.signal=t,this.dataReport=r,this.qualityTimeInterval=i,this.ac=a,this.streamCenter=n}</span>return e.prototype.publishStateUpdateError=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.logger.error("zp.psu.0 call "+JSON.stringify(e)),!t&amp;&amp;(this.state===s.ENUM_PUBLISH_STATE.stop||this.negoTryCount&lt;this.negoTryMaxCount&amp;&amp;this.stateNego&lt;s.ENUM_PUBLISH_STATE_NEGO.iceConnected)||(0!=this.sessionId&amp;&amp;this.shouldSendCloseSession(e)&amp;&amp;(this.signal.sendCloseSession(o.getSeq(),this.sessionId,1),this.closeSessionSignal=!0),this.state=s.ENUM_PUBLISH_STATE.stop,this.onPublishStateUpdate(o.ENUM_PUBLISH_STATE_UPDATE.error,this.streamId,e),this.resetPublish())}</span>,e.prototype.resetPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.rp.0 call"),this.state=s.ENUM_PUBLISH_STATE.stop,this.publishEvent=!1,null==this.peerConnection&amp;&amp;null==this.peerConnection||(this.peerConnection.close(),this.peerConnection=null),null!=this.waitingAnswerTimer&amp;&amp;(clearTimeout(this.waitingAnswerTimer),this.waitingAnswerTimer=null),null!=this.waitingICETimer&amp;&amp;(clearTimeout(this.waitingICETimer),this.waitingICETimer=null),null!=this.negoTimer&amp;&amp;(clearTimeout(this.negoTimer),this.negoTimer=null),null!=this.waittingConnectedTimer&amp;&amp;(clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null),this.clearPublishQualityTimer(),this.signal&amp;&amp;(this.signal.unregisterPushCallback("CandidateInfoPush",this.sessionId),this.signal.unregisterPushCallback("MediaDescPush",this.sessionId),this.signal.unregisterPushCallback("CloseSessionPush",this.sessionId)),this.sessionSeq=0,this.offerSeq=0,this.candidateInfo=[],this.publishQualityList=[],this.qualityUploadLastTime=0,this.currentRetryCount=0,this.retryState=s.ENUM_RETRY_STATE.didNotStart,this.clearTryPublishTimer()}</span>,e.prototype.clearTryPublishTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.waitingServerTimer&amp;&amp;(clearTimeout(this.waitingServerTimer),this.waitingServerTimer=null)}</span>,e.prototype.clearPublishQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.qualityTimer&amp;&amp;(clearInterval(this.qualityTimer),this.qualityTimer=null),this.lastPublishStats={},this.qualityCount=0}</span>,e.prototype.shouldSendCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.state!=s.ENUM_PUBLISH_STATE.stop&amp;&amp;this.state!=s.ENUM_PUBLISH_STATE.waitingSessionRsp}</span>,e.prototype.startPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,a){var c=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sp.0 called"),this.signal&amp;&amp;this.signal.negoInterval&amp;&amp;(this.negoInterval=this.signal.negoInterval),this.signal&amp;&amp;this.signal.negoTryCount&amp;&amp;(this.negoTryCount=this.signal.negoTryCount),this.signal&amp;&amp;this.signal.negoTryMaxCount&amp;&amp;(this.negoTryMaxCount=this.signal.negoTryMaxCount),e?(this.streamId=e,this.localStream=t,this.mediaStreamConfig=i,this.publishOption=a||{},navigator.userAgent.toLowerCase().indexOf("firefox")&gt;-1&amp;&amp;i&amp;&amp;(i.externalCapture||i.externalMediaStream)&amp;&amp;(this.localStream.onaddtrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >c.logger.info("zp.sp.0 Track added");v</span>ar e=<span class="cstat-no" title="statement not covered" >c.localStream.getVideoTracks(),</span>t=<span class="cstat-no" title="statement not covered" >c.localStream.getAudioTracks();<span class="cstat-no" title="statement not covered" ></span>if(e.length&gt;1)<span class="cstat-no" title="statement not covered" >c.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track.kind===e[1].kind}</span>)).replaceTrack(e[1]),c.localStream.removeTrack(e[0]);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.length&gt;1){<span class="cstat-no" title="statement not covered" >c.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track.kind===t[1].kind}</span>)).replaceTrack(t[1]),c.localStream.removeTrack(t[0])}</span>}</span></span>),r&amp;&amp;(this.videoInfo=r),a&amp;&amp;a.audioBitRate&amp;&amp;(this.audioBitRate=a.audioBitRate),a&amp;&amp;a.videoCodec&amp;&amp;(this.videoCodec=a.videoCodec),this.sessionSeq=o.getSeq(),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"CreateSession"),this.signal.createSession(this.sessionSeq,0,0,e,a&amp;&amp;a.streamParams,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >c.dataReport.eventEndWithMsg(0==c.retrySeq?c.reportSeq:c.retrySeq,"CreateSession",{sessionId:r.session_id}),c.logger.info("zp.sp.0 sessionId:"+r.session_id),c.sessionSeq==e?0!==r.result?(c.logger.error("zp.sp.0 create session failed "+r.result),c.publishStateUpdateError(n.publishErrorList.CREATE_SESSION_ERROR)):(c.sessionId=r.session_id,c.logger.debug("zp.sp.0 create session success "+c.sessionId),c.onCreatePublishSessionSuccess(r)):c.logger.error("zp.sp.0 seq is not match.")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >c.dataReport.eventEndWithMsg(0==c.retrySeq?c.reportSeq:c.retrySeq,"CreateSession",{error:e}),c.publishStateUpdateError(n.publishErrorList.SEND_SESSION_TIMEOUT)}</span>)),this.state=s.ENUM_PUBLISH_STATE.waitingSessionRsp,this.logger.info("zp.sp.0 called success"),this.stateNego=s.ENUM_PUBLISH_STATE_NEGO.start,this.negoTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >c.stateNego!==s.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;c.negoTryCount&lt;c.negoTryMaxCount?(c.signal.sendCloseSession(o.getSeq(),c.sessionId,1),c.resetPublish(),c.startPublish(e,t,r,i,a),++c.negoTryCount):c.stateNego!==s.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;c.negoTryCount===c.negoTryMaxCount&amp;&amp;(c.logger.error("zp.sp.0 waiting timeout"),c.publishStateUpdateError(n.publishErrorList.SERVER_NEGO_TIMEOUT))}</span>),this.negoInterval)):this.logger.error("zp.sp.0 streamId is null")}</span>,e.prototype.onCreatePublishSessionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.0 called");v</span>ar r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e.turn_server&amp;&amp;r.push(e.turn_server),e.stun_server&amp;&amp;r.push(e.stun_server);v</span>ar i=<span class="cstat-no" title="statement not covered" >{iceTransportPolicy:"relay",iceServers:[{urls:r,username:e.turn_username,credential:e.turn_auth_key}]};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.0 username: "+e.turn_username),this.logger.info("zp.ops.0 credential: "+e.turn_auth_key),this.peerConnection=new RTCPeerConnection(i),this.peerConnection.onicecandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.onIceCandidate(e)}</span>,this.peerConnection.onsignalingstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.onConnectionStateChange(e)}</span>,this.peerConnection.oniceconnectionstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.onIceConnectionStateChange(e)}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>this.localStream&amp;&amp;(this.localStream.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.peerConnection.addTrack(e,t.localStream)}</span>)),s=this.localStream.getVideoTracks(),o=this.localStream.getAudioTracks(),console.warn("getConstraints",o&amp;&amp;o[0]&amp;&amp;o[0].getConstraints&amp;&amp;o[0].getConstraints()),s.length&gt;0&amp;&amp;this.logger.info("zp.ops.0 video device: "+s[0].label),o.length&gt;0&amp;&amp;this.logger.info("zp.ops.0 audio device: "+o[0].label));v</span>ar a=<span class="cstat-no" title="statement not covered" >{offerToReceiveAudio:o.length&gt;0?1:0,offerToReceiveVideo:s.length&gt;0?1:0};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.0 createOffer: "+JSON.stringify(a)),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"CreateOffer"),this.peerConnection.createOffer(a).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"CreateOffer"),t.onCreateOfferSuccess(e)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"CreateOffer",{error:e.toString()}),t.logger.error("zp.ops.0 create offer error "+e.toString()),t.publishStateUpdateError(n.publishErrorList.CREATE_OFFER_ERROR,!0)}</span>)),this.signal.registerPushCallback("CandidateInfoPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvCandidateInfo(e,r,i)}</span>)),this.signal.registerPushCallback("CloseSessionPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvCloseSession(e,r,i)}</span>)),this.signal.registerPushCallback("MediaDescPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvMediaDescription(e,r,i)}</span>)),this.signal.registerPushCallback("SessionResetPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvResetSession(e,r,i)}</span>)),this.signal.registerPushCallback("PublishEventPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvPublishEvent(e,r,i)}</span>)),this.logger.debug("zp.ops.0 call success")}</span>,e.prototype.onCreateOfferSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>0!=this.videoInfo.bitRate&amp;&amp;(e.sdp=this.updateBandwidthRestriction(e.sdp,this.videoInfo.bitRate)),e.sdp=e.sdp.replace(/sendrecv/g,"sendonly"),e.sdp=e.sdp.replace(/useinbandfec=\d+/,"maxaveragebitrate="+this.audioBitRate),/m=video[\s\S]*m=audio/.test(e.sdp)&amp;&amp;(this.localSdpRevert=!0),e.sdp=d.SdpUtil.getSDPByVideDecodeType(e.sdp,this.videoCodec),this.logger.info("zp.oco.0 localSdp1 "+e.sdp.substr(0,e.sdp.length/2)),this.logger.info("zp.oco.0 localSdp2 "+e.sdp.substr(e.sdp.length/2)),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SetLocalDescription"),this.peerConnection.setLocalDescription(e).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"SetLocalDescription"),t.onSetLocalDescriptionSuccess(e)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"SetLocalDescription",{error:e.toString()}),t.logger.error("zp.oco.0 error "+e.toString()),t.publishStateUpdateError(n.publishErrorList.SET_LOCAL_DESC_ERROR,!0)}</span>))}</span>,e.prototype.updateBandwidthRestriction=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >"AS";<span class="cstat-no" title="statement not covered" ></span>return"firefox"===a.browserDetails.browser&amp;&amp;(t=1e3*(t&gt;&gt;&gt;0),r="TIAS"),e=-1===e.indexOf("b="+r+":")?(e=e.replace(/c=IN (.*)\r\n/g,"c=IN $1\r\nb="+r+":"+t+"\r\n")).replace("b="+r+":"+t+"\r\n",""):(e=e.replace(new RegExp("b="+r+":.*\r\n","g"),"b="+r+":"+t+"\r\n")).replace("b="+r+":"+t+"\r\n","")}</span>,e.prototype.onSetLocalDescriptionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.osd.0 success");v</span>ar r=<span class="cstat-no" title="statement not covered" >{sdp:e.sdp,width:this.videoInfo.width,height:this.videoInfo.height,frameRate:this.videoInfo.frameRate,video_min_kpbs:this.videoInfo.bitRate,video_max_kpbs:this.videoInfo.bitRate,audio_kpbs:48,keyframe_intv:2};<span class="cstat-no" title="statement not covered" ></span>this.offerSeq=o.getSeq(),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SendMediaDesc"),this.signal.sendMediaDesc(this.offerSeq,this.sessionId,0,r,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,o){<span class="cstat-no" title="statement not covered" >t.offerSeq==e&amp;&amp;t.sessionId==i?(t.logger.info("zp.osd.0 send success"),t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendMediaDesc",{mediaDescription:{width:r.width,height:r.height,frameRate:r.frameRate,video_min_kpbs:r.video_min_kpbs,video_max_kpbs:r.video_max_kpbs,audio_kpbs:r.audio_kpbs,keyframe_intv:r.keyframe_intv}}),t.waitingAnswerTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.state==s.ENUM_PUBLISH_STATE.waitingServerAnswer&amp;&amp;(t.logger.error("zp.osd.0 waiting timeout"),t.publishStateUpdateError(n.publishErrorList.SERVER_MEDIA_DESC_TIMEOUT))}</span>),t.waitingAnswerTimeInterval),t.logger.info("zp.osd.0 send success stateNego:waiterAnswer"),t.stateNego=s.ENUM_PUBLISH_STATE_NEGO.waiterAnswer,t.state=s.ENUM_PUBLISH_STATE.waitingServerAnswer):t.logger.error("zp.osd.0 seq or sessionId is not equal")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendMediaDesc",{error:e}),t.publishStateUpdateError(n.publishErrorList.SEND_MEDIA_DESC_TIMEOUT)}</span>)),this.state=s.ENUM_PUBLISH_STATE.waitingOffserRsp,this.logger.debug("zp.osd.0 call success")}</span>,e.prototype.onRecvMediaDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ormd.0 received"),this.state==s.ENUM_PUBLISH_STATE.waitingServerAnswer?(this.stateNego=s.ENUM_PUBLISH_STATE_NEGO.waitingCandidate,this.logger.info("zp.orm.0 received stateNego:waitingCandidate"),null!=this.waitingAnswerTimer&amp;&amp;(clearTimeout(this.waitingAnswerTimer),this.waitingAnswerTimer=null),this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"RecvMediaDesc"),this.signal.sendMediaDescAck(e,this.sessionId,0),1==r.type?this.onGetRemoteOfferSucceses(r.sdp):this.publishStateUpdateError(n.publishErrorList.SERVER_MEDIA_DESC_ERROR)):this.logger.info("zp.ormd.0 current state "+this.state+" not allowed")}</span>,e.prototype.onGetRemoteOfferSucceses=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(48e3!==this.audioBitRate&amp;&amp;(e=e.replace(/maxaveragebitrate=(\d+)/,"maxaveragebitrate="+this.audioBitRate)),this.localSdpRevert){var r=<span class="cstat-no" title="statement not covered" >[/[\s\S]*m=audio/.exec(e)[0].replace("m=audio",""),/m=video[\s\S]*/.exec(e)[0],/m=audio[\s\S]*m=video/.exec(e)[0].replace("m=video","")],</span>i=<span class="cstat-no" title="statement not covered" >r[0],</span>o=<span class="cstat-no" title="statement not covered" >r[1],</span>a=<span class="cstat-no" title="statement not covered" >r[2],</span>c=<span class="cstat-no" title="statement not covered" >/a=group:BUNDLE\s+(\w+)\s+(\w+)/.exec(i);<span class="cstat-no" title="statement not covered" ></span>e=(i=i.replace(/a=group:BUNDLE\s+(\w+)\s+(\w+)/,"a=group:BUNDLE "+c[2]+" "+c[1]))+o+a}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.info("zp.oro.0 remoteSdp:",e);v</span>ar d=<span class="cstat-no" title="statement not covered" >{type:"answer",sdp:e,toJSON:<span class="fstat-no" title="function not covered" >fu</span>nction(){}};<span class="cstat-no" title="statement not covered" ></span>this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SetRemoteDescription"),this.peerConnection.setRemoteDescription(new RTCSessionDescription(d)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.logger.info("zp.oro.0 set success"),t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"SetRemoteDescription")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.logger.error("zp.oro.0 failed: "+e.toString()),t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"SetRemoteDescription",{error:e.toString()}),t.publishStateUpdateError(n.publishErrorList.SET_REMOTE_DESC_ERROR)}</span>)),this.state=s.ENUM_PUBLISH_STATE.waitingServerICE,this.waitingICETimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.state==s.ENUM_PUBLISH_STATE.waitingServerICE&amp;&amp;(t.logger.error("zp.orod.0 waiting server timeout"),t.publishStateUpdateError(n.publishErrorList.SERVER_CANDIDATE_TIMEOUT))}</span>),this.waitingICETimeInterval),this.logger.debug("zp.oro.0 call success")}</span>,e.prototype.onIceConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.state!=s.ENUM_PUBLISH_STATE.stop&amp;&amp;null!=this.peerConnection&amp;&amp;(this.logger.info("zp.oics.0 stateChanged "+this.peerConnection.iceConnectionState),"connected"===this.peerConnection.iceConnectionState?(this.logger.info("zp.oics.0 connected state "+this.state),this.dataReport.eventEnd(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceConnected"),this.stateNego=s.ENUM_PUBLISH_STATE_NEGO.iceConnected,this.waittingConnectedTimer&amp;&amp;clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null,this.logger.info("zp.oisc.0  stateNego:iceConnected"),this.negoTryCount=1,this.nextSignalTryCount=1,this.negoTimer&amp;&amp;(clearTimeout(this.negoTimer),this.negoTimer=null),this.publishEvent&amp;&amp;this.publishSuccess()):"closed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceClosed"),this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState)):"failed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceFailed"),this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState)):"disconnected"===this.peerConnection.iceConnectionState&amp;&amp;(this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceDisconnected"),this.waittingConnectedTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!t.tryingNexitSignal&amp;&amp;t.tryNextSignal(n.publishErrorList.MEDIA_CONNECTION_DISCONNECTED)}</span>),this.waittingConnectedInerval)))}</span>,e.prototype.onIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oic.0 candidate"+e.candidate),e.candidate)<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oic.0 candidate"+e.candidate.candidate),this.state&lt;s.ENUM_PUBLISH_STATE.connecting||this.state==s.ENUM_PUBLISH_STATE.stop)<span class="cstat-no" title="statement not covered" >this.candidateInfo.push({candidate:e.candidate.candidate,sdpMid:e.candidate.sdpMid,sdpMLineIndex:e.candidate.sdpMLineIndex});e</span>lse{var t=<span class="cstat-no" title="statement not covered" >{candidate:e.candidate.candidate,sdpMid:e.candidate.sdpMid,sdpMLineIndex:e.candidate.sdpMLineIndex};<span class="cstat-no" title="statement not covered" ></span>this.sendCandidateInfo([t])}</span>}</span></span>,e.prototype.sendCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sci.0 called"),!(e=e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.candidate.indexOf("relay")&gt;0}</span>)))||e.length&lt;1?this.logger.info("zp.sci.0 cancelled"):(this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SendIceCandidate"),this.stateNego!==s.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;(this.stateNego=s.ENUM_PUBLISH_STATE_NEGO.sendCandidate),this.logger.info("zp.sci.0  stateNego:sendCandidate"),this.signal.sendCandidateInfo(o.getSeq(),this.sessionId,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.logger.info("zp.sci.0 send success"),t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendIceCandidate")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.logger.error("zp.sci.0 failed to send: "+e.toString()),t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendIceCandidate",{error:e}),t.publishStateUpdateError(n.publishErrorList.SEND_CANDIDATE_TIMEOUT)}</span>)))}</span>,e.prototype.onConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ocs.0 called "+e.target.signalingState)}</span>,e.prototype.onRecvCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.oci.0 received "+JSON.stringify(r.infos)),this.state==s.ENUM_PUBLISH_STATE.waitingServerICE){<span class="cstat-no" title="statement not covered" >null!=this.waitingICETimer&amp;&amp;(clearTimeout(this.waitingICETimer),this.waitingICETimer=null),this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"RecvIceCandidate"),this.signal.sendCandidateInfoAck(e,this.sessionId,0),this.sendCandidateInfo(this.candidateInfo),this.candidateInfo=[];<span class="cstat-no" title="statement not covered" >f</span>or(var o=0;o&lt;r.infos.length;o++){var a=<span class="cstat-no" title="statement not covered" >{sdpMid:r.infos[o].sdpMid,sdpMLineIndex:r.infos[o].sdpMLineIndex,candidate:r.infos[o].candidate};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zp.orci.0 candidate "+a.candidate),this.peerConnection.addIceCandidate(new RTCIceCandidate(a)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.logger.debug("zp.oci.0 add success")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.logger.error("zp.oci.0 add error "+e.toString()),i.publishStateUpdateError(n.publishErrorList.SERVER_CANDIDATE_ERROR)}</span>))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.state=s.ENUM_PUBLISH_STATE.connecting,this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceConnected")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.oci.0 current state "+this.state+" not allowed")}</span></span>,e.prototype.onRecvCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.0 reason: "+r.reason),this.signal.sendCloseSessionAck(e,this.sessionId,0);v</span>ar i=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(n.publishErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>i.msg+=r.reason,this.negoTimer&amp;&amp;clearTimeout(this.negoTimer);v</span>ar s=<span class="cstat-no" title="statement not covered" >1*r.reason,</span>a=<span class="cstat-no" title="statement not covered" >r.err_info&amp;&amp;JSON.parse(r.err_info).action?JSON.parse(r.err_info).action:null;<span class="cstat-no" title="statement not covered" ></span>if("number"==typeof s&amp;&amp;[26].includes(s)&amp;&amp;this.negoTryCount&lt;this.negoTryMaxCount||5==a){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.0 retry: "+this.streamId),this.retrySeq=o.getReportSeq(),this.dataReport.newReport(this.retrySeq,u.eventList.kZegoTaskRePublish),this.dataReport.addMsgInfo(this.retrySeq,{reason:i});v</span>ar c=<span class="cstat-no" title="statement not covered" >this.streamId,</span>d=<span class="cstat-no" title="statement not covered" >this.localStream,</span>l=<span class="cstat-no" title="statement not covered" >this.videoInfo,</span>h=<span class="cstat-no" title="statement not covered" >this.mediaStreamConfig,</span>p=<span class="cstat-no" title="statement not covered" >this.publishOption;<span class="cstat-no" title="statement not covered" ></span>this.signal.sendCloseSession(o.getSeq(),this.sessionId,1),this.onPublishStateUpdate(o.ENUM_PUBLISH_STATE_UPDATE.retry,this.streamId,{code:0,msg:""}),this.resetPublish(),this.startPublish(c,d,l,h,p),++this.negoTryCount}</span>else<span class="cstat-no" title="statement not covered" >[4,8,10,11,12,27].includes(s)||2==a?!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(i):this.publishStateUpdateError(i,!0)}</span></span>,e.prototype.onRecvResetSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.orrs.0 received "),t==this.sessionId){<span class="cstat-no" title="statement not covered" >this.signal.sendCloseSessionAck(e,this.sessionId,0);v</span>ar i=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(n.publishErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>this.negoTimer&amp;&amp;clearTimeout(this.negoTimer),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(i)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zp.orrs.0 cannot find session")}</span></span>,e.prototype.onRecvPublishEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orpe.0 received"),this.publishEvent=!0,this.stateNego===s.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;0==r.event&amp;&amp;this.publishSuccess()}</span>,e.prototype.shouldRetryPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.retryState==s.ENUM_RETRY_STATE.didNotStart&amp;&amp;this.state!=s.ENUM_PUBLISH_STATE.publishing?(this.logger.info("zp.srp.0.0 connection didn't success"),!1):this.retryState==s.ENUM_RETRY_STATE.retrying?(this.logger.info("zp.srp.0.0 already retrying"),!1):this.currentRetryCount&gt;this.maxRetryCount?(this.logger.info("zp.srp.0.0 beyond max"),!1):(this.logger.info("zp.srp.1.0 call success"),!0)}</span>,e.prototype.startRetryPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.srp.0 call");v</span>ar e=<span class="cstat-no" title="statement not covered" >this.streamId;<span class="cstat-no" title="statement not covered" ></span>e?(this.resetPublish(),this.tryStartPublish(e)):this.logger.info("zp.srp.0 no streamid")}</span>,e.prototype.tryStartPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.tsp.0 call"),this.clearTryPublishTimer(),this.streamId=e,this.currentRetryCount&gt;this.maxRetryCount)<span class="cstat-no" title="statement not covered" >return this.logger.info("zp.tsp.0 beyond max limit"),void this.publishStateUpdateError(n.publishErrorList.WEBSOCKET_ERROR);<span class="cstat-no" title="statement not covered" >t</span></span>his.retryState=s.ENUM_RETRY_STATE.retrying,this.currentRetryCount+=1,this.signal.isServerConnected()?(this.logger.info("zp.tsp.0 signal connected"),this.startPublish(e,this.localStream,this.videoInfo,this.mediaStreamConfig,this.publishOption)):(this.logger.debug("zp.tsp.0 signal server not connected"),this.waitingAnswerTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.tryStartPublish(e),console.warn(new Date)}</span>),this.waitingAnswerTimeInterval))}</span>,e.prototype.checkPublishConnectionFailedState=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>"failed"==e?t=n.publishErrorList.MEDIA_CONNECTION_FAILED:"closed"==e&amp;&amp;(t=n.publishErrorList.MEDIA_CONNECTION_CLOSED),null!=t&amp;&amp;(this.state!=s.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.retryState==s.ENUM_PUBLISH_STATE.didNotStart?(this.logger.info("zp.oics.0  state "+this.state+" retryState "+this.retryState+" connectionState "+e),this.publishStateUpdateError(t)):this.shouldRetryPublish()?(this.onPublishStateUpdate(o.ENUM_PUBLISH_STATE_UPDATE.retry,this.streamId,{code:0,msg:""}),this.startRetryPublish()):this.publishStateUpdateError(t))}</span>,e.prototype.setPublishQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>null==this.qualityTimer&amp;&amp;(this.logger.info("zp.spq.0 called"),this.clearPublishQualityTimer(),this.qualityTimer=setInterval((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.peerConnection&amp;&amp;e.peerConnection.getStats(null).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.getPublishStats(t)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.info("zp.spq.0 getStats error "+t.toString())}</span>))}</span>),this.qualityTimeInterval),this.lastPublishStats={time:0,audioBytesSent:0,videoBytesSent:0,framesEncoded:0,framesSent:0},this.qualitySeq=o.getSeq(),this.qualityCount=0)}</span>,e.prototype.getPublishStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(e){var r=<span class="cstat-no" title="statement not covered" >{audioCodec:"opus",audioBitrate:0,videoBitrate:0,videoFPS:0,nackCount:0,pliCount:0,frameHeight:0,frameWidth:0,videoTransferFPS:0,totalRoundTripTime:0,currentRoundTripTime:0},</span>i=<span class="cstat-no" title="statement not covered" >this.lastPublishStats.time;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >("outbound-rtp"==e.type||"ssrc"==e.type&amp;&amp;null!=e.bytesSent)&amp;&amp;"audio"==e.mediaType?(0!=i&amp;&amp;(r.audioBitrate=8*(e.bytesSent-t.lastPublishStats.audioBytesSent)/(e.timestamp-i)),r.audioBitrate&lt;0&amp;&amp;(r.audioBitrate=0),t.lastPublishStats.audioBytesSent=e.bytesSent,t.lastPublishStats.time=e.timestamp):("outbound-rtp"==e.type||"ssrc"==e.type&amp;&amp;null!=e.bytesSent)&amp;&amp;"video"==e.mediaType?(0!=i&amp;&amp;(r.videoBitrate=8*(e.bytesSent-t.lastPublishStats.videoBytesSent)/(e.timestamp-i),r.videoFPS=1e3*(e.framesEncoded-t.lastPublishStats.framesEncoded)/(e.timestamp-i)),r.videoBitrate&lt;0&amp;&amp;(r.videoBitrate=0),r.videoFPS&lt;0&amp;&amp;(r.videoFPS=0),r.nackCount=e.nackCount,r.pliCount=e.pliCount,t.lastPublishStats.videoBytesSent=e.bytesSent,t.lastPublishStats.framesEncoded=e.framesEncoded,t.lastPublishStats.time=e.timestamp):"track"==e.type&amp;&amp;("video"==e.kind||e.id.indexOf("video")&gt;=0||e.frameWidth)?(r.frameHeight=e.frameHeight,r.frameWidth=e.frameWidth,0!=i&amp;&amp;(r.videoTransferFPS=1e3*(e.framesSent-t.lastPublishStats.framesSent)/(e.timestamp-i)),r.videoTransferFPS&lt;0&amp;&amp;(r.videoTransferFPS=0),t.lastPublishStats.framesSent=e.framesSent):"candidate-pair"==e.type&amp;&amp;(null!=e.totalRoundTripTime&amp;&amp;(r.totalRoundTripTime=e.totalRoundTripTime),null!=e.currentRoundTripTime&amp;&amp;(r.currentRoundTripTime=e.currentRoundTripTime))}</span>)),this.uploadPublishQuality(r);v</span>ar s=<span class="cstat-no" title="statement not covered" >{video:{videoBitrate:r.videoBitrate,videoFPS:r.videoFPS,videoTransferFPS:r.videoTransferFPS,frameHeight:r.frameHeight,frameWidth:r.frameWidth},audio:{audioBitrate:r.audioBitrate,audioCodec:r.audioCodec},nackCount:r.nackCount,pliCount:r.pliCount,totalRoundTripTime:r.totalRoundTripTime,currentRoundTripTime:r.currentRoundTripTime};<span class="cstat-no" title="statement not covered" ></span>0!=i&amp;&amp;this.onPublishQualityUpdate(this.streamId,s)}</span>}</span>,e.prototype.uploadPublishQuality=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.qualityUpload){var r=<span class="cstat-no" title="statement not covered" >Date.parse(new Date+"");<span class="cstat-no" title="statement not covered" ></span>(0==this.qualityUploadLastTime||r-this.qualityUploadLastTime&gt;=this.qualityUploadInterval)&amp;&amp;(e.stream_type="publish",e.stream_id=this.streamId,e.timeStamp=r/1e3,this.logger.info("zp.upq.0 upload"+JSON.stringify(e)),this.signal.QualityReport(o.getSeq(),this.sessionId,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >void 0!==i.report&amp;&amp;(t.qualityUpload=i.report,t.qualityUploadInterval=i.report_interval_ms)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.logger.info("zp.upq.0 upload failed "+e)}</span>)),this.qualityUploadLastTime=r)}</span>}</span>,e.prototype.stopPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.sp.0.1 called"),Object.keys(this.streamCenter.publisherList).length=1)<span class="cstat-no" title="statement not covered" >for(var e in this.streamCenter.playerList){var t=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[e].player;<span class="cstat-no" title="statement not covered" ></span>t.state==s.ENUM_PLAY_STATE.playing&amp;&amp;t.broadcasterStatus==s.ENUM_BROADCASTER_STATUS.start&amp;&amp;(this.signal&amp;&amp;this.signal.sendBroadcasterStatus(o.getSeq(),t.sessionId,0),t.broadcasterStatus=s.ENUM_BROADCASTER_STATUS.stop)}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.sessionId&amp;&amp;!this.closeSessionSignal&amp;&amp;this.signal.sendCloseSession(o.getSeq(),this.sessionId,0),this.resetPublish()}</span>,e.prototype.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.od.0 call"),this.logger.info("zp.od.0 websocket disconnect"),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(n.publishErrorList.WEBSOCKET_ERROR)}</span>,e.prototype.playEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){},e.prototype.pauseEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){},e.prototype.resumeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){},e.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this.logger.info("zp.sma.0 call"),e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(t.audioMixList.find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.media==e}</span>)))<span class="cstat-no" title="statement not covered" >t.logger.info("zp.sma.0 mix audio already exist");e</span>lse{var r=<span class="cstat-no" title="statement not covered" >new c.AudioMixUtil(t.logger,t.ac);<span class="cstat-no" title="statement not covered" ></span>r.localStream=t.localStream,r.peerConnection=t.peerConnection,t.audioMixList.push({audioMix:r,media:e}),r.startMixingAudio(e)}</span>}</span>)),!0}</span>,e.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this.logger.info("zp.sma.0.0 call"),e?e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=0;r&lt;t.audioMixList.length;r++)<span class="cstat-no" title="statement not covered" >if(t.audioMixList[r].media==e){<span class="cstat-no" title="statement not covered" >t.audioMixList[r].audioMix.stopMixingAudio()&amp;&amp;t.audioMixList.splice(r--,1);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>)):(this.audioMixList.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.audioMix.stopMixingAudio()}</span>)),this.audioMixList=[]),!0}</span>,e.prototype.mixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if(this.arrayBufferMap[e])<span class="cstat-no" title="statement not covered" >this.arrayBufferMap[e].mixingBuffer(t,r);e</span>lse{var i=<span class="cstat-no" title="statement not covered" >new c.AudioMixUtil(this.logger,this.ac);<span class="cstat-no" title="statement not covered" ></span>i.localStream=this.localStream,i.peerConnection=this.peerConnection,this.arrayBufferMap[e]=i,i.mixingBuffer(t,r)}</span>}</span>,e.prototype.stopMixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.arrayBufferMap[e])<span class="cstat-no" title="statement not covered" >return this.arrayBufferMap[e].stopMingBuffer(),delete this.arrayBufferMap[e],!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0===e){<span class="cstat-no" title="statement not covered" >for(var t in this.arrayBufferMap)<span class="cstat-no" title="statement not covered" >this.arrayBufferMap[t].stopMingBuffer();<span class="cstat-no" title="statement not covered" >r</span></span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.logger.warn("zp.smb.0 arrayBuffer no found"),!1}</span>,e.prototype.voiceChange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.pitchEffect=new l.PitchUtil(this.ac);v</span>ar t=<span class="cstat-no" title="statement not covered" >this.ac.createMediaStreamSource(this.localStream.clone()),</span>r=<span class="cstat-no" title="statement not covered" >this.ac.createMediaStreamDestination();<span class="cstat-no" title="statement not covered" ></span>if(t.connect(this.pitchEffect.input),this.pitchEffect.output.connect(r),this.pitchEffect.setPitchOffset(e),!this.micTrack){var i=<span class="cstat-no" title="statement not covered" >r.stream.getAudioTracks()[0],</span>s=<span class="cstat-no" title="statement not covered" >this.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track.kind===i.kind}</span>));<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return this.logger.error("zp.vc.0 no sender"),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.micTrack=this.localStream.getAudioTracks()[0],s.replaceTrack(i),this.localStream.removeTrack(this.micTrack),this.localStream.addTrack(i)}</span>}</span>,e.prototype.voiceBack=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.micTrack?(this.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track.kind===e.micTrack.kind}</span>)).replaceTrack(this.micTrack),this.localStream.removeTrack(this.localStream.getAudioTracks()[0]),this.localStream.addTrack(this.micTrack),this.micTrack=null):this.logger.error("zp.vb.0 mo mickTrack found")}</span>,e.prototype.publishSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e in this.state!=s.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.onPublishStateUpdate(o.ENUM_PUBLISH_STATE_UPDATE.start,this.streamId,{code:0,msg:""}),this.state=s.ENUM_PUBLISH_STATE.publishing,this.tryingNexitSignal=!1,this.retrySeq=0,this.retryState!=s.ENUM_RETRY_STATE.didNotStart&amp;&amp;(this.retryState=s.ENUM_RETRY_STATE.finished,this.currentRetryCount=0),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"PublishState"),this.streamCenter.playerList){var t=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[e].player;<span class="cstat-no" title="statement not covered" ></span>t.state==s.ENUM_PLAY_STATE.playing&amp;&amp;t.broadcasterStatus==s.ENUM_BROADCASTER_STATUS.stop&amp;&amp;(this.signal&amp;&amp;this.signal.sendBroadcasterStatus(o.getSeq(),t.sessionId,1),t.broadcasterStatus=s.ENUM_BROADCASTER_STATUS.start)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.setPublishQualityTimer();v</span>ar r=<span class="cstat-no" title="statement not covered" >2,</span>i=<span class="cstat-no" title="statement not covered" >2;<span class="cstat-no" title="statement not covered" ></span>0!==this.localStream.getVideoTracks().length&amp;&amp;1==this.localStream.getVideoTracks()[0].enabled&amp;&amp;(r=0),0!==this.localStream.getAudioTracks().length&amp;&amp;1==this.localStream.getAudioTracks()[0].enabled&amp;&amp;(i=0),this.signal.sendStreamStatus(o.getSeq(),this.sessionId,r,i),this.streamCenter.soundLevelDelegate&amp;&amp;this.startSoundLevel()}</span>,e.prototype.tryNextSignal=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.tryingNexitSignal=!0;v</span>ar t=<span class="cstat-no" title="statement not covered" >this.streamId,</span>r=<span class="cstat-no" title="statement not covered" >this.signal.server,</span>i=<span class="cstat-no" title="statement not covered" >this.streamCenter.publisherList[t],</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.serverUrls&amp;&amp;(n=i.serverUrls),this.retrySeq=o.getReportSeq(),this.streamCenter.stateCenter.reportSeqList.rePublish[t]=this.retrySeq,this.dataReport.newReport(this.retrySeq,u.eventList.kZegoTaskRePublish),this.dataReport.addMsgInfo(this.retrySeq,{serverUrls:n,reason:e}),this.nextSignalTryCount&gt;3*n.length?(this.logger.error("zp.tns.0 try max limit"),this.publishStateUpdateError(e)):(this.onPublishStateUpdate(o.ENUM_PUBLISH_STATE_UPDATE.retry,this.streamId,{code:0,msg:""}),n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t&lt;=n.indexOf(r)&amp;&amp;n.push(e)}</span>)),n.splice(0,n.indexOf(r)+1),this.logger.info("zp.tns.0 try next signal "+t),this.signal&amp;&amp;this.signal.state==s.ENUM_CONNECT_STATE.connected&amp;&amp;this.signal.sendCloseSession(o.getSeq(),this.sessionId,1),this.signal&amp;&amp;this.signal.removeSession(this.sessionId),this.resetPublish(),this.streamCenter.connectPublishServer(t,!0),this.nextSignalTryCount++)}</span>,e.prototype.startSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.ssl.0 call streamID: "+this.streamId),this.localStream&amp;&amp;0!=this.localStream.getAudioTracks().length){<span class="cstat-no" title="statement not covered" >this.script&amp;&amp;this.script.disconnect()&amp;&amp;(this.script=null),this.mic&amp;&amp;this.mic.disconnect()&amp;&amp;(this.mic=null);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.mic=this.ac.createMediaStreamSource(this.localStream),this.script=this.ac.createScriptProcessor(4096,1,1),this.mic.connect(this.script),this.script.connect(this.ac.destination),this.script.onaudioprocess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var r=t.inputBuffer.getChannelData(0),i=0,s=0;s&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >i&lt;r[s]&amp;&amp;(i=r[s]);<span class="cstat-no" title="statement not covered" >e</span></span>.soundLevel=100*i}</span>,this.ac.resume()}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.logger.error("zp.ssl.0 get sound level failed "+e)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.0 local stream no found")}</span></span>,e.prototype.stopSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.0.1 call streamID: "+this.streamId),this.script&amp;&amp;this.script.disconnect(),this.mic&amp;&amp;this.mic.disconnect(),this.script=null,this.mic=null}</span>,e}();t.ZegoPublish=h},function(e,t,r){var i;e.exports=function e(t,r,s){function o(a,c){if(!r[a]){<span class="missing-if-branch" title="if path not taken" >I</span>if(!t[a]){<span class="cstat-no" title="statement not covered" >if(!c&amp;&amp;"function"==typeof i&amp;&amp;i)<span class="cstat-no" title="statement not covered" >return i(a,!0);<span class="cstat-no" title="statement not covered" >i</span></span>f(n)<span class="cstat-no" title="statement not covered" >return n(a,!0);v</span></span>ar d=<span class="cstat-no" title="statement not covered" >new Error("Cannot find module '"+a+"'");<span class="cstat-no" title="statement not covered" ></span>throw d.code="MODULE_NOT_FOUND",d}</span>var l=r[a]={exports:{}};t[a][0].call(l.exports,(function(e){return o(t[a][1][e]||<span class="branch-1 cbranch-no" title="branch not covered" >e)</span>}),l,l.exports,e,t,r,s)}return r[a].exports}for(var n="function"==typeof i&amp;&amp;i,a=0;a&lt;s.length;a++)o(s[a]);return o}({1:[function(e,t,r){"use strict";var i=(0,e("./adapter_factory.js").adapterFactory)({window:window});t.exports=i},{"./adapter_factory.js":2}],2:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.adapterFactory=function(){var e=(arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:<span class="branch-1 cbranch-no" title="branch not covered" >{})</span>.window,t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>{shimChrome:!0,shimFirefox:!0,shimEdge:!0,shimSafari:!0},r=i.log,d=i.detectBrowser(e),l={browserDetails:d,commonShim:c,extractVersion:i.extractVersion,disableLog:i.disableLog,disableWarnings:i.disableWarnings};switch(d.browser){case"chrome":<span class="missing-if-branch" title="if path not taken" >I</span>if(!s||!s.shimPeerConnection||!t.shimChrome)<span class="cstat-no" title="statement not covered" >return r("Chrome shim is not included in this adapter release."),l;r</span>("adapter.js shimming chrome."),l.browserShim=s,s.shimGetUserMedia(e),s.shimMediaStream(e),s.shimPeerConnection(e),s.shimOnTrack(e),s.shimAddTrackRemoveTrack(e),s.shimGetSendersWithDtmf(e),s.shimGetStats(e),s.shimSenderReceiverGetStats(e),s.fixNegotiationNeeded(e),c.shimRTCIceCandidate(e),c.shimConnectionState(e),c.shimMaxMessageSize(e),c.shimSendThrowTypeError(e),c.removeAllowExtmapMixed(e);break;<span class="branch-1 cbranch-no" title="branch not covered" >case"firefox":<span class="cstat-no" title="statement not covered" >if(!n||!n.shimPeerConnection||!t.shimFirefox)<span class="cstat-no" title="statement not covered" >return r("Firefox shim is not included in this adapter release."),l;<span class="cstat-no" title="statement not covered" >r</span></span>("adapter.js shimming firefox."),l.browserShim=n,n.shimGetUserMedia(e),n.shimPeerConnection(e),n.shimOnTrack(e),n.shimRemoveStream(e),n.shimSenderGetStats(e),n.shimReceiverGetStats(e),n.shimRTCDataChannel(e),c.shimRTCIceCandidate(e),c.shimConnectionState(e),c.shimMaxMessageSize(e),c.shimSendThrowTypeError(e);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-2 cbranch-no" title="branch not covered" >c</span></span>ase"edge":<span class="cstat-no" title="statement not covered" >if(!o||!o.shimPeerConnection||!t.shimEdge)<span class="cstat-no" title="statement not covered" >return r("MS edge shim is not included in this adapter release."),l;<span class="cstat-no" title="statement not covered" >r</span></span>("adapter.js shimming edge."),l.browserShim=o,o.shimGetUserMedia(e),o.shimGetDisplayMedia(e),o.shimPeerConnection(e),o.shimReplaceTrack(e),c.shimMaxMessageSize(e),c.shimSendThrowTypeError(e);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-3 cbranch-no" title="branch not covered" >c</span></span>ase"safari":<span class="cstat-no" title="statement not covered" >if(!a||!t.shimSafari)<span class="cstat-no" title="statement not covered" >return r("Safari shim is not included in this adapter release."),l;<span class="cstat-no" title="statement not covered" >r</span></span>("adapter.js shimming safari."),l.browserShim=a,a.shimRTCIceServerUrls(e),a.shimCreateOfferLegacy(e),a.shimCallbacksAPI(e),a.shimLocalStreamsAPI(e),a.shimRemoteStreamsAPI(e),a.shimTrackEventTransceiver(e),a.shimGetUserMedia(e),c.shimRTCIceCandidate(e),c.shimMaxMessageSize(e),c.shimSendThrowTypeError(e),c.removeAllowExtmapMixed(e);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-4 cbranch-no" title="branch not covered" >d</span></span>efault:<span class="cstat-no" title="statement not covered" >r("Unsupported browser!")}</span></span>return l};var i=d(e("./utils")),s=d(e("./chrome/chrome_shim")),o=d(e("./edge/edge_shim")),n=d(e("./firefox/firefox_shim")),a=d(e("./safari/safari_shim")),c=d(e("./common_shim"));function d(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>},{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var i="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(e){return typeof e}:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>,</span>s=e("./getusermedia");Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:function(){return s.shimGetUserMedia}});var o=e("./getdisplaymedia");Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.shimGetDisplayMedia}</span>}),r.shimMediaStream=function(e){e.MediaStream=e.MediaStream||<span class="branch-1 cbranch-no" title="branch not covered" >e.webkitMediaStream}</span>,r.shimOnTrack=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"!==(void 0===e?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>i(e))||!e.RTCPeerConnection||"ontrack"in e.RTCPeerConnection.prototype)n.wrapPeerConnectionEvent(e,"track",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.transceiver||Object.defineProperty(e,"transceiver",{value:{receiver:e.receiver}}),e}</span>));else{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e.RTCPeerConnection.prototype,"ontrack",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._ontrack}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._ontrack&amp;&amp;this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=e)}</span>,enumerable:!0,configurable:!0});v</span>ar t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._ontrackpoly||(this._ontrackpoly=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.stream.addEventListener("addtrack",(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var s=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>s=e.RTCPeerConnection.prototype.getReceivers?r.getReceivers().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track&amp;&amp;e.track.id===i.track.id}</span>)):{track:i.track};v</span>ar o=<span class="cstat-no" title="statement not covered" >new Event("track");<span class="cstat-no" title="statement not covered" ></span>o.track=i.track,o.receiver=s,o.transceiver={receiver:s},o.streams=[t.stream],r.dispatchEvent(o)}</span>)),t.stream.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){var s=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>s=e.RTCPeerConnection.prototype.getReceivers?r.getReceivers().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track&amp;&amp;e.track.id===i.id}</span>)):{track:i};v</span>ar o=<span class="cstat-no" title="statement not covered" >new Event("track");<span class="cstat-no" title="statement not covered" ></span>o.track=i,o.receiver=s,o.transceiver={receiver:s},o.streams=[t.stream],r.dispatchEvent(o)}</span>))}</span>,this.addEventListener("addstream",this._ontrackpoly)),t.apply(this,arguments)}</span>}</span>},r.shimGetSendersWithDtmf=function(e){<span class="missing-if-branch" title="if path not taken" >I</span>if("object"===(void 0===e?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>i(e))&amp;&amp;e.RTCPeerConnection&amp;&amp;!("getSenders"in e.RTCPeerConnection.prototype)&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >"createDTMFSender"in e.RTCPeerConnection.prototype)</span>{var t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{track:t,get dtmf(){<span class="cstat-no" title="statement not covered" >return void 0===this._dtmf&amp;&amp;("audio"===t.kind?this._dtmf=e.createDTMFSender(t):this._dtmf=null),this._dtmf}</span>,_pc:e}}</span>;<span class="cstat-no" title="statement not covered" ></span>if(!e.RTCPeerConnection.prototype.getSenders){<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._senders=this._senders||[],this._senders.slice()}</span>;v</span>ar r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){var s=<span class="cstat-no" title="statement not covered" >r.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return s||(s=t(this,e),this._senders.push(s)),s}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.removeTrack;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.apply(this,arguments);v</span>ar t=<span class="cstat-no" title="statement not covered" >this._senders.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>-1!==t&amp;&amp;this._senders.splice(t,1)}</span>}</span>v</span>ar o=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.addStream;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._senders=this._senders||[],o.apply(this,[e]),e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r._senders.push(t(r,e))}</span>))}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.removeStream;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._senders=this._senders||[],n.apply(this,[e]),e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >t._senders.find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===e}</span>));<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;t._senders.splice(t._senders.indexOf(r),1)}</span>))}</span>}</span>else <span class="missing-if-branch" title="if path not taken" >I</span>if("object"===(void 0===e?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>i(e))&amp;&amp;e.RTCPeerConnection&amp;&amp;"getSenders"in e.RTCPeerConnection.prototype&amp;&amp;"createDTMFSender"in e.RTCPeerConnection.prototype&amp;&amp;e.RTCRtpSender&amp;&amp;!("dtmf"in e.RTCRtpSender.prototype)){var a=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getSenders;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >a.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t._pc=e}</span>)),t}</span>,Object.defineProperty(e.RTCRtpSender.prototype,"dtmf",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return void 0===this._dtmf&amp;&amp;("audio"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}</span>})}</span>},r.shimGetStats=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){var s=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>if(arguments.length&gt;0&amp;&amp;"function"==typeof e)<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments);<span class="cstat-no" title="statement not covered" >i</span></span>f(0===t.length&amp;&amp;(0===arguments.length||"function"!=typeof arguments[0]))<span class="cstat-no" title="statement not covered" >return t.apply(this,[]);v</span></span>ar n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return e.result().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >{id:e.id,timestamp:e.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type};<span class="cstat-no" title="statement not covered" ></span>e.names().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >r[t]=e.stat(t)}</span>)),t[r.id]=r}</span>)),t}</span>,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return new Map(Object.keys(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return[t,e[t]]}</span>)))}</span>;<span class="cstat-no" title="statement not covered" ></span>if(arguments.length&gt;=2){var c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o[1](a(n(e)))}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.apply(this,[c,arguments[0]])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.apply(s,[<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e(a(n(t)))}</span>,r])}</span>)).then(r,i)}</span>}},r.shimSenderReceiverGetStats=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"===(void 0===e?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>i(e))&amp;&amp;e.RTCPeerConnection&amp;&amp;e.RTCRtpSender&amp;&amp;e.RTCRtpReceiver){<span class="missing-if-branch" title="if path not taken" >I</span>if(!("getStats"in e.RTCRtpSender.prototype)){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getSenders;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t._pc=e}</span>)),r}</span>);v</span>ar r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(e.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >r.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return e._pc=this,e}</span>),e.RTCRtpSender.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._pc.getStats().then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n.filterStats(t,e.track,!0)}</span>))}</span>}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(!("getStats"in e.RTCRtpReceiver.prototype)){var s=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getReceivers;<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;(e.RTCPeerConnection.prototype.getReceivers=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >s.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t._pc=e}</span>)),t}</span>),n.wrapPeerConnectionEvent(e,"track",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.receiver._pc=e.srcElement,e}</span>)),e.RTCRtpReceiver.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._pc.getStats().then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n.filterStats(t,e.track,!1)}</span>))}</span>}<span class="missing-if-branch" title="else path not taken" >E</span></span>if("getStats"in e.RTCRtpSender.prototype&amp;&amp;"getStats"in e.RTCRtpReceiver.prototype){var o=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(arguments.length&gt;0&amp;&amp;arguments[0]instanceof e.MediaStreamTrack){var t=<span class="cstat-no" title="statement not covered" >arguments[0],</span>r=<span class="cstat-no" title="statement not covered" >void 0,</span>i=<span class="cstat-no" title="statement not covered" >void 0,</span>s=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>return this.getSenders().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.track===t&amp;&amp;(r?s=!0:r=e)}</span>)),this.getReceivers().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track===t&amp;&amp;(i?s=!0:i=e),e.track===t}</span>)),s||r&amp;&amp;i?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):r?r.getStats():i?i.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.apply(this,arguments)}</span>}}},r.shimAddTrackRemoveTrackWithNative=a,r.shimAddTrackRemoveTrack=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.RTCPeerConnection){var t=n.detectBrowser(e);<span class="missing-if-branch" title="else path not taken" >E</span>if(e.RTCPeerConnection.prototype.addTrack&amp;&amp;t.version&gt;=65)return a(e);var r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getLocalStreams;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >r.apply(this);<span class="cstat-no" title="statement not covered" ></span>return this._reverseStreams=this._reverseStreams||{},t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e._reverseStreams[t.id]}</span>))}</span>;v</span>ar i=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.addStream;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},t.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(r.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===e}</span>)))<span class="cstat-no" title="statement not covered" >throw new DOMException("Track already exists.","InvalidAccessError")}</span></span>)),!this._reverseStreams[t.id]){var s=<span class="cstat-no" title="statement not covered" >new e.MediaStream(t.getTracks());<span class="cstat-no" title="statement not covered" ></span>this._streams[t.id]=s,this._reverseStreams[s.id]=t,t=s}<span class="cstat-no" title="statement not covered" ></span>i</span>.apply(this,[t])}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.removeStream;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},s.apply(this,[this._streams[e.id]||e]),delete this._reverseStreams[this._streams[e.id]?this._streams[e.id].id:e.id],delete this._streams[e.id]}</span>,e.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if("closed"===this.signalingState)<span class="cstat-no" title="statement not covered" >throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");v</span></span>ar s=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments,1);<span class="cstat-no" title="statement not covered" ></span>if(1!==s.length||!s[0].getTracks().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e===t}</span>)))<span class="cstat-no" title="statement not covered" >throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track===t}</span>));<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >throw new DOMException("Track already exists.","InvalidAccessError");<span class="cstat-no" title="statement not covered" >t</span></span>his._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};v</span>ar n=<span class="cstat-no" title="statement not covered" >this._streams[r.id];<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >n.addTrack(t),Promise.resolve().then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.dispatchEvent(new Event("negotiationneeded"))}</span>));e</span>lse{var a=<span class="cstat-no" title="statement not covered" >new e.MediaStream([t]);<span class="cstat-no" title="statement not covered" ></span>this._streams[r.id]=a,this._reverseStreams[a.id]=r,this.addStream(a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track===t}</span>))}</span>,["createOffer","createAnswer"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype[t];<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >arguments,</span>i=<span class="cstat-no" title="statement not covered" >arguments.length&amp;&amp;"function"==typeof arguments[0];<span class="cstat-no" title="statement not covered" ></span>return i?r.apply(this,[<span class="fstat-no" title="function not covered" >fu</span>nction(r){var i=<span class="cstat-no" title="statement not covered" >d(e,r);<span class="cstat-no" title="statement not covered" ></span>t[0].apply(null,[i])}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t[1]&amp;&amp;t[1].apply(null,e)}</span>,arguments[2]]):r.apply(this,arguments).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return d(e,t)}</span>))}</span>}</span>));v</span>ar o=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.setLocalDescription;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.setLocalDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments.length&amp;&amp;arguments[0].type?(arguments[0]=l(this,arguments[0]),o.apply(this,arguments)):o.apply(this,arguments)}</span>;v</span>ar c=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype,"localDescription");<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(e.RTCPeerConnection.prototype,"localDescription",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >c.get.apply(this);<span class="cstat-no" title="statement not covered" ></span>return""===e.type?e:d(this,e)}</span>}),e.RTCPeerConnection.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if("closed"===this.signalingState)<span class="cstat-no" title="statement not covered" >throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");<span class="cstat-no" title="statement not covered" >i</span></span>f(!e._pc)<span class="cstat-no" title="statement not covered" >throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");<span class="cstat-no" title="statement not covered" >i</span></span>f(e._pc!==this)<span class="cstat-no" title="statement not covered" >throw new DOMException("Sender was not created by this connection.","InvalidAccessError");<span class="cstat-no" title="statement not covered" >t</span></span>his._streams=this._streams||{};v</span>ar r=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>Object.keys(this._streams).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t._streams[i].getTracks().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.track===t}</span>))&amp;&amp;(r=t._streams[i])}</span>)),r&amp;&amp;(1===r.getTracks().length?this.removeStream(this._reverseStreams[r.id]):r.removeTrack(e.track),this.dispatchEvent(new Event("negotiationneeded")))}</span>}</span>function <span class="fstat-no" title="function not covered" >d(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >t.sdp;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(e._reverseStreams||[]).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >e._reverseStreams[t],</span>s=<span class="cstat-no" title="statement not covered" >e._streams[i.id];<span class="cstat-no" title="statement not covered" ></span>r=r.replace(new RegExp(s.id,"g"),i.id)}</span>)),new RTCSessionDescription({type:t.type,sdp:r})}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >t.sdp;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(e._reverseStreams||[]).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >e._reverseStreams[t],</span>s=<span class="cstat-no" title="statement not covered" >e._streams[i.id];<span class="cstat-no" title="statement not covered" ></span>r=r.replace(new RegExp(i.id,"g"),s.id)}</span>)),new RTCSessionDescription({type:t.type,sdp:r})}</span>},r.shimPeerConnection=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(!e.RTCPeerConnection&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.webkitRTCPeerConnection&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >e.RTCPeerConnection=e.webkitRTCPeerConnection)</span>,e.RTCPeerConnection){["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(t){var r=e.RTCPeerConnection.prototype[t];e.RTCPeerConnection.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),r.apply(this,arguments)}</span>}));var t=e.RTCPeerConnection.prototype.addIceCandidate;e.RTCPeerConnection.prototype.addIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments[0]?t.apply(this,arguments):(arguments[1]&amp;&amp;arguments[1].apply(null),Promise.resolve())}</span>}},r.fixNegotiationNeeded=function(e){n.wrapPeerConnectionEvent(e,"negotiationneeded",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("stable"===e.target.signalingState)<span class="cstat-no" title="statement not covered" >return e}</span></span>))};var n=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("../utils.js"));function a(e){e.RTCPeerConnection.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e._shimmedLocalStreams[t][0]}</span>))}</span>;var t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(!r)<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments);<span class="cstat-no" title="statement not covered" >t</span></span>his._shimmedLocalStreams=this._shimmedLocalStreams||{};v</span>ar i=<span class="cstat-no" title="statement not covered" >t.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return this._shimmedLocalStreams[r.id]?-1===this._shimmedLocalStreams[r.id].indexOf(i)&amp;&amp;this._shimmedLocalStreams[r.id].push(i):this._shimmedLocalStreams[r.id]=[r,i],i}</span>;var r=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._shimmedLocalStreams=this._shimmedLocalStreams||{},e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(t.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===e}</span>)))<span class="cstat-no" title="statement not covered" >throw new DOMException("Track already exists.","InvalidAccessError")}</span></span>));v</span>ar i=<span class="cstat-no" title="statement not covered" >this.getSenders();<span class="cstat-no" title="statement not covered" ></span>r.apply(this,arguments);v</span>ar s=<span class="cstat-no" title="statement not covered" >this.getSenders().filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return-1===i.indexOf(e)}</span>));<span class="cstat-no" title="statement not covered" ></span>this._shimmedLocalStreams[e.id]=[e].concat(s)}</span>;var i=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[e.id],i.apply(this,arguments)}</span>;var s=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._shimmedLocalStreams=this._shimmedLocalStreams||{},e&amp;&amp;Object.keys(this._shimmedLocalStreams).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){var i=<span class="cstat-no" title="statement not covered" >t._shimmedLocalStreams[r].indexOf(e);<span class="cstat-no" title="statement not covered" ></span>-1!==i&amp;&amp;t._shimmedLocalStreams[r].splice(i,1),1===t._shimmedLocalStreams[r].length&amp;&amp;delete t._shimmedLocalStreams[r]}</span>)),s.apply(this,arguments)}</span>}},{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.navigator.mediaDevices&amp;&amp;"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&amp;&amp;("function"==typeof t?e.navigator.mediaDevices.getDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return t(r).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >r.video&amp;&amp;r.video.width,</span>s=<span class="cstat-no" title="statement not covered" >r.video&amp;&amp;r.video.height,</span>o=<span class="cstat-no" title="statement not covered" >r.video&amp;&amp;r.video.frameRate;<span class="cstat-no" title="statement not covered" ></span>return r.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:t,maxFrameRate:o||3}},i&amp;&amp;(r.video.mandatory.maxWidth=i),s&amp;&amp;(r.video.mandatory.maxHeight=s),e.navigator.mediaDevices.getUserMedia(r)}</span>))}</span>:console.error("shimGetDisplayMedia: getSourceId argument is not a function"))}</span>},{}],5:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>;</span>r.shimGetUserMedia=function(e){var t=e&amp;&amp;e.navigator;<span class="missing-if-branch" title="else path not taken" >E</span>if(t.mediaDevices){var r=s.detectBrowser(e),n=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("object"!==(void 0===e?"undefined":i(e))||e.mandatory||e.optional)<span class="cstat-no" title="statement not covered" >return e;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >if("require"!==r&amp;&amp;"advanced"!==r&amp;&amp;"mediaSource"!==r){var s=<span class="cstat-no" title="statement not covered" >"object"===i(e[r])?e[r]:{ideal:e[r]};<span class="cstat-no" title="statement not covered" ></span>void 0!==s.exact&amp;&amp;"number"==typeof s.exact&amp;&amp;(s.min=s.max=s.exact);v</span>ar o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e?e+t.charAt(0).toUpperCase()+t.slice(1):"deviceId"===t?"sourceId":t}</span>;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==s.ideal){<span class="cstat-no" title="statement not covered" >t.optional=t.optional||[];v</span>ar n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>"number"==typeof s.ideal?(n[o("min",r)]=s.ideal,t.optional.push(n),(n={})[o("max",r)]=s.ideal,t.optional.push(n)):(n[o("",r)]=s.ideal,t.optional.push(n))}<span class="cstat-no" title="statement not covered" ></span>v</span>oid 0!==s.exact&amp;&amp;"number"!=typeof s.exact?(t.mandatory=t.mandatory||{},t.mandatory[o("",r)]=s.exact):["min","max"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >void 0!==s[e]&amp;&amp;(t.mandatory=t.mandatory||{},t.mandatory[o(e,r)]=s[e])}</span>))}</span>}</span>)),e.advanced&amp;&amp;(t.optional=(t.optional||[]).concat(e.advanced)),t}</span>,a=function(e,s){<span class="missing-if-branch" title="else path not taken" >E</span>if(r.version&gt;=61)return s(e);<span class="cstat-no" title="statement not covered" >if((e=JSON.parse(JSON.stringify(e)))&amp;&amp;"object"===i(e.audio)){var a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >t in e&amp;&amp;!(r in e)&amp;&amp;(e[r]=e[t],delete e[t])}</span>;<span class="cstat-no" title="statement not covered" ></span>a((e=JSON.parse(JSON.stringify(e))).audio,"autoGainControl","googAutoGainControl"),a(e.audio,"noiseSuppression","googNoiseSuppression"),e.audio=n(e.audio)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e&amp;&amp;"object"===i(e.video)){var c=<span class="cstat-no" title="statement not covered" >e.video.facingMode;<span class="cstat-no" title="statement not covered" ></span>c=c&amp;&amp;("object"===(void 0===c?"undefined":i(c))?c:{ideal:c});v</span>ar d=<span class="cstat-no" title="statement not covered" >r.version&lt;66;<span class="cstat-no" title="statement not covered" ></span>if(c&amp;&amp;("user"===c.exact||"environment"===c.exact||"user"===c.ideal||"environment"===c.ideal)&amp;&amp;(!t.mediaDevices.getSupportedConstraints||!t.mediaDevices.getSupportedConstraints().facingMode||d)){<span class="cstat-no" title="statement not covered" >delete e.video.facingMode;v</span>ar l=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if("environment"===c.exact||"environment"===c.ideal?l=["back","rear"]:"user"!==c.exact&amp;&amp;"user"!==c.ideal||(l=["front"]),l)<span class="cstat-no" title="statement not covered" >return t.mediaDevices.enumerateDevices().then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >(t=t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"videoinput"===e.kind}</span>))).find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return l.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.label.toLowerCase().includes(t)}</span>))}</span>));<span class="cstat-no" title="statement not covered" ></span>return!r&amp;&amp;t.length&amp;&amp;l.includes("back")&amp;&amp;(r=t[t.length-1]),r&amp;&amp;(e.video.deviceId=c.exact?{exact:r.deviceId}:{ideal:r.deviceId}),e.video=n(e.video),o("chrome: "+JSON.stringify(e)),s(e)}</span>))}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.video=n(e.video)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o("chrome: "+JSON.stringify(e)),s(e)}</span>,c=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r.version&gt;=64?e:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[e.name]||e.name,message:e.message,constraint:e.constraint||e.constraintName,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.name+(this.message&amp;&amp;": ")+this.message}</span>}}</span>;<span class="missing-if-branch" title="else path not taken" >E</span>if(t.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >a(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.webkitGetUserMedia(e,r,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i(c(e))}</span>))}</span>))}</span>.bind(t),t.mediaDevices.getUserMedia){var d=t.mediaDevices.getUserMedia.bind(t.mediaDevices);t.mediaDevices.getUserMedia=function(e){return a(e,(function(e){return d(e).then((function(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.audio&amp;&amp;!t.getAudioTracks().length||e.video&amp;&amp;!t.getVideoTracks().length)<span class="cstat-no" title="statement not covered" >throw t.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.stop()}</span>)),new DOMException("","NotFoundError");r</span>eturn t}),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Promise.reject(c(e))}</span>))}))}}}};var s=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("../utils.js")),o=s.log},{"../utils.js":15}],6:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>;</span>r.shimRTCIceCandidate=function(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.RTCIceCandidate&amp;&amp;!(e.RTCIceCandidate&amp;&amp;"foundation"in e.RTCIceCandidate.prototype)){var t=<span class="cstat-no" title="statement not covered" >e.RTCIceCandidate;<span class="cstat-no" title="statement not covered" ></span>e.RTCIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===e?"undefined":i(e))&amp;&amp;e.candidate&amp;&amp;0===e.candidate.indexOf("a=")&amp;&amp;((e=JSON.parse(JSON.stringify(e))).candidate=e.candidate.substr(2)),e.candidate&amp;&amp;e.candidate.length){var r=<span class="cstat-no" title="statement not covered" >new t(e),</span>s=<span class="cstat-no" title="statement not covered" >n.default.parseCandidate(e.candidate),</span>o=<span class="cstat-no" title="statement not covered" >Object.assign(r,s);<span class="cstat-no" title="statement not covered" ></span>return o.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{candidate:o.candidate,sdpMid:o.sdpMid,sdpMLineIndex:o.sdpMLineIndex,usernameFragment:o.usernameFragment}}</span>,o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new t(e)}</span>,e.RTCIceCandidate.prototype=t.prototype,a.wrapPeerConnectionEvent(e,"icecandidate",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.candidate&amp;&amp;Object.defineProperty(t,"candidate",{value:new e.RTCIceCandidate(t.candidate),writable:"false"}),t}</span>))}</span>},r.shimMaxMessageSize=function(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(!e.RTCSctpTransport&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.RTCPeerConnection)</span>{var t=<span class="cstat-no" title="statement not covered" >a.detectBrowser(e);<span class="cstat-no" title="statement not covered" ></span>"sctp"in e.RTCPeerConnection.prototype||Object.defineProperty(e.RTCPeerConnection.prototype,"sctp",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return void 0===this._sctp?null:this._sctp}</span>});v</span>ar r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!e||!e.sdp)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >n.default.splitSections(e.sdp);<span class="cstat-no" title="statement not covered" ></span>return t.shift(),t.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >n.default.parseMLine(e);<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;"application"===t.kind&amp;&amp;-1!==t.protocol.indexOf("SCTP")}</span>))}</span>,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);<span class="cstat-no" title="statement not covered" ></span>if(null===t||t.length&lt;2)<span class="cstat-no" title="statement not covered" >return-1;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >parseInt(t[1],10);<span class="cstat-no" title="statement not covered" ></span>return r!=r?-1:r}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >65536;<span class="cstat-no" title="statement not covered" ></span>return"firefox"===t.browser&amp;&amp;(r=t.version&lt;57?-1===e?16384:2147483637:t.version&lt;60?57===t.version?65535:65536:2147483637),r}</span>,</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var i=<span class="cstat-no" title="statement not covered" >65536;<span class="cstat-no" title="statement not covered" ></span>"firefox"===t.browser&amp;&amp;57===t.version&amp;&amp;(i=65535);v</span>ar s=<span class="cstat-no" title="statement not covered" >n.default.matchPrefix(e.sdp,"a=max-message-size:");<span class="cstat-no" title="statement not covered" ></span>return s.length&gt;0?i=parseInt(s[0].substr(19),10):"firefox"===t.browser&amp;&amp;-1!==r&amp;&amp;(i=2147483637),i}</span>,</span>c=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this._sctp=null,r(arguments[0])){var e=<span class="cstat-no" title="statement not covered" >i(arguments[0]),</span>t=<span class="cstat-no" title="statement not covered" >s(e),</span>n=<span class="cstat-no" title="statement not covered" >o(arguments[0],e),</span>a=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>a=0===t&amp;&amp;0===n?Number.POSITIVE_INFINITY:0===t||0===n?Math.max(t,n):Math.min(t,n);v</span>ar d=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(d,"maxMessageSize",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a}</span>}),this._sctp=d}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn c.apply(this,arguments)}</span>}</span>},r.shimSendThrowTypeError=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.RTCPeerConnection&amp;&amp;"createDataChannel"in e.RTCPeerConnection.prototype){var t=e.RTCPeerConnection.prototype.createDataChannel;e.RTCPeerConnection.prototype.createDataChannel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >t.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return r(e,this),e}</span>,a.wrapPeerConnectionEvent(e,"datachannel",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r(e.channel,e.target),e}</span>))}function <span class="fstat-no" title="function not covered" >r(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >e.send;<span class="cstat-no" title="statement not covered" ></span>e.send=<span class="fstat-no" title="function not covered" >fu</span>nction(){var i=<span class="cstat-no" title="statement not covered" >arguments[0],</span>s=<span class="cstat-no" title="statement not covered" >i.length||i.size||i.byteLength;<span class="cstat-no" title="statement not covered" ></span>if("open"===e.readyState&amp;&amp;t.sctp&amp;&amp;s&gt;t.sctp.maxMessageSize)<span class="cstat-no" title="statement not covered" >throw new TypeError("Message too large (can send a maximum of "+t.sctp.maxMessageSize+" bytes)");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.apply(e,arguments)}</span>}</span>},r.shimConnectionState=function(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.RTCPeerConnection&amp;&amp;!("connectionState"in e.RTCPeerConnection.prototype)){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"connectionState",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState}</span>,enumerable:!0,configurable:!0}),Object.defineProperty(t,"onconnectionstatechange",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._onconnectionstatechange||null}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this._onconnectionstatechange&amp;&amp;(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),e&amp;&amp;this.addEventListener("connectionstatechange",this._onconnectionstatechange=e)}</span>,enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._connectionstatechangepoly||(this._connectionstatechangepoly=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.target;<span class="cstat-no" title="statement not covered" ></span>if(t._lastConnectionState!==t.connectionState){<span class="cstat-no" title="statement not covered" >t._lastConnectionState=t.connectionState;v</span>ar r=<span class="cstat-no" title="statement not covered" >new Event("connectionstatechange",e);<span class="cstat-no" title="statement not covered" ></span>t.dispatchEvent(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),r.apply(this,arguments)}</span>}</span>))}</span>},r.removeAllowExtmapMixed=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.RTCPeerConnection){var t=a.detectBrowser(e);<span class="missing-if-branch" title="if path not taken" >I</span>if(!("chrome"===t.browser&amp;&amp;t.version&gt;=71)){var r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.sdp&amp;&amp;-1!==e.sdp.indexOf("\na=extmap-allow-mixed")&amp;&amp;(e.sdp=e.sdp.split("\n").filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"a=extmap-allow-mixed"!==e.trim()}</span>)).join("\n")),r.apply(this,arguments)}</span>}</span>}};var s,o=e("sdp"),n=(s=o)&amp;&amp;s.__esModule?<span class="branch-0 cbranch-no" title="branch not covered" >s:</span>{default:s},a=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("./utils"))},{"./utils":15,sdp:17}],7:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var i=e("./getusermedia");Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.shimGetUserMedia}</span>});var s=e("./getdisplaymedia");Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.shimGetDisplayMedia}</span>}),r.shimPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >n.detectBrowser(e);<span class="cstat-no" title="statement not covered" ></span>if(e.RTCIceGatherer&amp;&amp;(e.RTCIceCandidate||(e.RTCIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e}</span>),e.RTCSessionDescription||(e.RTCSessionDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e}</span>),t.version&lt;15025)){var r=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype,"enabled");<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(e.MediaStreamTrack.prototype,"enabled",{set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.set.call(this,e);v</span>ar t=<span class="cstat-no" title="statement not covered" >new Event("enabled");<span class="cstat-no" title="statement not covered" ></span>t.enabled=e,this.dispatchEvent(t)}</span>})}<span class="cstat-no" title="statement not covered" ></span>!</span>e.RTCRtpSender||"dtmf"in e.RTCRtpSender.prototype||Object.defineProperty(e.RTCRtpSender.prototype,"dtmf",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return void 0===this._dtmf&amp;&amp;("audio"===this.track.kind?this._dtmf=new e.RTCDtmfSender(this):"video"===this.track.kind&amp;&amp;(this._dtmf=null)),this._dtmf}</span>}),e.RTCDtmfSender&amp;&amp;!e.RTCDTMFSender&amp;&amp;(e.RTCDTMFSender=e.RTCDtmfSender);v</span>ar i=<span class="cstat-no" title="statement not covered" >(0,d.default)(e,t.version);<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.iceServers&amp;&amp;(e.iceServers=(0,a.filterIceServers)(e.iceServers,t.version),n.log("ICE servers after filtering:",e.iceServers)),new i(e)}</span>,e.RTCPeerConnection.prototype=i.prototype}</span>,r.shimReplaceTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >!e.RTCRtpSender||"replaceTrack"in e.RTCRtpSender.prototype||(e.RTCRtpSender.prototype.replaceTrack=e.RTCRtpSender.prototype.setTrack)}</span>;var o,n=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("../utils")),a=e("./filtericeservers"),c=e("rtcpeerconnection-shim"),d=(o=c)&amp;&amp;o.__esModule?<span class="branch-0 cbranch-no" title="branch not covered" >o:</span>{default:o}},{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.filterIceServers=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return(e=JSON.parse(JSON.stringify(e))).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;(e.urls||e.url)){var t=<span class="cstat-no" title="statement not covered" >e.urls||e.url;<span class="cstat-no" title="statement not covered" ></span>e.url&amp;&amp;!e.urls&amp;&amp;i.deprecated("RTCIceServer.url","RTCIceServer.urls");v</span>ar s=<span class="cstat-no" title="statement not covered" >"string"==typeof t;<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(t=[t]),t=t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(0===e.indexOf("stun:"))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >e.startsWith("turn")&amp;&amp;!e.startsWith("turn:[")&amp;&amp;e.includes("transport=udp");<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;!r?(r=!0,!0):t&amp;&amp;!r}</span>)),delete e.url,e.urls=s?t[0]:t,!!t.length}</span>}</span>))}</span>;var i=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("../utils"))},{"../utils":15}],9:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"getDisplayMedia"in e.navigator&amp;&amp;e.navigator.mediaDevices&amp;&amp;(e.navigator.mediaDevices&amp;&amp;"getDisplayMedia"in e.navigator.mediaDevices||(e.navigator.mediaDevices.getDisplayMedia=e.navigator.getDisplayMedia.bind(e.navigator)))}</span>},{}],10:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.navigator,</span>r=<span class="cstat-no" title="statement not covered" >t.mediaDevices.getUserMedia.bind(t.mediaDevices);<span class="cstat-no" title="statement not covered" ></span>t.mediaDevices.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r(e).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Promise.reject(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{name:{PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:e.message,constraint:e.constraint,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.name}</span>}}</span>(e))}</span>))}</span>}</span>},{}],11:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var i="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>,</span>s=e("./getusermedia");Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.shimGetUserMedia}</span>});var o=e("./getdisplaymedia");Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.shimGetDisplayMedia}</span>}),r.shimOnTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"object"===(void 0===e?"undefined":i(e))&amp;&amp;e.RTCTrackEvent&amp;&amp;"receiver"in e.RTCTrackEvent.prototype&amp;&amp;!("transceiver"in e.RTCTrackEvent.prototype)&amp;&amp;Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{receiver:this.receiver}}</span>})}</span>,r.shimPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >n.detectBrowser(e);<span class="cstat-no" title="statement not covered" ></span>if("object"===(void 0===e?"undefined":i(e))&amp;&amp;(e.RTCPeerConnection||e.mozRTCPeerConnection)){<span class="cstat-no" title="statement not covered" >!e.RTCPeerConnection&amp;&amp;e.mozRTCPeerConnection&amp;&amp;(e.RTCPeerConnection=e.mozRTCPeerConnection),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype[t];<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),r.apply(this,arguments)}</span>}</span>));v</span>ar r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.addIceCandidate;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.addIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments[0]?r.apply(this,arguments):(arguments[1]&amp;&amp;arguments[1].apply(null),Promise.resolve())}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >{inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},</span>o=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getStats;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >return o.apply(this,[e||null]).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(t.version&lt;53&amp;&amp;!r)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.type=s[e.type]||e.type}</span>))}</span>catch(t){<span class="cstat-no" title="statement not covered" >if("TypeError"!==t.name)<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >e</span></span>.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >e.set(r,Object.assign({},t,{type:s[t.type]||t.type}))}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>)).then(r,i)}</span>}</span>}</span>,r.shimSenderGetStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===e?"undefined":i(e))&amp;&amp;e.RTCPeerConnection&amp;&amp;e.RTCRtpSender&amp;&amp;!(e.RTCRtpSender&amp;&amp;"getStats"in e.RTCRtpSender.prototype)){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getSenders;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t._pc=e}</span>)),r}</span>);v</span>ar r=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(e.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >r.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return e._pc=this,e}</span>),e.RTCRtpSender.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}</span>}</span>}</span>,r.shimReceiverGetStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===e?"undefined":i(e))&amp;&amp;e.RTCPeerConnection&amp;&amp;e.RTCRtpSender&amp;&amp;!(e.RTCRtpSender&amp;&amp;"getStats"in e.RTCRtpReceiver.prototype)){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.getReceivers;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.RTCPeerConnection.prototype.getReceivers=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t._pc=e}</span>)),r}</span>),n.wrapPeerConnectionEvent(e,"track",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.receiver._pc=e.srcElement,e}</span>)),e.RTCRtpReceiver.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._pc.getStats(this.track)}</span>}</span>}</span>,r.shimRemoveStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >!e.RTCPeerConnection||"removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>n.deprecated("removeStream","removeTrack"),this.getSenders().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >r.track&amp;&amp;e.getTracks().includes(r.track)&amp;&amp;t.removeTrack(r)}</span>))}</span>)}</span>,r.shimRTCDataChannel=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.DataChannel&amp;&amp;!e.RTCDataChannel&amp;&amp;(e.RTCDataChannel=e.DataChannel)}</span>;var n=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("../utils"))},{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.navigator.mediaDevices&amp;&amp;"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&amp;&amp;(e.navigator.mediaDevices.getDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >if(!r||!r.video){var i=<span class="cstat-no" title="statement not covered" >new DOMException("getDisplayMedia without video constraints is undefined");<span class="cstat-no" title="statement not covered" ></span>return i.name="NotFoundError",i.code=8,Promise.reject(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0===r.video?r.video={mediaSource:t}:r.video.mediaSource=t,e.navigator.mediaDevices.getUserMedia(r)}</span>)}</span>},{}],13:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>;</span>r.shimGetUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >s.detectBrowser(e),</span>r=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.navigator,</span>o=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.MediaStreamTrack;<span class="cstat-no" title="statement not covered" ></span>if(r.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,i){<span class="cstat-no" title="statement not covered" >s.deprecated("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),r.mediaDevices.getUserMedia(e).then(t,i)}</span>,!(t.version&gt;55&amp;&amp;"autoGainControl"in r.mediaDevices.getSupportedConstraints())){var n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >t in e&amp;&amp;!(r in e)&amp;&amp;(e[r]=e[t],delete e[t])}</span>,</span>a=<span class="cstat-no" title="statement not covered" >r.mediaDevices.getUserMedia.bind(r.mediaDevices);<span class="cstat-no" title="statement not covered" ></span>if(r.mediaDevices.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"object"===(void 0===e?"undefined":i(e))&amp;&amp;"object"===i(e.audio)&amp;&amp;(e=JSON.parse(JSON.stringify(e)),n(e.audio,"autoGainControl","mozAutoGainControl"),n(e.audio,"noiseSuppression","mozNoiseSuppression")),a(e)}</span>,o&amp;&amp;o.prototype.getSettings){var c=<span class="cstat-no" title="statement not covered" >o.prototype.getSettings;<span class="cstat-no" title="statement not covered" ></span>o.prototype.getSettings=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >c.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return n(e,"mozAutoGainControl","autoGainControl"),n(e,"mozNoiseSuppression","noiseSuppression"),e}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o&amp;&amp;o.prototype.applyConstraints){var d=<span class="cstat-no" title="statement not covered" >o.prototype.applyConstraints;<span class="cstat-no" title="statement not covered" ></span>o.prototype.applyConstraints=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"audio"===this.kind&amp;&amp;"object"===(void 0===e?"undefined":i(e))&amp;&amp;(e=JSON.parse(JSON.stringify(e)),n(e,"autoGainControl","mozAutoGainControl"),n(e,"noiseSuppression","mozNoiseSuppression")),d.apply(this,[e])}</span>}</span>}</span>}</span>;var s=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("../utils"))},{"../utils":15}],14:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>;</span>r.shimLocalStreamsAPI=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===e?"undefined":i(e))&amp;&amp;e.RTCPeerConnection){<span class="cstat-no" title="statement not covered" >if("getLocalStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._localStreams||(this._localStreams=[]),this._localStreams}</span>),!("addStream"in e.RTCPeerConnection.prototype)){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._localStreams||(this._localStreams=[]),this._localStreams.includes(e)||this._localStreams.push(e),e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return t.call(r,i,e)}</span>))}</span>,e.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return r&amp;&amp;(this._localStreams?this._localStreams.includes(r)||this._localStreams.push(r):this._localStreams=[r]),t.call(this,e,r)}</span>}<span class="cstat-no" title="statement not covered" ></span>"</span>removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._localStreams||(this._localStreams=[]);v</span>ar r=<span class="cstat-no" title="statement not covered" >this._localStreams.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(-1!==r){<span class="cstat-no" title="statement not covered" >this._localStreams.splice(r,1);v</span>ar i=<span class="cstat-no" title="statement not covered" >e.getTracks();<span class="cstat-no" title="statement not covered" ></span>this.getSenders().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.includes(e.track)&amp;&amp;t.removeTrack(e)}</span>))}</span>}</span>)}</span>}</span>,r.shimRemoteStreamsAPI=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===e?"undefined":i(e))&amp;&amp;e.RTCPeerConnection&amp;&amp;("getRemoteStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getRemoteStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._remoteStreams?this._remoteStreams:[]}</span>),!("onaddstream"in e.RTCPeerConnection.prototype))){<span class="cstat-no" title="statement not covered" >Object.defineProperty(e.RTCPeerConnection.prototype,"onaddstream",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._onaddstream}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._onaddstream&amp;&amp;(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=e),this.addEventListener("track",this._onaddstreampoly=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.streams.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(t._remoteStreams||(t._remoteStreams=[]),!t._remoteStreams.includes(e)){<span class="cstat-no" title="statement not covered" >t._remoteStreams.push(e);v</span>ar r=<span class="cstat-no" title="statement not covered" >new Event("addstream");<span class="cstat-no" title="statement not covered" ></span>r.stream=e,t.dispatchEvent(r)}</span>}</span>))}</span>)}</span>});v</span>ar t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.streams.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(e._remoteStreams||(e._remoteStreams=[]),!(e._remoteStreams.indexOf(t)&gt;=0)){<span class="cstat-no" title="statement not covered" >e._remoteStreams.push(t);v</span>ar r=<span class="cstat-no" title="statement not covered" >new Event("addstream");<span class="cstat-no" title="statement not covered" ></span>r.stream=t,e.dispatchEvent(r)}</span>}</span>))}</span>),t.apply(e,arguments)}</span>}</span>}</span>,r.shimCallbacksAPI=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===e?"undefined":i(e))&amp;&amp;e.RTCPeerConnection){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype,</span>r=<span class="cstat-no" title="statement not covered" >t.createOffer,</span>s=<span class="cstat-no" title="statement not covered" >t.createAnswer,</span>o=<span class="cstat-no" title="statement not covered" >t.setLocalDescription,</span>n=<span class="cstat-no" title="statement not covered" >t.setRemoteDescription,</span>a=<span class="cstat-no" title="statement not covered" >t.addIceCandidate;<span class="cstat-no" title="statement not covered" ></span>t.createOffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;=2?arguments[2]:arguments[0],</span>s=<span class="cstat-no" title="statement not covered" >r.apply(this,[i]);<span class="cstat-no" title="statement not covered" ></span>return t?(s.then(e,t),Promise.resolve()):s}</span>,t.createAnswer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;=2?arguments[2]:arguments[0],</span>i=<span class="cstat-no" title="statement not covered" >s.apply(this,[r]);<span class="cstat-no" title="statement not covered" ></span>return t?(i.then(e,t),Promise.resolve()):i}</span>;v</span>ar c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >o.apply(this,[e]);<span class="cstat-no" title="statement not covered" ></span>return r?(i.then(t,r),Promise.resolve()):i}</span>;<span class="cstat-no" title="statement not covered" ></span>t.setLocalDescription=c,c=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >n.apply(this,[e]);<span class="cstat-no" title="statement not covered" ></span>return r?(i.then(t,r),Promise.resolve()):i}</span>,t.setRemoteDescription=c,c=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >a.apply(this,[e]);<span class="cstat-no" title="statement not covered" ></span>return r?(i.then(t,r),Promise.resolve()):i}</span>,t.addIceCandidate=c}</span>}</span>,r.shimGetUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.navigator;<span class="cstat-no" title="statement not covered" ></span>if(t.mediaDevices&amp;&amp;t.mediaDevices.getUserMedia){var r=<span class="cstat-no" title="statement not covered" >t.mediaDevices,</span>i=<span class="cstat-no" title="statement not covered" >r.getUserMedia.bind(r);<span class="cstat-no" title="statement not covered" ></span>t.mediaDevices.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i(o(e))}</span>}<span class="cstat-no" title="statement not covered" ></span>!</span>t.getUserMedia&amp;&amp;t.mediaDevices&amp;&amp;t.mediaDevices.getUserMedia&amp;&amp;(t.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.mediaDevices.getUserMedia(e).then(r,i)}</span>.bind(t))}</span>,r.shimConstraints=o,r.shimRTCIceServerUrls=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;e.iceServers){<span class="cstat-no" title="statement not covered" >for(var i=[],o=0;o&lt;e.iceServers.length;o++){var n=<span class="cstat-no" title="statement not covered" >e.iceServers[o];<span class="cstat-no" title="statement not covered" ></span>!n.hasOwnProperty("urls")&amp;&amp;n.hasOwnProperty("url")?(s.deprecated("RTCIceServer.url","RTCIceServer.urls"),(n=JSON.parse(JSON.stringify(n))).urls=n.url,delete n.url,i.push(n)):i.push(e.iceServers[o])}<span class="cstat-no" title="statement not covered" ></span>e</span>.iceServers=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new t(e,r)}</span>,e.RTCPeerConnection.prototype=t.prototype,"generateCertificate"in e.RTCPeerConnection&amp;&amp;Object.defineProperty(e.RTCPeerConnection,"generateCertificate",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.generateCertificate}</span>})}</span>,r.shimTrackEventTransceiver=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"object"===(void 0===e?"undefined":i(e))&amp;&amp;e.RTCPeerConnection&amp;&amp;"receiver"in e.RTCTrackEvent.prototype&amp;&amp;!e.RTCTransceiver&amp;&amp;Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{receiver:this.receiver}}</span>})}</span>,r.shimCreateOfferLegacy=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.RTCPeerConnection.prototype.createOffer;<span class="cstat-no" title="statement not covered" ></span>e.RTCPeerConnection.prototype.createOffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >void 0!==e.offerToReceiveAudio&amp;&amp;(e.offerToReceiveAudio=!!e.offerToReceiveAudio);v</span>ar r=<span class="cstat-no" title="statement not covered" >this.getTransceivers().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"audio"===e.receiver.track.kind}</span>));<span class="cstat-no" title="statement not covered" ></span>!1===e.offerToReceiveAudio&amp;&amp;r?"sendrecv"===r.direction?r.setDirection?r.setDirection("sendonly"):r.direction="sendonly":"recvonly"===r.direction&amp;&amp;(r.setDirection?r.setDirection("inactive"):r.direction="inactive"):!0!==e.offerToReceiveAudio||r||this.addTransceiver("audio"),void 0!==e.offerToReceiveVideo&amp;&amp;(e.offerToReceiveVideo=!!e.offerToReceiveVideo);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.getTransceivers().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"video"===e.receiver.track.kind}</span>));<span class="cstat-no" title="statement not covered" ></span>!1===e.offerToReceiveVideo&amp;&amp;i?"sendrecv"===i.direction?i.setDirection?i.setDirection("sendonly"):i.direction="sendonly":"recvonly"===i.direction&amp;&amp;(i.setDirection?i.setDirection("inactive"):i.direction="inactive"):!0!==e.offerToReceiveVideo||i||this.addTransceiver("video")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.apply(this,arguments)}</span>}</span>;var s=function(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>(e("../utils"));function <span class="fstat-no" title="function not covered" >o(</span>e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;void 0!==e.video?Object.assign({},e,{video:s.compactObject(e.video)}):e}</span>},{"../utils":15}],15:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(e){return typeof e}:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>;</span>r.extractVersion=n,r.wrapPeerConnectionEvent=function(e,t,r){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.RTCPeerConnection){var i=e.RTCPeerConnection.prototype,s=i.addEventListener;i.addEventListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >if(e!==t)<span class="cstat-no" title="statement not covered" >return s.apply(this,arguments);v</span></span>ar o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >r(e);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;i(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>return this._eventMap=this._eventMap||{},this._eventMap[i]=o,s.apply(this,[e,o])}</span>;var o=i.removeEventListener;i.removeEventListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >if(e!==t||!this._eventMap||!this._eventMap[r])<span class="cstat-no" title="statement not covered" >return o.apply(this,arguments);v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this._eventMap[r];<span class="cstat-no" title="statement not covered" ></span>return delete this._eventMap[r],o.apply(this,[e,i])}</span>,Object.defineProperty(i,"on"+t,{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this["_on"+t]}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this["_on"+t]&amp;&amp;(this.removeEventListener(t,this["_on"+t]),delete this["_on"+t]),e&amp;&amp;this.addEventListener(t,this["_on"+t]=e)}</span>,enumerable:!0,configurable:!0})}},r.disableLog=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"boolean"!=typeof e?new Error("Argument type: "+(void 0===e?"undefined":i(e))+". Please use a boolean."):(s=e,e?"adapter.js logging disabled":"adapter.js logging enabled")}</span>,r.disableWarnings=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"boolean"!=typeof e?new Error("Argument type: "+(void 0===e?"undefined":i(e))+". Please use a boolean."):(o=!e,"adapter.js deprecation warnings "+(e?"disabled":"enabled"))}</span>,r.log=function(){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"===("undefined"==typeof window?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>i(window))){<span class="missing-if-branch" title="else path not taken" >E</span>if(s)return;<span class="cstat-no" title="statement not covered" >"undefined"!=typeof console&amp;&amp;"function"==typeof console.log&amp;&amp;console.log.apply(console,arguments)}</span>},r.deprecated=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >o&amp;&amp;console.warn(e+" is deprecated, please use "+t+" instead.")}</span>,r.detectBrowser=function(e){var t=e.navigator,r={browser:null,version:null};<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===e||!e.navigator)<span class="cstat-no" title="statement not covered" >return r.browser="Not a browser.",r;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t.mozGetUserMedia)<span class="cstat-no" title="statement not covered" >r.browser="firefox",r.version=n(t.userAgent,/Firefox\/(\d+)\./,1);e</span>lse <span class="missing-if-branch" title="else path not taken" >E</span>if(t.webkitGetUserMedia||<span class="branch-1 cbranch-no" title="branch not covered" >!1===e.isSecureContext&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.webkitRTCPeerConnection&amp;</span>&amp;<span class="branch-3 cbranch-no" title="branch not covered" >!e.RTCIceGatherer)</span>r.browser="chrome",r.version=n(t.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else <span class="cstat-no" title="statement not covered" >if(t.mediaDevices&amp;&amp;t.userAgent.match(/Edge\/(\d+).(\d+)$/))<span class="cstat-no" title="statement not covered" >r.browser="edge",r.version=n(t.userAgent,/Edge\/(\d+).(\d+)$/,2);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!e.RTCPeerConnection||!t.userAgent.match(/AppleWebKit\/(\d+)\./))<span class="cstat-no" title="statement not covered" >return r.browser="Not a supported browser.",r;<span class="cstat-no" title="statement not covered" >r</span></span>.browser="safari",r.version=n(t.userAgent,/AppleWebKit\/(\d+)\./,1)}</span>r</span>eturn r},r.compactObject=function <span class="fstat-no" title="function not covered" >e(</span>t){<span class="cstat-no" title="statement not covered" >return"object"!==(void 0===t?"undefined":i(t))?t:Object.keys(t).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(r,s){var o=<span class="cstat-no" title="statement not covered" >"object"===i(t[s]),</span>n=<span class="cstat-no" title="statement not covered" >o?e(t[s]):t[s],</span>a=<span class="cstat-no" title="statement not covered" >o&amp;&amp;!Object.keys(n).length;<span class="cstat-no" title="statement not covered" ></span>return void 0===n||a?r:Object.assign(r,<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}</span>({},s,n))}</span>),{})}</span>,r.walkStats=a,r.filterStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >r?"outbound-rtp":"inbound-rtp",</span>s=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>if(null===t)<span class="cstat-no" title="statement not covered" >return s;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"track"===e.type&amp;&amp;e.trackIdentifier===t.id&amp;&amp;o.push(e)}</span>)),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >r.type===i&amp;&amp;r.trackId===t.id&amp;&amp;a(e,r,s)}</span>))}</span>)),s}</span>;var s=!0,o=!0;function n(e,t,r){var i=e.match(t);return i&amp;&amp;i.length&gt;=r&amp;&amp;parseInt(i[r],10)}function <span class="fstat-no" title="function not covered" >a(</span>e,t,r){<span class="cstat-no" title="statement not covered" >t&amp;&amp;!r.has(t.id)&amp;&amp;(r.set(t.id,t),Object.keys(t).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >i.endsWith("Id")?a(e,e.get(t[i]),r):i.endsWith("Ids")&amp;&amp;t[i].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a(e,e.get(t),r)}</span>))}</span>)))}</span>},{}],16:[function(e,t,r){"use strict";var i=e("sdp");function <span class="fstat-no" title="function not covered" >s(</span>e,t,r,s,o){var n=<span class="cstat-no" title="statement not covered" >i.writeRtpDescription(e.kind,t);<span class="cstat-no" title="statement not covered" ></span>if(n+=i.writeIceParameters(e.iceGatherer.getLocalParameters()),n+=i.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),"offer"===r?"actpass":o||"active"),n+="a=mid:"+e.mid+"\r\n",e.rtpSender&amp;&amp;e.rtpReceiver?n+="a=sendrecv\r\n":e.rtpSender?n+="a=sendonly\r\n":e.rtpReceiver?n+="a=recvonly\r\n":n+="a=inactive\r\n",e.rtpSender){var a=<span class="cstat-no" title="statement not covered" >e.rtpSender._initialTrackId||e.rtpSender.track.id;<span class="cstat-no" title="statement not covered" ></span>e.rtpSender._initialTrackId=a;v</span>ar c=<span class="cstat-no" title="statement not covered" >"msid:"+(s?s.id:"-")+" "+a+"\r\n";<span class="cstat-no" title="statement not covered" ></span>n+="a="+c,n+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" "+c,e.sendEncodingParameters[0].rtx&amp;&amp;(n+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" "+c,n+="a=ssrc-group:FID "+e.sendEncodingParameters[0].ssrc+" "+e.sendEncodingParameters[0].rtx.ssrc+"\r\n")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" cname:"+i.localCName+"\r\n",e.rtpSender&amp;&amp;e.sendEncodingParameters[0].rtx&amp;&amp;(n+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" cname:"+i.localCName+"\r\n"),n}</span>function <span class="fstat-no" title="function not covered" >o(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >{codecs:[],headerExtensions:[],fecMechanisms:[]},</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e=parseInt(e,10);<span class="cstat-no" title="statement not covered" >f</span>or(var r=0;r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >if(t[r].payloadType===e||t[r].preferredPayloadType===e)<span class="cstat-no" title="statement not covered" >return t[r]}</span></span></span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s){var o=<span class="cstat-no" title="statement not covered" >i(e.parameters.apt,r),</span>n=<span class="cstat-no" title="statement not covered" >i(t.parameters.apt,s);<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;n&amp;&amp;o.name.toLowerCase()===n.name.toLowerCase()}</span>;<span class="cstat-no" title="statement not covered" ></span>return e.codecs.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >for(var o=0;o&lt;t.codecs.length;o++){var n=<span class="cstat-no" title="statement not covered" >t.codecs[o];<span class="cstat-no" title="statement not covered" ></span>if(i.name.toLowerCase()===n.name.toLowerCase()&amp;&amp;i.clockRate===n.clockRate){<span class="cstat-no" title="statement not covered" >if("rtx"===i.name.toLowerCase()&amp;&amp;i.parameters&amp;&amp;n.parameters.apt&amp;&amp;!s(i,n,e.codecs,t.codecs))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >(</span></span>n=JSON.parse(JSON.stringify(n))).numChannels=Math.min(i.numChannels,n.numChannels),r.codecs.push(n),n.rtcpFeedback=n.rtcpFeedback.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=0;t&lt;i.rtcpFeedback.length;t++)<span class="cstat-no" title="statement not covered" >if(i.rtcpFeedback[t].type===e.type&amp;&amp;i.rtcpFeedback[t].parameter===e.parameter)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}</span>)),e.headerExtensions.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;t.headerExtensions.length;i++){var s=<span class="cstat-no" title="statement not covered" >t.headerExtensions[i];<span class="cstat-no" title="statement not covered" ></span>if(e.uri===s.uri){<span class="cstat-no" title="statement not covered" >r.headerExtensions.push(s);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}</span>)),r}</span>function <span class="fstat-no" title="function not covered" >n(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return-1!=={offer:{setLocalDescription:["stable","have-local-offer"],setRemoteDescription:["stable","have-remote-offer"]},answer:{setLocalDescription:["have-remote-offer","have-local-pranswer"],setRemoteDescription:["have-local-offer","have-remote-pranswer"]}}[t][e].indexOf(r)}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >e.getRemoteCandidates().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.foundation===e.foundation&amp;&amp;t.ip===e.ip&amp;&amp;t.port===e.port&amp;&amp;t.priority===e.priority&amp;&amp;t.protocol===e.protocol&amp;&amp;t.type===e.type}</span>));<span class="cstat-no" title="statement not covered" ></span>return r||e.addRemoteCandidate(t),!r}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >new Error(t);<span class="cstat-no" title="statement not covered" ></span>return r.name=e,r.code={NotSupportedError:9,InvalidStateError:11,InvalidAccessError:15,TypeError:void 0,OperationError:void 0}[e],r}</span>t.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){function <span class="fstat-no" title="function not covered" >r(</span>t,r){<span class="cstat-no" title="statement not covered" >r.addTrack(t),r.dispatchEvent(new e.MediaStreamTrackEvent("addtrack",{track:t}))}</span>function <span class="fstat-no" title="function not covered" >d(</span>t,r,i,s){var o=<span class="cstat-no" title="statement not covered" >new Event("track");<span class="cstat-no" title="statement not covered" ></span>o.track=r,o.receiver=i,o.transceiver={receiver:i},o.streams=s,e.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t._dispatchEvent("track",o)}</span>))}</span>var l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(r){var s=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >document.createDocumentFragment();<span class="cstat-no" title="statement not covered" ></span>if(["addEventListener","removeEventListener","dispatchEvent"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s[e]=o[e].bind(o)}</span>)),this.canTrickleIceCandidates=null,this.needNegotiation=!1,this.localStreams=[],this.remoteStreams=[],this._localDescription=null,this._remoteDescription=null,this.signalingState="stable",this.iceConnectionState="new",this.connectionState="new",this.iceGatheringState="new",r=JSON.parse(JSON.stringify(r||{})),this.usingBundle="max-bundle"===r.bundlePolicy,"negotiate"===r.rtcpMuxPolicy)<span class="cstat-no" title="statement not covered" >throw c("NotSupportedError","rtcpMuxPolicy 'negotiate' is not supported");<span class="cstat-no" title="statement not covered" >s</span></span>witch(r.rtcpMuxPolicy||(r.rtcpMuxPolicy="require"),r.iceTransportPolicy){case"all":case"relay":<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >r.iceTransportPolicy="all"}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(r.bundlePolicy){case"balanced":case"max-compat":case"max-bundle":<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >r.bundlePolicy="balanced"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.iceServers=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return(e=JSON.parse(JSON.stringify(e))).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;(e.urls||e.url)){var i=<span class="cstat-no" title="statement not covered" >e.urls||e.url;<span class="cstat-no" title="statement not covered" ></span>e.url&amp;&amp;!e.urls&amp;&amp;console.warn("RTCIceServer.url is deprecated! Use urls instead.");v</span>ar s=<span class="cstat-no" title="statement not covered" >"string"==typeof i;<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(i=[i]),i=i.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0!==e.indexOf("turn:")||-1===e.indexOf("transport=udp")||-1!==e.indexOf("turn:[")||r?0===e.indexOf("stun:")&amp;&amp;t&gt;=14393&amp;&amp;-1===e.indexOf("?transport=udp"):(r=!0,!0)}</span>)),delete e.url,e.urls=s?i[0]:i,!!i.length}</span>}</span>))}</span>(r.iceServers||[],t),this._iceGatherers=[],r.iceCandidatePoolSize)<span class="cstat-no" title="statement not covered" >for(var n=r.iceCandidatePoolSize;n&gt;0;n--)<span class="cstat-no" title="statement not covered" >this._iceGatherers.push(new e.RTCIceGatherer({iceServers:r.iceServers,gatherPolicy:r.iceTransportPolicy}));e</span></span>lse <span class="cstat-no" title="statement not covered" >r.iceCandidatePoolSize=0;<span class="cstat-no" title="statement not covered" >t</span></span>his._config=r,this.transceivers=[],this._sdpSessionId=i.generateSessionId(),this._sdpSessionVersion=0,this._dtlsRole=void 0,this._isClosed=!1}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(l.prototype,"localDescription",{configurable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._localDescription}</span>}),Object.defineProperty(l.prototype,"remoteDescription",{configurable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._remoteDescription}</span>}),l.prototype.onicecandidate=null,l.prototype.onaddstream=null,l.prototype.ontrack=null,l.prototype.onremovestream=null,l.prototype.onsignalingstatechange=null,l.prototype.oniceconnectionstatechange=null,l.prototype.onconnectionstatechange=null,l.prototype.onicegatheringstatechange=null,l.prototype.onnegotiationneeded=null,l.prototype.ondatachannel=null,l.prototype._dispatchEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this._isClosed||(this.dispatchEvent(t),"function"==typeof this["on"+e]&amp;&amp;this["on"+e](t))}</span>,l.prototype._emitGatheringStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >new Event("icegatheringstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("icegatheringstatechange",e)}</span>,l.prototype.getConfiguration=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._config}</span>,l.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.localStreams}</span>,l.prototype.getRemoteStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.remoteStreams}</span>,l.prototype._createTransceiver=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this.transceivers.length&gt;0,</span>i=<span class="cstat-no" title="statement not covered" >{track:null,iceGatherer:null,iceTransport:null,dtlsTransport:null,localCapabilities:null,remoteCapabilities:null,rtpSender:null,rtpReceiver:null,kind:e,mid:null,sendEncodingParameters:null,recvEncodingParameters:null,stream:null,associatedRemoteMediaStreams:[],wantReceive:!0};<span class="cstat-no" title="statement not covered" ></span>if(this.usingBundle&amp;&amp;r)<span class="cstat-no" title="statement not covered" >i.iceTransport=this.transceivers[0].iceTransport,i.dtlsTransport=this.transceivers[0].dtlsTransport;e</span>lse{var s=<span class="cstat-no" title="statement not covered" >this._createIceAndDtlsTransports();<span class="cstat-no" title="statement not covered" ></span>i.iceTransport=s.iceTransport,i.dtlsTransport=s.dtlsTransport}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t||this.transceivers.push(i),i}</span>,l.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >if(this._isClosed)<span class="cstat-no" title="statement not covered" >throw c("InvalidStateError","Attempted to call addTrack on a closed peerconnection.");v</span></span>ar i;<span class="cstat-no" title="statement not covered" >if(this.transceivers.find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.track===t}</span>)))<span class="cstat-no" title="statement not covered" >throw c("InvalidAccessError","Track already exists.");<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=0;s&lt;this.transceivers.length;s++)<span class="cstat-no" title="statement not covered" >this.transceivers[s].track||this.transceivers[s].kind!==t.kind||(i=this.transceivers[s]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i||(i=this._createTransceiver(t.kind)),this._maybeFireNegotiationNeeded(),-1===this.localStreams.indexOf(r)&amp;&amp;this.localStreams.push(r),i.track=t,i.stream=r,i.rtpSender=new e.RTCRtpSender(t,i.dtlsTransport),i.rtpSender}</span>,l.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=15025)<span class="cstat-no" title="statement not covered" >e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >r.addTrack(t,e)}</span>));e</span>lse{var i=<span class="cstat-no" title="statement not covered" >e.clone();<span class="cstat-no" title="statement not covered" ></span>e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >i.getTracks()[t];<span class="cstat-no" title="statement not covered" ></span>e.addEventListener("enabled",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.enabled=e.enabled}</span>))}</span>)),i.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.addTrack(e,i)}</span>))}</span>}</span>,l.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this._isClosed)<span class="cstat-no" title="statement not covered" >throw c("InvalidStateError","Attempted to call removeTrack on a closed peerconnection.");<span class="cstat-no" title="statement not covered" >i</span></span>f(!(t instanceof e.RTCRtpSender))<span class="cstat-no" title="statement not covered" >throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.transceivers.find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.rtpSender===t}</span>));<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw c("InvalidAccessError","Sender was not created by this connection.");v</span></span>ar i=<span class="cstat-no" title="statement not covered" >r.stream;<span class="cstat-no" title="statement not covered" ></span>r.rtpSender.stop(),r.rtpSender=null,r.track=null,r.stream=null,-1===this.transceivers.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.stream}</span>)).indexOf(i)&amp;&amp;this.localStreams.indexOf(i)&gt;-1&amp;&amp;this.localStreams.splice(this.localStreams.indexOf(i),1),this._maybeFireNegotiationNeeded()}</span>,l.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >t.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===e}</span>));<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;t.removeTrack(r)}</span>))}</span>,l.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.transceivers.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!!e.rtpSender}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.rtpSender}</span>))}</span>,l.prototype.getReceivers=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.transceivers.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!!e.rtpReceiver}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.rtpReceiver}</span>))}</span>,l.prototype._createIceGatherer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;t&gt;0)<span class="cstat-no" title="statement not covered" >return this.transceivers[0].iceGatherer;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._iceGatherers.length)<span class="cstat-no" title="statement not covered" >return this._iceGatherers.shift();v</span></span>ar s=<span class="cstat-no" title="statement not covered" >new e.RTCIceGatherer({iceServers:this._config.iceServers,gatherPolicy:this._config.iceTransportPolicy});<span class="cstat-no" title="statement not covered" ></span>return Object.defineProperty(s,"state",{value:"new",writable:!0}),this.transceivers[t].bufferedCandidateEvents=[],this.transceivers[t].bufferCandidates=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >!e.candidate||0===Object.keys(e.candidate).length;<span class="cstat-no" title="statement not covered" ></span>s.state=r?"completed":"gathering",null!==i.transceivers[t].bufferedCandidateEvents&amp;&amp;i.transceivers[t].bufferedCandidateEvents.push(e)}</span>,s.addEventListener("localcandidate",this.transceivers[t].bufferCandidates),s}</span>,l.prototype._gather=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var s=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this.transceivers[r].iceGatherer;<span class="cstat-no" title="statement not covered" ></span>if(!o.onlocalcandidate){var n=<span class="cstat-no" title="statement not covered" >this.transceivers[r].bufferedCandidateEvents;<span class="cstat-no" title="statement not covered" ></span>this.transceivers[r].bufferedCandidateEvents=null,o.removeEventListener("localcandidate",this.transceivers[r].bufferCandidates),o.onlocalcandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!(s.usingBundle&amp;&amp;r&gt;0)){var n=<span class="cstat-no" title="statement not covered" >new Event("icecandidate");<span class="cstat-no" title="statement not covered" ></span>n.candidate={sdpMid:t,sdpMLineIndex:r};v</span>ar a=<span class="cstat-no" title="statement not covered" >e.candidate,</span>c=<span class="cstat-no" title="statement not covered" >!a||0===Object.keys(a).length;<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >"new"!==o.state&amp;&amp;"gathering"!==o.state||(o.state="completed");e</span>lse{<span class="cstat-no" title="statement not covered" >"new"===o.state&amp;&amp;(o.state="gathering"),a.component=1,a.ufrag=o.getLocalParameters().usernameFragment;v</span>ar d=<span class="cstat-no" title="statement not covered" >i.writeCandidate(a);<span class="cstat-no" title="statement not covered" ></span>n.candidate=Object.assign(n.candidate,i.parseCandidate(d)),n.candidate.candidate=d,n.candidate.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{candidate:n.candidate.candidate,sdpMid:n.candidate.sdpMid,sdpMLineIndex:n.candidate.sdpMLineIndex,usernameFragment:n.candidate.usernameFragment}}</span>}</span>v</span>ar l=<span class="cstat-no" title="statement not covered" >i.getMediaSections(s._localDescription.sdp);<span class="cstat-no" title="statement not covered" ></span>l[n.candidate.sdpMLineIndex]+=c?"a=end-of-candidates\r\n":"a="+n.candidate.candidate+"\r\n",s._localDescription.sdp=i.getDescription(s._localDescription.sdp)+l.join("");v</span>ar u=<span class="cstat-no" title="statement not covered" >s.transceivers.every((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.iceGatherer&amp;&amp;"completed"===e.iceGatherer.state}</span>));<span class="cstat-no" title="statement not covered" ></span>"gathering"!==s.iceGatheringState&amp;&amp;(s.iceGatheringState="gathering",s._emitGatheringStateChange()),c||s._dispatchEvent("icecandidate",n),u&amp;&amp;(s._dispatchEvent("icecandidate",new Event("icecandidate")),s.iceGatheringState="complete",s._emitGatheringStateChange())}</span>}</span>,e.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o.onlocalcandidate(e)}</span>))}</span>),0)}</span>}</span>,l.prototype._createIceAndDtlsTransports=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >new e.RTCIceTransport(null);<span class="cstat-no" title="statement not covered" ></span>r.onicestatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t._updateIceConnectionState(),t._updateConnectionState()}</span>;v</span>ar i=<span class="cstat-no" title="statement not covered" >new e.RTCDtlsTransport(r);<span class="cstat-no" title="statement not covered" ></span>return i.ondtlsstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t._updateConnectionState()}</span>,i.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Object.defineProperty(i,"state",{value:"failed",writable:!0}),t._updateConnectionState()}</span>,{iceTransport:r,dtlsTransport:i}}</span>,l.prototype._disposeIceAndDtlsTransports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.transceivers[e].iceGatherer;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(delete t.onlocalcandidate,delete this.transceivers[e].iceGatherer);v</span>ar r=<span class="cstat-no" title="statement not covered" >this.transceivers[e].iceTransport;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(delete r.onicestatechange,delete this.transceivers[e].iceTransport);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.transceivers[e].dtlsTransport;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(delete i.ondtlsstatechange,delete i.onerror,delete this.transceivers[e].dtlsTransport)}</span>,l.prototype._transceive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,s){var n=<span class="cstat-no" title="statement not covered" >o(e.localCapabilities,e.remoteCapabilities);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;e.rtpSender&amp;&amp;(n.encodings=e.sendEncodingParameters,n.rtcp={cname:i.localCName,compound:e.rtcpParameters.compound},e.recvEncodingParameters.length&amp;&amp;(n.rtcp.ssrc=e.recvEncodingParameters[0].ssrc),e.rtpSender.send(n)),s&amp;&amp;e.rtpReceiver&amp;&amp;n.codecs.length&gt;0&amp;&amp;("video"===e.kind&amp;&amp;e.recvEncodingParameters&amp;&amp;t&lt;15019&amp;&amp;e.recvEncodingParameters.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >delete e.rtx}</span>)),e.recvEncodingParameters.length?n.encodings=e.recvEncodingParameters:n.encodings=[{}],n.rtcp={compound:e.rtcpParameters.compound},e.rtcpParameters.cname&amp;&amp;(n.rtcp.cname=e.rtcpParameters.cname),e.sendEncodingParameters.length&amp;&amp;(n.rtcp.ssrc=e.sendEncodingParameters[0].ssrc),e.rtpReceiver.receive(n))}</span>,l.prototype.setLocalDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(-1===["offer","answer"].indexOf(e.type))<span class="cstat-no" title="statement not covered" >return Promise.reject(c("TypeError",'Unsupported type "'+e.type+'"'));<span class="cstat-no" title="statement not covered" >i</span></span>f(!n("setLocalDescription",e.type,s.signalingState)||s._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(c("InvalidStateError","Can not set local "+e.type+" in state "+s.signalingState));<span class="cstat-no" title="statement not covered" >i</span></span>f("offer"===e.type)<span class="cstat-no" title="statement not covered" >t=i.splitSections(e.sdp),r=t.shift(),t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >i.parseRtpParameters(e);<span class="cstat-no" title="statement not covered" ></span>s.transceivers[t].localCapabilities=r}</span>)),s.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >s._gather(e.mid,t)}</span>));e</span>lse <span class="cstat-no" title="statement not covered" >if("answer"===e.type){<span class="cstat-no" title="statement not covered" >t=i.splitSections(s._remoteDescription.sdp),r=t.shift();v</span>ar a=<span class="cstat-no" title="statement not covered" >i.matchPrefix(r,"a=ice-lite").length&gt;0;<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n=<span class="cstat-no" title="statement not covered" >s.transceivers[t],</span>c=<span class="cstat-no" title="statement not covered" >n.iceGatherer,</span>d=<span class="cstat-no" title="statement not covered" >n.iceTransport,</span>l=<span class="cstat-no" title="statement not covered" >n.dtlsTransport,</span>u=<span class="cstat-no" title="statement not covered" >n.localCapabilities,</span>h=<span class="cstat-no" title="statement not covered" >n.remoteCapabilities;<span class="cstat-no" title="statement not covered" ></span>if(!(i.isRejected(e)&amp;&amp;0===i.matchPrefix(e,"a=bundle-only").length||n.rejected)){var p=<span class="cstat-no" title="statement not covered" >i.getIceParameters(e,r),</span>g=<span class="cstat-no" title="statement not covered" >i.getDtlsParameters(e,r);<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(g.role="server"),s.usingBundle&amp;&amp;0!==t||(s._gather(n.mid,t),"new"===d.state&amp;&amp;d.start(c,p,a?"controlling":"controlled"),"new"===l.state&amp;&amp;l.start(g));v</span>ar m=<span class="cstat-no" title="statement not covered" >o(u,h);<span class="cstat-no" title="statement not covered" ></span>s._transceive(n,m.codecs.length&gt;0,!1)}</span>}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn s._localDescription={type:e.type,sdp:e.sdp},"offer"===e.type?s._updateSignalingState("have-local-offer"):s._updateSignalingState("stable"),Promise.resolve()}</span>,l.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(s){var l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(-1===["offer","answer"].indexOf(s.type))<span class="cstat-no" title="statement not covered" >return Promise.reject(c("TypeError",'Unsupported type "'+s.type+'"'));<span class="cstat-no" title="statement not covered" >i</span></span>f(!n("setRemoteDescription",s.type,l.signalingState)||l._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(c("InvalidStateError","Can not set remote "+s.type+" in state "+l.signalingState));v</span></span>ar u=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>l.remoteStreams.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >u[e.id]=e}</span>));v</span>ar h=<span class="cstat-no" title="statement not covered" >[],</span>p=<span class="cstat-no" title="statement not covered" >i.splitSections(s.sdp),</span>g=<span class="cstat-no" title="statement not covered" >p.shift(),</span>m=<span class="cstat-no" title="statement not covered" >i.matchPrefix(g,"a=ice-lite").length&gt;0,</span>f=<span class="cstat-no" title="statement not covered" >i.matchPrefix(g,"a=group:BUNDLE ").length&gt;0;<span class="cstat-no" title="statement not covered" ></span>l.usingBundle=f;v</span>ar v=<span class="cstat-no" title="statement not covered" >i.matchPrefix(g,"a=ice-options:")[0];<span class="cstat-no" title="statement not covered" ></span>return l.canTrickleIceCandidates=!!v&amp;&amp;v.substr(14).split(" ").indexOf("trickle")&gt;=0,p.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n,c){var d=<span class="cstat-no" title="statement not covered" >i.splitLines(n),</span>p=<span class="cstat-no" title="statement not covered" >i.getKind(n),</span>v=<span class="cstat-no" title="statement not covered" >i.isRejected(n)&amp;&amp;0===i.matchPrefix(n,"a=bundle-only").length,</span>S=<span class="cstat-no" title="statement not covered" >d[0].substr(2).split(" ")[2],</span>y=<span class="cstat-no" title="statement not covered" >i.getDirection(n,g),</span>C=<span class="cstat-no" title="statement not covered" >i.parseMsid(n),</span>b=<span class="cstat-no" title="statement not covered" >i.getMid(n)||i.generateIdentifier();<span class="cstat-no" title="statement not covered" ></span>if(v||"application"===p&amp;&amp;("DTLS/SCTP"===S||"UDP/DTLS/SCTP"===S))<span class="cstat-no" title="statement not covered" >l.transceivers[c]={mid:b,kind:p,protocol:S,rejected:!0};e</span>lse{var E,T,R,_,k,L,M,P,I;<span class="cstat-no" title="statement not covered" >!v&amp;&amp;l.transceivers[c]&amp;&amp;l.transceivers[c].rejected&amp;&amp;(l.transceivers[c]=l._createTransceiver(p,!0));v</span>ar U,w,D=<span class="cstat-no" title="statement not covered" >i.parseRtpParameters(n);<span class="cstat-no" title="statement not covered" ></span>v||(U=i.getIceParameters(n,g),(w=i.getDtlsParameters(n,g)).role="client"),M=i.parseRtpEncodingParameters(n);v</span>ar N=<span class="cstat-no" title="statement not covered" >i.parseRtcpParameters(n),</span>O=<span class="cstat-no" title="statement not covered" >i.matchPrefix(n,"a=end-of-candidates",g).length&gt;0,</span>A=<span class="cstat-no" title="statement not covered" >i.matchPrefix(n,"a=candidate:").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i.parseCandidate(e)}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 1===e.component}</span>));<span class="cstat-no" title="statement not covered" ></span>if(("offer"===s.type||"answer"===s.type)&amp;&amp;!v&amp;&amp;f&amp;&amp;c&gt;0&amp;&amp;l.transceivers[c]&amp;&amp;(l._disposeIceAndDtlsTransports(c),l.transceivers[c].iceGatherer=l.transceivers[0].iceGatherer,l.transceivers[c].iceTransport=l.transceivers[0].iceTransport,l.transceivers[c].dtlsTransport=l.transceivers[0].dtlsTransport,l.transceivers[c].rtpSender&amp;&amp;l.transceivers[c].rtpSender.setTransport(l.transceivers[0].dtlsTransport),l.transceivers[c].rtpReceiver&amp;&amp;l.transceivers[c].rtpReceiver.setTransport(l.transceivers[0].dtlsTransport)),"offer"!==s.type||v)<span class="cstat-no" title="statement not covered" >"answer"!==s.type||v||(T=(E=l.transceivers[c]).iceGatherer,R=E.iceTransport,_=E.dtlsTransport,k=E.rtpReceiver,L=E.sendEncodingParameters,P=E.localCapabilities,l.transceivers[c].recvEncodingParameters=M,l.transceivers[c].remoteCapabilities=D,l.transceivers[c].rtcpParameters=N,A.length&amp;&amp;"new"===R.state&amp;&amp;(!m&amp;&amp;!O||f&amp;&amp;0!==c?A.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >a(E.iceTransport,e)}</span>)):R.setRemoteCandidates(A)),f&amp;&amp;0!==c||("new"===R.state&amp;&amp;R.start(T,U,"controlling"),"new"===_.state&amp;&amp;_.start(w)),!o(E.localCapabilities,E.remoteCapabilities).codecs.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"rtx"===e.name.toLowerCase()}</span>)).length&amp;&amp;E.sendEncodingParameters[0].rtx&amp;&amp;delete E.sendEncodingParameters[0].rtx,l._transceive(E,"sendrecv"===y||"recvonly"===y,"sendrecv"===y||"sendonly"===y),!k||"sendrecv"!==y&amp;&amp;"sendonly"!==y?delete E.rtpReceiver:(I=k.track,C?(u[C.stream]||(u[C.stream]=new e.MediaStream),r(I,u[C.stream]),h.push([I,k,u[C.stream]])):(u.default||(u.default=new e.MediaStream),r(I,u.default),h.push([I,k,u.default]))));e</span>lse{<span class="cstat-no" title="statement not covered" >(E=l.transceivers[c]||l._createTransceiver(p)).mid=b,E.iceGatherer||(E.iceGatherer=l._createIceGatherer(c,f)),A.length&amp;&amp;"new"===E.iceTransport.state&amp;&amp;(!O||f&amp;&amp;0!==c?A.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >a(E.iceTransport,e)}</span>)):E.iceTransport.setRemoteCandidates(A)),P=e.RTCRtpReceiver.getCapabilities(p),t&lt;15019&amp;&amp;(P.codecs=P.codecs.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"rtx"!==e.name}</span>))),L=E.sendEncodingParameters||[{ssrc:1001*(2*c+2)}];v</span>ar x,z=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>"sendrecv"===y||"sendonly"===y?(z=!E.rtpReceiver,k=E.rtpReceiver||new e.RTCRtpReceiver(E.dtlsTransport,p),z&amp;&amp;(I=k.track,C&amp;&amp;"-"===C.stream||(C?(u[C.stream]||(u[C.stream]=new e.MediaStream,Object.defineProperty(u[C.stream],"id",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return C.stream}</span>})),Object.defineProperty(I,"id",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return C.track}</span>}),x=u[C.stream]):(u.default||(u.default=new e.MediaStream),x=u.default)),x&amp;&amp;(r(I,x),E.associatedRemoteMediaStreams.push(x)),h.push([I,k,x]))):E.rtpReceiver&amp;&amp;E.rtpReceiver.track&amp;&amp;(E.associatedRemoteMediaStreams.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >t.getTracks().find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.id===E.rtpReceiver.track.id}</span>));<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >r.removeTrack(t),r.dispatchEvent(new e.MediaStreamTrackEvent("removetrack",{track:t}))}</span>(r,t)}</span>)),E.associatedRemoteMediaStreams=[]),E.localCapabilities=P,E.remoteCapabilities=D,E.rtpReceiver=k,E.rtcpParameters=N,E.sendEncodingParameters=L,E.recvEncodingParameters=M,l._transceive(l.transceivers[c],!1,z)}</span>}</span>}</span>)),void 0===l._dtlsRole&amp;&amp;(l._dtlsRole="offer"===s.type?"active":"passive"),l._remoteDescription={type:s.type,sdp:s.sdp},"offer"===s.type?l._updateSignalingState("have-remote-offer"):l._updateSignalingState("stable"),Object.keys(u).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >u[t];<span class="cstat-no" title="statement not covered" ></span>if(r.getTracks().length){<span class="cstat-no" title="statement not covered" >if(-1===l.remoteStreams.indexOf(r)){<span class="cstat-no" title="statement not covered" >l.remoteStreams.push(r);v</span>ar i=<span class="cstat-no" title="statement not covered" >new Event("addstream");<span class="cstat-no" title="statement not covered" ></span>i.stream=r,e.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l._dispatchEvent("addstream",i)}</span>))}<span class="cstat-no" title="statement not covered" ></span>h</span>.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e[0],</span>i=<span class="cstat-no" title="statement not covered" >e[1];<span class="cstat-no" title="statement not covered" ></span>r.id===e[2].id&amp;&amp;d(l,t,i,[r])}</span>))}</span>}</span>)),h.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e[2]||d(l,e[0],e[1],[])}</span>)),e.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.transceivers&amp;&amp;l.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.iceTransport&amp;&amp;"new"===e.iceTransport.state&amp;&amp;e.iceTransport.getRemoteCandidates().length&gt;0&amp;&amp;(console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"),e.iceTransport.addRemoteCandidate({}))}</span>))}</span>),4e3),Promise.resolve()}</span>,l.prototype.close=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.iceTransport&amp;&amp;e.iceTransport.stop(),e.dtlsTransport&amp;&amp;e.dtlsTransport.stop(),e.rtpSender&amp;&amp;e.rtpSender.stop(),e.rtpReceiver&amp;&amp;e.rtpReceiver.stop()}</span>)),this._isClosed=!0,this._updateSignalingState("closed")}</span>,l.prototype._updateSignalingState=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.signalingState=e;v</span>ar t=<span class="cstat-no" title="statement not covered" >new Event("signalingstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("signalingstatechange",t)}</span>,l.prototype._maybeFireNegotiationNeeded=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>"stable"===this.signalingState&amp;&amp;!0!==this.needNegotiation&amp;&amp;(this.needNegotiation=!0,e.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(t.needNegotiation){<span class="cstat-no" title="statement not covered" >t.needNegotiation=!1;v</span>ar e=<span class="cstat-no" title="statement not covered" >new Event("negotiationneeded");<span class="cstat-no" title="statement not covered" ></span>t._dispatchEvent("negotiationneeded",e)}</span>}</span>),0))}</span>,l.prototype._updateIceConnectionState=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t=<span class="cstat-no" title="statement not covered" >{new:0,closed:0,checking:0,connected:0,completed:0,disconnected:0,failed:0};<span class="cstat-no" title="statement not covered" ></span>if(this.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.iceTransport&amp;&amp;!e.rejected&amp;&amp;t[e.iceTransport.state]++}</span>)),e="new",t.failed&gt;0?e="failed":t.checking&gt;0?e="checking":t.disconnected&gt;0?e="disconnected":t.new&gt;0?e="new":t.connected&gt;0?e="connected":t.completed&gt;0&amp;&amp;(e="completed"),e!==this.iceConnectionState){<span class="cstat-no" title="statement not covered" >this.iceConnectionState=e;v</span>ar r=<span class="cstat-no" title="statement not covered" >new Event("iceconnectionstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("iceconnectionstatechange",r)}</span>}</span>,l.prototype._updateConnectionState=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t=<span class="cstat-no" title="statement not covered" >{new:0,closed:0,connecting:0,connected:0,completed:0,disconnected:0,failed:0};<span class="cstat-no" title="statement not covered" ></span>if(this.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.iceTransport&amp;&amp;e.dtlsTransport&amp;&amp;!e.rejected&amp;&amp;(t[e.iceTransport.state]++,t[e.dtlsTransport.state]++)}</span>)),t.connected+=t.completed,e="new",t.failed&gt;0?e="failed":t.connecting&gt;0?e="connecting":t.disconnected&gt;0?e="disconnected":t.new&gt;0?e="new":t.connected&gt;0&amp;&amp;(e="connected"),e!==this.connectionState){<span class="cstat-no" title="statement not covered" >this.connectionState=e;v</span>ar r=<span class="cstat-no" title="statement not covered" >new Event("connectionstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("connectionstatechange",r)}</span>}</span>,l.prototype.createOffer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(r._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(c("InvalidStateError","Can not call createOffer after close"));v</span></span>ar o=<span class="cstat-no" title="statement not covered" >r.transceivers.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"audio"===e.kind}</span>)).length,</span>n=<span class="cstat-no" title="statement not covered" >r.transceivers.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"video"===e.kind}</span>)).length,</span>a=<span class="cstat-no" title="statement not covered" >arguments[0];<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >if(a.mandatory||a.optional)<span class="cstat-no" title="statement not covered" >throw new TypeError("Legacy mandatory/optional constraints not supported.");<span class="cstat-no" title="statement not covered" >v</span></span>oid 0!==a.offerToReceiveAudio&amp;&amp;(o=!0===a.offerToReceiveAudio?1:!1===a.offerToReceiveAudio?0:a.offerToReceiveAudio),void 0!==a.offerToReceiveVideo&amp;&amp;(n=!0===a.offerToReceiveVideo?1:!1===a.offerToReceiveVideo?0:a.offerToReceiveVideo)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(r.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"audio"===e.kind?--o&lt;0&amp;&amp;(e.wantReceive=!1):"video"===e.kind&amp;&amp;--n&lt;0&amp;&amp;(e.wantReceive=!1)}</span>));o&gt;0||n&gt;0;)<span class="cstat-no" title="statement not covered" >o&gt;0&amp;&amp;(r._createTransceiver("audio"),o--),n&gt;0&amp;&amp;(r._createTransceiver("video"),n--);v</span></span>ar d=<span class="cstat-no" title="statement not covered" >i.writeSessionBoilerplate(r._sdpSessionId,r._sdpSessionVersion++);<span class="cstat-no" title="statement not covered" ></span>r.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){var n=<span class="cstat-no" title="statement not covered" >s.track,</span>a=<span class="cstat-no" title="statement not covered" >s.kind,</span>c=<span class="cstat-no" title="statement not covered" >s.mid||i.generateIdentifier();<span class="cstat-no" title="statement not covered" ></span>s.mid=c,s.iceGatherer||(s.iceGatherer=r._createIceGatherer(o,r.usingBundle));v</span>ar d=<span class="cstat-no" title="statement not covered" >e.RTCRtpSender.getCapabilities(a);<span class="cstat-no" title="statement not covered" ></span>t&lt;15019&amp;&amp;(d.codecs=d.codecs.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"rtx"!==e.name}</span>))),d.codecs.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"H264"===e.name&amp;&amp;void 0===e.parameters["level-asymmetry-allowed"]&amp;&amp;(e.parameters["level-asymmetry-allowed"]="1"),s.remoteCapabilities&amp;&amp;s.remoteCapabilities.codecs&amp;&amp;s.remoteCapabilities.codecs.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.name.toLowerCase()===t.name.toLowerCase()&amp;&amp;e.clockRate===t.clockRate&amp;&amp;(e.preferredPayloadType=t.payloadType)}</span>))}</span>)),d.headerExtensions.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >(s.remoteCapabilities&amp;&amp;s.remoteCapabilities.headerExtensions||[]).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.uri===t.uri&amp;&amp;(e.id=t.id)}</span>))}</span>));v</span>ar l=<span class="cstat-no" title="statement not covered" >s.sendEncodingParameters||[{ssrc:1001*(2*o+1)}];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t&gt;=15019&amp;&amp;"video"===a&amp;&amp;!l[0].rtx&amp;&amp;(l[0].rtx={ssrc:l[0].ssrc+1}),s.wantReceive&amp;&amp;(s.rtpReceiver=new e.RTCRtpReceiver(s.dtlsTransport,a)),s.localCapabilities=d,s.sendEncodingParameters=l}</span>)),"max-compat"!==r._config.bundlePolicy&amp;&amp;(d+="a=group:BUNDLE "+r.transceivers.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.mid}</span>)).join(" ")+"\r\n"),d+="a=ice-options:trickle\r\n",r.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >d+=s(e,e.localCapabilities,"offer",e.stream,r._dtlsRole),d+="a=rtcp-rsize\r\n",!e.iceGatherer||"new"===r.iceGatheringState||0!==t&amp;&amp;r.usingBundle||(e.iceGatherer.getLocalCandidates().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.component=1,d+="a="+i.writeCandidate(e)+"\r\n"}</span>)),"completed"===e.iceGatherer.state&amp;&amp;(d+="a=end-of-candidates\r\n"))}</span>));v</span>ar l=<span class="cstat-no" title="statement not covered" >new e.RTCSessionDescription({type:"offer",sdp:d});<span class="cstat-no" title="statement not covered" ></span>return Promise.resolve(l)}</span>,l.prototype.createAnswer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(r._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(c("InvalidStateError","Can not call createAnswer after close"));<span class="cstat-no" title="statement not covered" >i</span></span>f("have-remote-offer"!==r.signalingState&amp;&amp;"have-local-pranswer"!==r.signalingState)<span class="cstat-no" title="statement not covered" >return Promise.reject(c("InvalidStateError","Can not call createAnswer in signalingState "+r.signalingState));v</span></span>ar n=<span class="cstat-no" title="statement not covered" >i.writeSessionBoilerplate(r._sdpSessionId,r._sdpSessionVersion++);<span class="cstat-no" title="statement not covered" ></span>r.usingBundle&amp;&amp;(n+="a=group:BUNDLE "+r.transceivers.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.mid}</span>)).join(" ")+"\r\n"),n+="a=ice-options:trickle\r\n";v</span>ar a=<span class="cstat-no" title="statement not covered" >i.getMediaSections(r._remoteDescription.sdp).length;<span class="cstat-no" title="statement not covered" ></span>r.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,i){<span class="cstat-no" title="statement not covered" >if(!(i+1&gt;a)){<span class="cstat-no" title="statement not covered" >if(e.rejected)<span class="cstat-no" title="statement not covered" >return"application"===e.kind?"DTLS/SCTP"===e.protocol?n+="m=application 0 DTLS/SCTP 5000\r\n":n+="m=application 0 "+e.protocol+" webrtc-datachannel\r\n":"audio"===e.kind?n+="m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n":"video"===e.kind&amp;&amp;(n+="m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"),void(n+="c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:"+e.mid+"\r\n");v</span></span>ar c;<span class="cstat-no" title="statement not covered" >e.stream&amp;&amp;("audio"===e.kind?c=e.stream.getAudioTracks()[0]:"video"===e.kind&amp;&amp;(c=e.stream.getVideoTracks()[0]),c&amp;&amp;t&gt;=15019&amp;&amp;"video"===e.kind&amp;&amp;!e.sendEncodingParameters[0].rtx&amp;&amp;(e.sendEncodingParameters[0].rtx={ssrc:e.sendEncodingParameters[0].ssrc+1}));v</span>ar d=<span class="cstat-no" title="statement not covered" >o(e.localCapabilities,e.remoteCapabilities);<span class="cstat-no" title="statement not covered" ></span>!d.codecs.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"rtx"===e.name.toLowerCase()}</span>)).length&amp;&amp;e.sendEncodingParameters[0].rtx&amp;&amp;delete e.sendEncodingParameters[0].rtx,n+=s(e,d,"answer",e.stream,r._dtlsRole),e.rtcpParameters&amp;&amp;e.rtcpParameters.reducedSize&amp;&amp;(n+="a=rtcp-rsize\r\n")}</span>}</span>));v</span>ar d=<span class="cstat-no" title="statement not covered" >new e.RTCSessionDescription({type:"answer",sdp:n});<span class="cstat-no" title="statement not covered" ></span>return Promise.resolve(d)}</span>,l.prototype.addIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;void 0===e.sdpMLineIndex&amp;&amp;!e.sdpMid?Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")):new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){<span class="cstat-no" title="statement not covered" >if(!r._remoteDescription)<span class="cstat-no" title="statement not covered" >return o(c("InvalidStateError","Can not add ICE candidate without a remote description"));<span class="cstat-no" title="statement not covered" >i</span></span>f(e&amp;&amp;""!==e.candidate){var n=<span class="cstat-no" title="statement not covered" >e.sdpMLineIndex;<span class="cstat-no" title="statement not covered" ></span>if(e.sdpMid)<span class="cstat-no" title="statement not covered" >for(var d=0;d&lt;r.transceivers.length;d++)<span class="cstat-no" title="statement not covered" >if(r.transceivers[d].mid===e.sdpMid){<span class="cstat-no" title="statement not covered" >n=d;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>v</span></span></span>ar l=<span class="cstat-no" title="statement not covered" >r.transceivers[n];<span class="cstat-no" title="statement not covered" ></span>if(!l)<span class="cstat-no" title="statement not covered" >return o(c("OperationError","Can not add ICE candidate"));<span class="cstat-no" title="statement not covered" >i</span></span>f(l.rejected)<span class="cstat-no" title="statement not covered" >return s();v</span></span>ar u=<span class="cstat-no" title="statement not covered" >Object.keys(e.candidate).length&gt;0?i.parseCandidate(e.candidate):{};<span class="cstat-no" title="statement not covered" ></span>if("tcp"===u.protocol&amp;&amp;(0===u.port||9===u.port))<span class="cstat-no" title="statement not covered" >return s();<span class="cstat-no" title="statement not covered" >i</span></span>f(u.component&amp;&amp;1!==u.component)<span class="cstat-no" title="statement not covered" >return s();<span class="cstat-no" title="statement not covered" >i</span></span>f((0===n||n&gt;0&amp;&amp;l.iceTransport!==r.transceivers[0].iceTransport)&amp;&amp;!a(l.iceTransport,u))<span class="cstat-no" title="statement not covered" >return o(c("OperationError","Can not add ICE candidate"));v</span></span>ar h=<span class="cstat-no" title="statement not covered" >e.candidate.trim();<span class="cstat-no" title="statement not covered" ></span>0===h.indexOf("a=")&amp;&amp;(h=h.substr(2)),(t=i.getMediaSections(r._remoteDescription.sdp))[n]+="a="+(u.type?h:"end-of-candidates")+"\r\n",r._remoteDescription.sdp=i.getDescription(r._remoteDescription.sdp)+t.join("")}</span>else <span class="cstat-no" title="statement not covered" >for(var p=0;p&lt;r.transceivers.length&amp;&amp;(r.transceivers[p].rejected||(r.transceivers[p].iceTransport.addRemoteCandidate({}),(t=i.getMediaSections(r._remoteDescription.sdp))[p]+="a=end-of-candidates\r\n",r._remoteDescription.sdp=i.getDescription(r._remoteDescription.sdp)+t.join(""),!r.usingBundle));p++);<span class="cstat-no" title="statement not covered" >s</span></span>()}</span>))}</span>,l.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;t instanceof e.MediaStreamTrack){var r=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.rtpSender&amp;&amp;e.rtpSender.track===t?r=e.rtpSender:e.rtpReceiver&amp;&amp;e.rtpReceiver.track===t&amp;&amp;(r=e.rtpReceiver)}</span>)),!r)<span class="cstat-no" title="statement not covered" >throw c("InvalidAccessError","Invalid selector.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.getStats()}</span>v</span>ar i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.transceivers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >["rtpSender","rtpReceiver","iceGatherer","iceTransport","dtlsTransport"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e[t]&amp;&amp;i.push(e[t].getStats())}</span>))}</span>)),Promise.all(i).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.set(e.id,e)}</span>))}</span>)),t}</span>))}</span>,["RTCRtpSender","RTCRtpReceiver","RTCIceGatherer","RTCIceTransport","RTCDtlsTransport"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;r.prototype&amp;&amp;r.prototype.getStats){var i=<span class="cstat-no" title="statement not covered" >r.prototype.getStats;<span class="cstat-no" title="statement not covered" ></span>r.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.apply(this).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){var i;<span class="cstat-no" title="statement not covered" >e[r].type={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[(i=e[r]).type]||i.type,t.set(r,e[r])}</span>)),t}</span>))}</span>}</span>}</span>));v</span>ar u=<span class="cstat-no" title="statement not covered" >["createOffer","createAnswer"];<span class="cstat-no" title="statement not covered" ></span>return u.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >l.prototype[e];<span class="cstat-no" title="statement not covered" ></span>l.prototype[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof e[0]||"function"==typeof e[1]?t.apply(this,[arguments[2]]).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"function"==typeof e[0]&amp;&amp;e[0].apply(null,[t])}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"function"==typeof e[1]&amp;&amp;e[1].apply(null,[t])}</span>)):t.apply(this,arguments)}</span>}</span>)),(u=["setLocalDescription","setRemoteDescription","addIceCandidate"]).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >l.prototype[e];<span class="cstat-no" title="statement not covered" ></span>l.prototype[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof e[1]||"function"==typeof e[2]?t.apply(this,arguments).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"function"==typeof e[1]&amp;&amp;e[1].apply(null)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"function"==typeof e[2]&amp;&amp;e[2].apply(null,[t])}</span>)):t.apply(this,arguments)}</span>}</span>)),["getStats"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >l.prototype[e];<span class="cstat-no" title="statement not covered" ></span>l.prototype[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof e[1]?t.apply(this,arguments).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"function"==typeof e[1]&amp;&amp;e[1].apply(null)}</span>)):t.apply(this,arguments)}</span>}</span>)),l}</span>},{sdp:17}],17:[function(e,t,r){"use strict";var i={generateIdentifier:function(){return Math.random().toString(36).substr(2,10)}};i.localCName=i.generateIdentifier(),i.splitLines=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.trim().split("\n").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.trim()}</span>))}</span>,i.splitSections=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.split("\nm=").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return(t&gt;0?"m="+e:e).trim()+"\r\n"}</span>))}</span>,i.getDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >i.splitSections(e);<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;t[0]}</span>,i.getMediaSections=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >i.splitSections(e);<span class="cstat-no" title="statement not covered" ></span>return t.shift(),t}</span>,i.matchPrefix=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return i.splitLines(e).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0===e.indexOf(t)}</span>))}</span>,i.parseCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t,r={foundation:(t=0===e.indexOf("a=candidate:")?e.substring(12).split(" "):e.substring(10).split(" "))[0],component:parseInt(t[1],10),protocol:t[2].toLowerCase(),priority:parseInt(t[3],10),ip:t[4],address:t[4],port:parseInt(t[5],10),type:t[7]},i=8;i&lt;t.length;i+=2)<span class="cstat-no" title="statement not covered" >switch(t[i]){case"raddr":<span class="cstat-no" title="statement not covered" >r.relatedAddress=t[i+1];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rport":<span class="cstat-no" title="statement not covered" >r.relatedPort=parseInt(t[i+1],10);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"tcptype":<span class="cstat-no" title="statement not covered" >r.tcpType=t[i+1];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ufrag":<span class="cstat-no" title="statement not covered" >r.ufrag=t[i+1],r.usernameFragment=t[i+1];<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >r[t[i]]=t[i+1]}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn r}</span>,i.writeCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.push(e.foundation),t.push(e.component),t.push(e.protocol.toUpperCase()),t.push(e.priority),t.push(e.address||e.ip),t.push(e.port);v</span>ar r=<span class="cstat-no" title="statement not covered" >e.type;<span class="cstat-no" title="statement not covered" ></span>return t.push("typ"),t.push(r),"host"!==r&amp;&amp;e.relatedAddress&amp;&amp;e.relatedPort&amp;&amp;(t.push("raddr"),t.push(e.relatedAddress),t.push("rport"),t.push(e.relatedPort)),e.tcpType&amp;&amp;"tcp"===e.protocol.toLowerCase()&amp;&amp;(t.push("tcptype"),t.push(e.tcpType)),(e.usernameFragment||e.ufrag)&amp;&amp;(t.push("ufrag"),t.push(e.usernameFragment||e.ufrag)),"candidate:"+t.join(" ")}</span>,i.parseIceOptions=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.substr(14).split(" ")}</span>,i.parseRtpMap=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.substr(9).split(" "),</span>r=<span class="cstat-no" title="statement not covered" >{payloadType:parseInt(t.shift(),10)};<span class="cstat-no" title="statement not covered" ></span>return t=t[0].split("/"),r.name=t[0],r.clockRate=parseInt(t[1],10),r.channels=3===t.length?parseInt(t[2],10):1,r.numChannels=r.channels,r}</span>,i.writeRtpMap=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.payloadType;<span class="cstat-no" title="statement not covered" ></span>void 0!==e.preferredPayloadType&amp;&amp;(t=e.preferredPayloadType);v</span>ar r=<span class="cstat-no" title="statement not covered" >e.channels||e.numChannels||1;<span class="cstat-no" title="statement not covered" ></span>return"a=rtpmap:"+t+" "+e.name+"/"+e.clockRate+(1!==r?"/"+r:"")+"\r\n"}</span>,i.parseExtmap=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.substr(9).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{id:parseInt(t[0],10),direction:t[0].indexOf("/")&gt;0?t[0].split("/")[1]:"sendrecv",uri:t[1]}}</span>,i.writeExtmap=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"a=extmap:"+(e.id||e.preferredId)+(e.direction&amp;&amp;"sendrecv"!==e.direction?"/"+e.direction:"")+" "+e.uri+"\r\n"}</span>,i.parseFmtp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t,r={},i=e.substr(e.indexOf(" ")+1).split(";"),s=0;s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >r[(t=i[s].trim().split("="))[0].trim()]=t[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,i.writeFmtp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >"",</span>r=<span class="cstat-no" title="statement not covered" >e.payloadType;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==e.preferredPayloadType&amp;&amp;(r=e.preferredPayloadType),e.parameters&amp;&amp;Object.keys(e.parameters).length){var i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>Object.keys(e.parameters).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.parameters[t]?i.push(t+"="+e.parameters[t]):i.push(t)}</span>)),t+="a=fmtp:"+r+" "+i.join(";")+"\r\n"}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,i.parseRtcpFb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.substr(e.indexOf(" ")+1).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{type:t.shift(),parameter:t.join(" ")}}</span>,i.writeRtcpFb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >"",</span>r=<span class="cstat-no" title="statement not covered" >e.payloadType;<span class="cstat-no" title="statement not covered" ></span>return void 0!==e.preferredPayloadType&amp;&amp;(r=e.preferredPayloadType),e.rtcpFeedback&amp;&amp;e.rtcpFeedback.length&amp;&amp;e.rtcpFeedback.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t+="a=rtcp-fb:"+r+" "+e.type+(e.parameter&amp;&amp;e.parameter.length?" "+e.parameter:"")+"\r\n"}</span>)),t}</span>,i.parseSsrcMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.indexOf(" "),</span>r=<span class="cstat-no" title="statement not covered" >{ssrc:parseInt(e.substr(7,t-7),10)},</span>i=<span class="cstat-no" title="statement not covered" >e.indexOf(":",t);<span class="cstat-no" title="statement not covered" ></span>return i&gt;-1?(r.attribute=e.substr(t+1,i-t-1),r.value=e.substr(i+1)):r.attribute=e.substr(t+1),r}</span>,i.parseSsrcGroup=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.substr(13).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{semantics:t.shift(),ssrcs:t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return parseInt(e,10)}</span>))}}</span>,i.getMid=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=mid:")[0];<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t.substr(6)}</span></span>,i.parseFingerprint=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.substr(14).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{algorithm:t[0].toLowerCase(),value:t[1]}}</span>,i.getDtlsParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{role:"auto",fingerprints:i.matchPrefix(e+t,"a=fingerprint:").map(i.parseFingerprint)}}</span>,i.writeDtlsParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >"a=setup:"+t+"\r\n";<span class="cstat-no" title="statement not covered" ></span>return e.fingerprints.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r+="a=fingerprint:"+e.algorithm+" "+e.value+"\r\n"}</span>)),r}</span>,i.getIceParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >i.splitLines(e);<span class="cstat-no" title="statement not covered" ></span>return{usernameFragment:(r=r.concat(i.splitLines(t))).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0===e.indexOf("a=ice-ufrag:")}</span>))[0].substr(12),password:r.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0===e.indexOf("a=ice-pwd:")}</span>))[0].substr(10)}}</span>,i.writeIceParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"a=ice-ufrag:"+e.usernameFragment+"\r\na=ice-pwd:"+e.password+"\r\n"}</span>,i.parseRtpParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},r=i.splitLines(e)[0].split(" "),s=3;s&lt;r.length;s++){var o=<span class="cstat-no" title="statement not covered" >r[s],</span>n=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=rtpmap:"+o+" ")[0];<span class="cstat-no" title="statement not covered" ></span>if(n){var a=<span class="cstat-no" title="statement not covered" >i.parseRtpMap(n),</span>c=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=fmtp:"+o+" ");<span class="cstat-no" title="statement not covered" ></span>switch(a.parameters=c.length?i.parseFmtp(c[0]):{},a.rtcpFeedback=i.matchPrefix(e,"a=rtcp-fb:"+o+" ").map(i.parseRtcpFb),t.codecs.push(a),a.name.toUpperCase()){case"RED":case"ULPFEC":<span class="cstat-no" title="statement not covered" >t.fecMechanisms.push(a.name.toUpperCase())}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.matchPrefix(e,"a=extmap:").forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.headerExtensions.push(i.parseExtmap(e))}</span>)),t}</span>,i.writeRtpDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>r+="m="+e+" ",r+=t.codecs.length&gt;0?"9":"0",r+=" UDP/TLS/RTP/SAVPF ",r+=t.codecs.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e.preferredPayloadType?e.preferredPayloadType:e.payloadType}</span>)).join(" ")+"\r\n",r+="c=IN IP4 0.0.0.0\r\n",r+="a=rtcp:9 IN IP4 0.0.0.0\r\n",t.codecs.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r+=i.writeRtpMap(e),r+=i.writeFmtp(e),r+=i.writeRtcpFb(e)}</span>));v</span>ar s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.codecs.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.maxptime&gt;s&amp;&amp;(s=e.maxptime)}</span>)),s&gt;0&amp;&amp;(r+="a=maxptime:"+s+"\r\n"),r+="a=rtcp-mux\r\n",t.headerExtensions&amp;&amp;t.headerExtensions.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r+=i.writeExtmap(e)}</span>)),r}</span>,i.parseRtpEncodingParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >i.parseRtpParameters(e),</span>o=<span class="cstat-no" title="statement not covered" >-1!==s.fecMechanisms.indexOf("RED"),</span>n=<span class="cstat-no" title="statement not covered" >-1!==s.fecMechanisms.indexOf("ULPFEC"),</span>a=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=ssrc:").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i.parseSsrcMedia(e)}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"cname"===e.attribute}</span>)),</span>c=<span class="cstat-no" title="statement not covered" >a.length&gt;0&amp;&amp;a[0].ssrc,</span>d=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=ssrc-group:FID").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.substr(17).split(" ").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return parseInt(e,10)}</span>))}</span>));<span class="cstat-no" title="statement not covered" ></span>d.length&gt;0&amp;&amp;d[0].length&gt;1&amp;&amp;d[0][0]===c&amp;&amp;(t=d[0][1]),s.codecs.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("RTX"===e.name.toUpperCase()&amp;&amp;e.parameters.apt){var i=<span class="cstat-no" title="statement not covered" >{ssrc:c,codecPayloadType:parseInt(e.parameters.apt,10)};<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;t&amp;&amp;(i.rtx={ssrc:t}),r.push(i),o&amp;&amp;((i=JSON.parse(JSON.stringify(i))).fec={ssrc:c,mechanism:n?"red+ulpfec":"red"},r.push(i))}</span>}</span>)),0===r.length&amp;&amp;c&amp;&amp;r.push({ssrc:c});v</span>ar l=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"b=");<span class="cstat-no" title="statement not covered" ></span>return l.length&amp;&amp;(l=0===l[0].indexOf("b=TIAS:")?parseInt(l[0].substr(7),10):0===l[0].indexOf("b=AS:")?1e3*parseInt(l[0].substr(5),10)*.95-16e3:void 0,r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.maxBitrate=l}</span>))),r}</span>,i.parseRtcpParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{},</span>r=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=ssrc:").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i.parseSsrcMedia(e)}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"cname"===e.attribute}</span>))[0];<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(t.cname=r.value,t.ssrc=r.ssrc);v</span>ar s=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=rtcp-rsize");<span class="cstat-no" title="statement not covered" ></span>t.reducedSize=s.length&gt;0,t.compound=0===s.length;v</span>ar o=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=rtcp-mux");<span class="cstat-no" title="statement not covered" ></span>return t.mux=o.length&gt;0,t}</span>,i.parseMsid=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=msid:");<span class="cstat-no" title="statement not covered" ></span>if(1===r.length)<span class="cstat-no" title="statement not covered" >return{stream:(t=r[0].substr(7).split(" "))[0],track:t[1]};v</span></span>ar s=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"a=ssrc:").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i.parseSsrcMedia(e)}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"msid"===e.attribute}</span>));<span class="cstat-no" title="statement not covered" ></span>return s.length&gt;0?{stream:(t=s[0].value.split(" "))[0],track:t[1]}:void 0}</span>,i.generateSessionId=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Math.random().toString().substr(2,21)}</span>,i.writeSessionBoilerplate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var s=<span class="cstat-no" title="statement not covered" >void 0!==t?t:2;<span class="cstat-no" title="statement not covered" ></span>return"v=0\r\no="+(r||"thisisadapterortc")+" "+(e||i.generateSessionId())+" "+s+" IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"}</span>,i.writeMediaSection=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s){var o=<span class="cstat-no" title="statement not covered" >i.writeRtpDescription(e.kind,t);<span class="cstat-no" title="statement not covered" ></span>if(o+=i.writeIceParameters(e.iceGatherer.getLocalParameters()),o+=i.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),"offer"===r?"actpass":"active"),o+="a=mid:"+e.mid+"\r\n",e.direction?o+="a="+e.direction+"\r\n":e.rtpSender&amp;&amp;e.rtpReceiver?o+="a=sendrecv\r\n":e.rtpSender?o+="a=sendonly\r\n":e.rtpReceiver?o+="a=recvonly\r\n":o+="a=inactive\r\n",e.rtpSender){var n=<span class="cstat-no" title="statement not covered" >"msid:"+s.id+" "+e.rtpSender.track.id+"\r\n";<span class="cstat-no" title="statement not covered" ></span>o+="a="+n,o+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" "+n,e.sendEncodingParameters[0].rtx&amp;&amp;(o+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" "+n,o+="a=ssrc-group:FID "+e.sendEncodingParameters[0].ssrc+" "+e.sendEncodingParameters[0].rtx.ssrc+"\r\n")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" cname:"+i.localCName+"\r\n",e.rtpSender&amp;&amp;e.sendEncodingParameters[0].rtx&amp;&amp;(o+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" cname:"+i.localCName+"\r\n"),o}</span>,i.getDirection=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var r=i.splitLines(e),s=0;s&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >switch(r[s]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":<span class="cstat-no" title="statement not covered" >return r[s].substr(2)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t?i.getDirection(t):"sendrecv"}</span>,i.getKind=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i.splitLines(e)[0].split(" ")[0].substr(2)}</span>,i.isRejected=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"0"===e.split(" ",2)[1]}</span>,i.parseMLine=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >i.splitLines(e)[0].substr(2).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{kind:t[0],port:parseInt(t[1],10),protocol:t[2],fmt:t.slice(3).join(" ")}}</span>,i.parseOLine=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >i.matchPrefix(e,"o=")[0].substr(2).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{username:t[0],sessionId:t[1],sessionVersion:parseInt(t[2],10),netType:t[3],addressType:t[4],address:t[5]}}</span>,i.isValidSDP=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("string"!=typeof e||0===e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=i.splitLines(e),r=0;r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >if(t[r].length&lt;2||"="!==t[r].charAt(1))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,"object"==typeof t&amp;&amp;(t.exports=i)},{}]},{},[1])(1)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(4),s=function(){function <span class="fstat-no" title="function not covered" >e(</span>e,t){<span class="cstat-no" title="statement not covered" >this.audioBufferList=[],this.loop=!1,this.replace=!1,this.effectEndedCallBack=null,this.effectEndedListener=null,this.startTimes=0,this.startOffset=0,this.pauseTimes=0,this.resumeOffset=0,this.isMixAudio=!1,this.isMixingBuffer=!1,this.logger=e,this.ac=t}</span>return e.prototype.preloadEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("amu.pe.0 start preload effect");v</span>ar i=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>i.open("GET",e,!0),i.responseType="arraybuffer",i.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(200==i.status||304==i.status){var e=<span class="cstat-no" title="statement not covered" >i.response;<span class="cstat-no" title="statement not covered" ></span>r.ac.decodeAudioData(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.logger.info("amu.pe.0 effect preload success"),t("",e)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t(e)}</span>))}</span>else{var s=<span class="cstat-no" title="statement not covered" >i.statusText;<span class="cstat-no" title="statement not covered" ></span>t(s)}</span>}</span>,i.send()}</span>,e.prototype.playEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){var o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>!0!==this.isMixAudio?this.audioBuffer?(this.startOffset=e||0,this.loop=t||!1,this.replace=r||!1,this.effectEndedCallBack=s,this.mixEffect(this.audioBuffer,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >o.buffSource.loop=!!t,e?o.buffSource.start(0,e/1e3):o.buffSource.start(0),o.startTimes=Date.now(),o.effectEndedListener=o.effectEndedHandler.bind(o),o.buffSource.addEventListener("ended",o.effectEndedListener),i&amp;&amp;i()}</span>))):this.logger.error("amu.pe.1 no audio buffer found"):this.logger.error("amu.pe.1 audio is mixing")}</span>,e.prototype.mixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>!0!==this.isMixAudio||0!=this.audioBufferList.length||0!=this.isMixingBuffer?this.ac.decodeAudioData(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.audioBufferList.push(e),1==r.audioBufferList.length&amp;&amp;r.playRealTimeEffect(r.audioBufferList[0]),r.isMixingBuffer=!0,t&amp;&amp;t()}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.logger.error("amu.mb.0 "+e),t&amp;&amp;t({code:i.errorList.kDecodeAudioDataFail.code,message:i.errorList.kDecodeAudioDataFail.message+" "+e})}</span>)):this.logger.error("amu.mb.0 audio is mixing")}</span>,e.prototype.stopMingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isMixingBuffer=!1,this.stopMixingAudio()}</span>,e.prototype.playRealTimeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.mixEffect(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.buffSource&amp;&amp;t.buffSource.start(0),t.buffSource&amp;&amp;t.buffSource.addEventListener("ended",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.audioBufferList.shift(),t.audioBufferList.length&gt;0&amp;&amp;t.isMixAudio&amp;&amp;t.playRealTimeEffect(t.audioBufferList[0])}</span>))}</span>))}</span>,e.prototype.pauseEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.audioBufferList.length&gt;0?this.logger.error("amu.pe.0 real time buffer can not be paused"):(this.stopMixingAudio(),this.resumeOffset=(this.pauseTimes-this.startTimes+this.startOffset)%(1e3*this.audioBuffer.duration))}</span>,e.prototype.resumeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.audioBufferList.length&gt;0?this.logger.error("amu.pe.0 real time buffer can not be resume"):(this.playEffect(this.resumeOffset,this.loop,this.replace,void 0,this.effectEndedCallBack),this.startOffset=this.resumeOffset)}</span>,e.prototype.mixEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.localStream?(this.gainNode=this.ac.createGain(),this.buffSource=this.ac.createBufferSource(),this.buffSource.buffer=e,this.buffSource.connect(this.gainNode),this.gainNode.connect(this.ac.destination),this.replaceTrack()&amp;&amp;t()):this.logger.error("amu.me.0 localStream can not be found")}</span>,e.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.replace=t||!1,this.isMixAudio?(this.logger.error("amu.sma.0 audio is mixing"),!1):this.localStream?(e.captureStream=e.captureStream||e.mozCaptureStream||e.webkitCaptureStream,this.gainNode=this.ac.createGain(),this.mixAudio=this.ac.createMediaStreamSource(e.captureStream()),this.mixAudio.connect(this.gainNode),this.replaceTrack()):(this.logger.error("amu.sma.0 localStream can not be found"),!1)}</span>,e.prototype.replaceTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.streamSource=this.ac.createMediaStreamSource(this.localStream),this.destination=this.ac.createMediaStreamDestination(),!this.replace&amp;&amp;this.streamSource.connect(this.destination),this.gainNode.connect(this.destination);v</span>ar e=<span class="cstat-no" title="statement not covered" >this.destination.stream.getAudioTracks()[0],</span>t=<span class="cstat-no" title="statement not covered" >this.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track.kind===e.kind}</span>));<span class="cstat-no" title="statement not covered" ></span>return t?(this.micTrack=this.localStream.getAudioTracks()[0],t.replaceTrack(e),this.localStream.removeTrack(this.micTrack),this.localStream.addTrack(e),this.isMixAudio=!0,!0):(this.logger.error("amu.rt.0 no sender"),!1)}</span>,e.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!this.isMixAudio)<span class="cstat-no" title="statement not covered" >return this.logger.error("amu.sma.1 no mixing audio found"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.localStream)<span class="cstat-no" title="statement not covered" >return this.logger.error("amu.sma.1 localStream can not be found"),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.peerConnection.getSenders().find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track.kind===e.micTrack.kind}</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn this.mixAudio?(this.mixAudio.disconnect(this.gainNode),this.mixAudio=null):this.buffSource&amp;&amp;(this.buffSource.removeEventListener("ended",this.effectEndedListener),this.buffSource.stop(),this.pauseTimes=Date.now(),this.buffSource.disconnect(this.gainNode),this.buffSource=null),this.gainNode.disconnect(this.destination),this.isMixAudio=!1,this.audioBufferList=[],!0}</span>,e.prototype.setMixingAudioVolume=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.gainNode?(this.gainNode.gain.value=e,!0):(this.logger.error("amu.sma.2 no mixing audio found"),!1)}</span>,e.prototype.effectEndedHandler=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.stopMixingAudio(),this.effectEndedCallBack&amp;&amp;this.effectEndedCallBack()}</span>,e}();t.AudioMixUtil=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >this.delayTime=.1,this.fadeTime=.05,this.startTime=.1,this.previousPitch=-1,this.context=e,this.input=e.createGain(),this.output=e.createGain(),this.mod1=e.createBufferSource(),this.mod2=e.createBufferSource(),this.mod3=e.createBufferSource(),this.mod4=e.createBufferSource(),this.shiftDownBuffer=this.createDelayTimeBuffer(e,this.startTime,this.fadeTime,!1),this.shiftUpBuffer=this.createDelayTimeBuffer(e,this.startTime,this.fadeTime,!0),this.mod1.buffer=this.shiftDownBuffer,this.mod2.buffer=this.shiftDownBuffer,this.mod3.buffer=this.shiftUpBuffer,this.mod4.buffer=this.shiftUpBuffer,this.mod1.loop=!0,this.mod2.loop=!0,this.mod3.loop=!0,this.mod4.loop=!0,this.mod1Gain=e.createGain(),this.mod2Gain=e.createGain(),this.mod3Gain=e.createGain(),this.mod4Gain=e.createGain(),this.mod3Gain.gain.value=0,this.mod4Gain.gain.value=0,this.mod1.connect(this.mod1Gain),this.mod2.connect(this.mod2Gain),this.mod3.connect(this.mod3Gain),this.mod4.connect(this.mod4Gain),this.modGain1=e.createGain(),this.modGain2=e.createGain(),this.delay1=e.createDelay(),this.delay2=e.createDelay(),this.mod1Gain.connect(this.modGain1),this.mod2Gain.connect(this.modGain2),this.mod3Gain.connect(this.modGain1),this.mod4Gain.connect(this.modGain2),this.modGain1.connect(this.delay1.delayTime),this.modGain2.connect(this.delay2.delayTime),this.fade1=e.createBufferSource(),this.fade2=e.createBufferSource(),this.fadeBuffer=this.createFadeBuffer(e,this.startTime,this.fadeTime),this.fade1.buffer=this.fadeBuffer,this.fade2.buffer=this.fadeBuffer,this.fade1.loop=!0,this.fade2.loop=!0,this.mix1=e.createGain(),this.mix2=e.createGain(),this.mix1.gain.value=0,this.mix2.gain.value=0,this.fade1.connect(this.mix1.gain),this.fade2.connect(this.mix2.gain),this.input.connect(this.delay1),this.input.connect(this.delay2),this.delay1.connect(this.mix1),this.delay2.connect(this.mix2),this.mix1.connect(this.output),this.mix2.connect(this.output);v</span>ar t=<span class="cstat-no" title="statement not covered" >e.currentTime+.05,</span>r=<span class="cstat-no" title="statement not covered" >t+this.startTime-this.fadeTime;<span class="cstat-no" title="statement not covered" ></span>this.mod1.start(t),this.mod2.start(r),this.mod3.start(t),this.mod4.start(r),this.fade1.start(t),this.fade2.start(r),this.setDelay(this.delayTime)}</span>return e.prototype.createFadeBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >for(var i=t*e.sampleRate,s=i+(t-2*r)*e.sampleRate,o=e.createBuffer(1,s,e.sampleRate),n=o.getChannelData(0),a=r*e.sampleRate,c=i-a,d=0;d&lt;i;++d)<span class="cstat-no" title="statement not covered" >n[d]=d&lt;a?Math.sqrt(d/a):d&gt;=c?Math.sqrt(1-(d-c)/a):1;<span class="cstat-no" title="statement not covered" >f</span></span>or(d=i;d&lt;length;++d)<span class="cstat-no" title="statement not covered" >n[d]=0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>,e.prototype.createDelayTimeBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >for(var s=t*e.sampleRate,o=s+(t-2*r)*e.sampleRate,n=e.createBuffer(1,o,e.sampleRate),a=n.getChannelData(0),c=0;c&lt;s;++c)<span class="cstat-no" title="statement not covered" >a[c]=i?(s-c)/o:c/s;<span class="cstat-no" title="statement not covered" >f</span></span>or(c=s;c&lt;o;++c)<span class="cstat-no" title="statement not covered" >a[c]=0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,e.prototype.setDelay=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.modGain1.gain.setTargetAtTime(.5*e,0,.01),this.modGain2.gain.setTargetAtTime(.5*e,0,.01)}</span>,e.prototype.setPitchOffset=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e&gt;0?(this.mod1Gain.gain.value=0,this.mod2Gain.gain.value=0,this.mod3Gain.gain.value=1,this.mod4Gain.gain.value=1):(this.mod1Gain.gain.value=1,this.mod2Gain.gain.value=1,this.mod3Gain.gain.value=0,this.mod4Gain.gain.value=0),this.setDelay(this.delayTime*Math.abs(e)),this.previousPitch=e}</span>,e}();t.PitchUtil=i},function(e,t,r){"use strict";var i=this&amp;&amp;this.__assign||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(i=Object.assign||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t,r=1,i=arguments.length;r&lt;i;r++)<span class="cstat-no" title="statement not covered" >for(var s in t=arguments[r])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,s)&amp;&amp;(e[s]=t[s]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>).apply(this,arguments)}</span>;Object.defineProperty(t,"__esModule",{value:!0});var s=r(0),o=r(2),n=function(){function <span class="fstat-no" title="function not covered" >e(</span>e,t){<span class="cstat-no" title="statement not covered" >this.sendDataMap={},this.sendDataList=new s.LinkedList,this.sendDataCheckOnceCount=100,this.signalSeq=0,this.pushCallback={},this.sessionInfos={},this.tryHeartbeatCount=0,this.heartbeatInterval=1e4,this.sendDataTimeout=5e3,this.sendDataDropTimeout=1e4,this.tryConnectCount=1,this.tryConnectTimer=null,this.tryConnectInterval=3e3,this.state=s.ENUM_CONNECT_STATE.disconnect,this.tokenType=0,this.browser=this.getBrowserAndVersion(),this.platform=navigator.platform,this.negoInterval=25e3,this.negoTryCount=1,this.negoTryMaxCount=2,this.logger=e,this.stateCenter=t}</span>return e.prototype.getBrowserAndVersion=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t=<span class="cstat-no" title="statement not covered" >navigator.userAgent,</span>r=<span class="cstat-no" title="statement not covered" >t.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i)||[];<span class="cstat-no" title="statement not covered" ></span>return/trident/i.test(r[1])?{name:"IE",version:(e=/\brv[ :]+([\d\.]+)/g.exec(t)||[])[1]||""}:"Chrome"===r[1]&amp;&amp;null!=(e=t.match(/\bOPR|Edge\/([\d\.]+)/))?{name:"Opera",version:e[1]}:(r=r[2]?[r[1],r[2]]:[navigator.appName,navigator.appVersion,"-?"],null!=(e=t.match(/version\/([\d+\.]+)/i))&amp;&amp;r.splice(1,1,e[1]),{name:r[0],version:r[1]})}</span>,e.prototype.setSessionInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.ssi.0 call"),this.appid=e+"",this.userid=t}</span>,e.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.onUpdateHeartBeartInterval=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.resetConnectTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zs.rct.0 call"),clearTimeout(this.tryConnectTimer),this.tryConnectTimer=null,this.tryConnectCount=0}</span>,e.prototype.bindWebSocketHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.tryHeartbeatCount=0,this.websocket.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >JSON.parse(t.data);<span class="cstat-no" title="statement not covered" ></span>e.logger.info("zs.bsh.0 signmsg= ",r.header.cmd),e.logger.info("zs.bsh.0 signmsg= "+JSON.stringify(r)),r.header.appid==e.appid&amp;&amp;r.header.user_id===e.userid?e.handleServerPush(r):e.logger.warn("zs.bsh.0 check header failed")}</span>,this.websocket.onclose=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.info("zs.bsh.0 close msg = "+JSON.stringify(t)),e.state!=s.ENUM_CONNECT_STATE.disconnect&amp;&amp;(e.resetConnectTimer(),e.startConnectTimer(),e.resetCheckMessage())}</span>,this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.error("zs.bsh.0 msg = "+JSON.stringify(t))}</span>}</span>,e.prototype.resetCheckMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.rcm.0 call");<span class="cstat-no" title="statement not covered" >f</span>or(var e=this.sendDataList.getFirst();null!=e;)<span class="cstat-no" title="statement not covered" >this.sendDataList.remove(e),e._data.error&amp;&amp;e._data.error(s.SEND_MSG_RESET,e._data.seq),e=this.sendDataList.getFirst();<span class="cstat-no" title="statement not covered" >t</span></span>his.sendDataMap={}}</span>,e.prototype.handleServerPush=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >switch(e.header.cmd){case"LoginRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("LoginReq",e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CreateSessionRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("CreateSessionReq",e),0===e.body.result&amp;&amp;this.addSession(e.header.session_id,e.body.session_token);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"MediaDescRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("MediaDescReq",e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CandidateInfoRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("CandidateInfoReq",e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CloseSessionRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("CloseSessionReq",e),this.removeSession(e.header.session_id);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ClientHBRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("ClientHBReq",e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"MediaDescPush":case"CandidateInfoPush":<span class="cstat-no" title="statement not covered" >this.handlePushData(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CloseSessionPush":<span class="cstat-no" title="statement not covered" >this.handlePushData(e),this.removeSession(e.header.session_id);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"QualityReportRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("QualityReportReq",e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SessionResetPush":<span class="cstat-no" title="statement not covered" >this.handlePushResetSessionData(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"StreamStatusNotifyPush":case"PublishEventPush":case"PlayEventPush":<span class="cstat-no" title="statement not covered" >this.handlePushData(e)}</span>}</span>,e.prototype.disconnectCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.connectCallback&amp;&amp;(this.connectCallback(-1,this.server,void 0),this.connectCallback=null);v</span>ar e=<span class="cstat-no" title="statement not covered" >this.server;<span class="cstat-no" title="statement not covered" ></span>this.disconnectServer(),this.onDisconnect(e)}</span>,e.prototype.updateToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zs.ut.0 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >{token:this.token,tokenType:this.tokenType,roomid:this.stateCenter.roomid,anchorname:this.stateCenter.anchor_info.anchor_id,sdkversion:s.PROTO_VERSION,osinfo:navigator.appVersion};<span class="cstat-no" title="statement not covered" ></span>if(0!=Object.keys(this.sessionInfos).length){var r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var i in this.sessionInfos){var n=<span class="cstat-no" title="statement not covered" >parseInt(i);<span class="cstat-no" title="statement not covered" ></span>r.push({session_id:n,session_token:this.sessionInfos[n].token})}<span class="cstat-no" title="statement not covered" ></span>t</span>.sessions=r}<span class="cstat-no" title="statement not covered" ></span>t</span>his.sendMessageWithCallback("LoginReq",o.getSeq(),0,t,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){<span class="cstat-no" title="statement not covered" >if(0==i.result){<span class="cstat-no" title="statement not covered" >e.token=i.token,e.tokenType=i.tokenType;v</span>ar s=<span class="cstat-no" title="statement not covered" >{report:i.report,report_interval:i.report_interval_ms};<span class="cstat-no" title="statement not covered" ></span>i.negoInterval&amp;&amp;(e.negoInterval=i.negoInterval),i.negoTryCount&amp;&amp;(e.negoTryCount=i.negoTryCount),i.negoTryMaxCount&amp;&amp;(e.negoTryMaxCount=i.negoTryMaxCount),null!=e.connectCallback&amp;&amp;(e.connectCallback(0,e.server,s),e.connectCallback=null)}</span>else{var o=<span class="cstat-no" title="statement not covered" >{error:i.strError};<span class="cstat-no" title="statement not covered" ></span>null!=e.connectCallback&amp;&amp;(e.connectCallback(i.result,e.server,o),e.connectCallback=null)}</span>}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=e.connectCallback&amp;&amp;(e.connectCallback(-1,e.server,void 0),e.connectCallback=null)}</span>))}</span>,e.prototype.sendMessageWithCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,o,n){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zs.smwc.0 call "+e),!this.websocket||1!==this.websocket.readyState)<span class="cstat-no" title="statement not covered" >return this.logger.error("zs.smwc.0 connect not establish"),void(n&amp;&amp;n(s.SEND_MSG_TIMEOUT,t));v</span></span>ar a=<span class="cstat-no" title="statement not covered" >{header:this.getHeader(e,t,r),body:i};<span class="cstat-no" title="statement not covered" ></span>null==o&amp;&amp;(o=null),null==n&amp;&amp;(n=null);v</span>ar c=<span class="cstat-no" title="statement not covered" >{seq:t,deleted:!1,cmd:e,time:Date.parse(new Date+""),success:o,error:n},</span>d=<span class="cstat-no" title="statement not covered" >this.sendDataList.push(c);<span class="cstat-no" title="statement not covered" ></span>this.sendDataMap[c.seq]=d;v</span>ar l=<span class="cstat-no" title="statement not covered" >JSON.stringify(a);<span class="cstat-no" title="statement not covered" ></span>this.websocket.send(l),this.logger.debug("zs.smwc.0 success")}</span>,e.prototype.getHeader=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return this.globalHeader={version:"1.0.1",cmd:e,appid:this.appid+"",seq:t,user_id:this.userid,session_id:r},this.globalHeader}</span>,e.prototype.connectServer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.token=e,this.server=t,this.state=s.ENUM_CONNECT_STATE.connecting,this.connectCallback=r,this.websocket&amp;&amp;1===this.websocket.readyState)<span class="cstat-no" title="statement not covered" >this.resetConnectTimer(),this.state=s.ENUM_CONNECT_STATE.connected;e</span>lse{<span class="cstat-no" title="statement not covered" >this.logger.info("zs.cs.0 need new websocket");<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.websocket&amp;&amp;(this.logger.warn("zs.cs.0 close error websocket"),this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null),this.websocket=new WebSocket(this.server),this.websocket.onopen=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.resetConnectTimer(),i.logger.info("zs.cs.0 websocket open call"),i.bindWebSocketHandle(),i.updateToken(),i.state=s.ENUM_CONNECT_STATE.connected}</span>,this.websocket.onclose=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.logger.info("zs.cs.0 websocket close call  "+JSON.stringify(e))}</span>,this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.logger.info("zs.cs.0 websocket onerror call  "+JSON.stringify(e))}</span>}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.logger.error("zs.cs.0 websocket error "+e)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.tryConnectTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.startConnectTimer(r)}</span>),this.tryConnectInterval)}</span>,e.prototype.startConnectTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zs.sct.0 call"),this.tryConnectCount&gt;=s.MAX_TRY_CONNECT_COUNT)<span class="cstat-no" title="statement not covered" >return this.logger.info("zs.sct.0 beyond "+this.server+"max limit"),void this.disconnectCallback();<span class="cstat-no" title="statement not covered" >t</span></span>his.websocket&amp;&amp;1===this.websocket.readyState?this.resetConnectTimer():(this.tryConnectCount+=1,this.connectServer(this.token,this.server,e))}</span>,e.prototype.disconnectServer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.ds.0 call"),this.connectCallback=null,this.resetCheckMessage(),this.resetConnectTimer(),this.websocket&amp;&amp;(this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null),this.token="",this.sessionInfos={},this.tokenType=0,this.tryHeartbeatCount=0,this.tryConnectCount=0,this.state=s.ENUM_CONNECT_STATE.disconnect}</span>,e.prototype.isServerConnected=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!(!this.websocket||1!==this.websocket.readyState)}</span>,e.prototype.createSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,o,n,a){<span class="cstat-no" title="statement not covered" >void 0===o&amp;&amp;(o=""),this.logger.debug("zs.cs.1 call: ",i);v</span>ar c=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>s.PROTO_VERSION.split(".").forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return 1==e.length&amp;&amp;1==t?c+="0"+e:c+=e}</span>));v</span>ar d=<span class="cstat-no" title="statement not covered" >{type:t,stream_id:i,platform:this.platform,browser:this.browser.name,version:this.browser.version,app_id:this.appid,negotiate_mode:r,strAuthParam:o,sdk_version:1*c};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("CreateSessionReq",e,0,d,n,a)}</span>,e.prototype.removeSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zs.rs.0 call"),this.sessionInfos[e]&amp;&amp;delete this.sessionInfos[e]}</span>,e.prototype.sendCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.scs.0 call: ",t);v</span>ar o=<span class="cstat-no" title="statement not covered" >{reason:r};<span class="cstat-no" title="statement not covered" ></span>this.removeSession(t),this.sendMessageWithCallback("CloseSessionReq",e,t,o,i,s)}</span>,e.prototype.sendMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zs.sm.0 call "+e),this.websocket&amp;&amp;1===this.websocket.readyState){var s=<span class="cstat-no" title="statement not covered" >{header:this.getHeader(e,t,r),body:i},</span>o=<span class="cstat-no" title="statement not covered" >JSON.stringify(s);<span class="cstat-no" title="statement not covered" ></span>this.websocket.send(o),this.logger.debug("zs.sm.0 success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zs.sm.0 connect not establish")}</span></span>,e.prototype.handleRespondData=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.hrd.0 call");v</span>ar r=<span class="cstat-no" title="statement not covered" >this.sendDataMap[t.header.seq];<span class="cstat-no" title="statement not covered" ></span>if(null!=r){var i=<span class="cstat-no" title="statement not covered" >r._data;<span class="cstat-no" title="statement not covered" ></span>i.cmd!==e?this.logger.error("sz.hrd.0 command is not match"):i.success&amp;&amp;i.success(t.header.seq,t.header.session_id,t.body),delete this.sendDataMap[t.header.seq],this.sendDataList.remove(r)}</span>else{<span class="cstat-no" title="statement not covered" >if("CloseSessionRsp"==t.header.cmd)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.error("zs.hrd.0 cannot find data "+e)}</span>}</span>,e.prototype.addSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.logger.info("zs.as.0 call"),this.sessionInfos[e]={token:t}}</span>,e.prototype.handlePushData=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.hpd.0 call "+e.header.cmd+" session "+e.header.session_id);v</span>ar t=<span class="cstat-no" title="statement not covered" >this.pushCallback[e.header.cmd+e.header.session_id];<span class="cstat-no" title="statement not covered" ></span>t?t.callback&amp;&amp;t.callback(e.header.seq,e.header.session_id,e.body):this.logger.info("zs.hpd.0 no callbackData "+e.header.cmd+" session: "+e.header.session_id)}</span>,e.prototype.handlePushResetSessionData=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.hprsd.0 call ");v</span>ar t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(0==e.body.cResetType)<span class="cstat-no" title="statement not covered" >t=Object.keys(this.sessionInfos);e</span>lse <span class="cstat-no" title="statement not covered" >if(1==e.body.cResetType)<span class="cstat-no" title="statement not covered" >for(var r=0;r&lt;e.body.session_ids.length;r++)<span class="cstat-no" title="statement not covered" >t.push(e.body.session_ids[r]);<span class="cstat-no" title="statement not covered" >i</span></span></span></span>f(this.sendResetSessionAck(e.header.seq,0,0),0!=t.length)<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;t.length;i++){var s=<span class="cstat-no" title="statement not covered" >this.pushCallback[e.header.cmd+t[i]];<span class="cstat-no" title="statement not covered" ></span>null==s?this.logger.info("zs.hprsd.0 no callbackData "+t[i]):s.callback&amp;&amp;s.callback(e.header.seq,t[i],e.body)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >this.logger.info("zs.hprsd.0 no session to callback")}</span></span>,e.prototype.sendMediaDesc=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s,o){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.smd.0 call: ",t);v</span>ar n=<span class="cstat-no" title="statement not covered" >{type:r,sdp:i.sdp};<span class="cstat-no" title="statement not covered" ></span>null!=i.width&amp;&amp;(n.width=i.width),null!=i.height&amp;&amp;(n.height=i.height),null!=i.frameRate&amp;&amp;(n.framerate=i.frameRate),null!=i.video_min_kpbs&amp;&amp;(n.video_min_kpbs=i.video_min_kpbs),null!=i.video_max_kpbs&amp;&amp;(n.video_max_kpbs=i.video_max_kpbs),null!=i.audio_kpbs&amp;&amp;(n.audio_kpbs=i.audio_kpbs),null!=i.keyframe_intv&amp;&amp;(n.keyframe_intv=i.keyframe_intv),this.sendMessageWithCallback("MediaDescReq",e,t,n,s,o)}</span>,e.prototype.sendCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.sci.0 call: ",t);<span class="cstat-no" title="statement not covered" >f</span>or(var o=[],n=0;n&lt;r.length;n++){var a=<span class="cstat-no" title="statement not covered" >{candidate:r[n].candidate,sdpMid:r[n].sdpMid,sdpMLineIndex:r[n].sdpMLineIndex};<span class="cstat-no" title="statement not covered" ></span>o.push(a)}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >{infos:o};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("CandidateInfoReq",e,t,c,i,s)}</span>,e.prototype.sendMediaDescAck=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.smda.0 call: ",t);v</span>ar i=<span class="cstat-no" title="statement not covered" >{result:r};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("MediaDescAck",e,t,i)}</span>,e.prototype.sendCandidateInfoAck=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.scia.0 call: ",t);v</span>ar i=<span class="cstat-no" title="statement not covered" >{result:r};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("CandidateInfoAck",e,t,i)}</span>,e.prototype.sendCloseSessionAck=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.scsa.0 call: ",t);v</span>ar i=<span class="cstat-no" title="statement not covered" >{result:r};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("CloseSessionAck",e,t,i)}</span>,e.prototype.sendResetSessionAck=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.ssra.0 call: ",t);v</span>ar i=<span class="cstat-no" title="statement not covered" >{result:r};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("SessionResetAck",e,t,i)}</span>,e.prototype.registerPushCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >r&amp;&amp;"function"==typeof r&amp;&amp;(this.logger.debug("zs.rpc.0 setcallback"),this.pushCallback[e+t]={callback:r})}</span>,e.prototype.unregisterPushCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >delete this.pushCallback[e+t]}</span>,e.prototype.checkMessageTimeout=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=this.sendDataList.getFirst(),t=Date.parse(new Date+""),r=0,i=0,o=0;!(null==e||e._data.time+this.sendDataTimeout&gt;t||(delete this.sendDataMap[e._data.seq],this.sendDataList.remove(e),++i,null==e._data.error||this.sendDataDropTimeout&gt;0&amp;&amp;e._data.time+this.sendDataDropTimeout&lt;t?++o:e._data.error&amp;&amp;e._data.error(s.SEND_MSG_TIMEOUT,e._data.seq),++r&gt;=this.sendDataCheckOnceCount));)<span class="cstat-no" title="statement not covered" >e=this.sendDataList.getFirst();<span class="cstat-no" title="statement not covered" >0</span></span>==i&amp;&amp;0==o||this.logger.debug("zs.cmt.0 call success, state: timeout=",i," drop=",o)}</span>,e.prototype.sendHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zs.shb.0 call tryHeartbeatCount:"+this.tryHeartbeatCount),0!=Object.keys(this.sessionInfos).length){<span class="cstat-no" title="statement not covered" >if(++this.tryHeartbeatCount&gt;s.MAX_TRY_HEARTBEAT_COUNT)<span class="cstat-no" title="statement not covered" >return this.logger.error("zs.shb.0 heartbeat try limit"),void this.disconnectCallback();v</span></span>ar t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var r in this.sessionInfos)<span class="cstat-no" title="statement not covered" >t.push(parseInt(r));v</span></span>ar i=<span class="cstat-no" title="statement not covered" >{session_ids:t};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("ClientHBReq",o.getSeq(),0,i,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){<span class="cstat-no" title="statement not covered" >e.heartbeatInterval!=i.hb_interval&amp;&amp;(e.heartbeatInterval=i.hb_interval,e.onUpdateHeartBeartInterval(i.hb_interval)),e.tryHeartbeatCount=0}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){}))}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zs.shb.0 no need to heartbeat")}</span></span>,e.prototype.QualityReport=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s,o){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.qr.0 call");v</span>ar n=<span class="cstat-no" title="statement not covered" >{streams:[i(i({},r),{aid:t})]};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("QualityReportReq",e,t,n,s,o)}</span>,e.prototype.sendStreamStatus=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.sss.0 call");v</span>ar s=<span class="cstat-no" title="statement not covered" >{mic_status:i,camera_status:r};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zs.sss.0 stream status "+JSON.stringify(s)),this.sendMessage("StreamStatusNotify",e,t,s)}</span>,e.prototype.sendBroadcasterStatus=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.sss.0 call");v</span>ar i=<span class="cstat-no" title="statement not covered" >{status:r};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("BroadcasterStatusNotify",e,t,i)}</span>,e}();t.ZegoSignal=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(2),o=r(1),n=r(5),a=r(4),c=function(){function <span class="fstat-no" title="function not covered" >e(</span>e,t,r,o,n,a){<span class="cstat-no" title="statement not covered" >this.state=i.ENUM_PLAY_STATE.stop,this.candidateInfo=[],this.waitICETimer=null,this.waitingICETimeInterval=5e3,this.waitingOfferTimer=null,this.waitingOfferTimeInterval=5e3,this.waitingServerTimer=null,this.waitingServerTimerInterval=3e3,this.qualityTimer=null,this.broadcasterStatus=i.ENUM_BROADCASTER_STATUS.stop,this.playQualityList=[],this.maxQualityListCount=10,this.lastPlayStats={audioPacketsLost:0,videoPacketsLost:0,time:0,audioTime:0,videoTime:0,audioBytesReceived:0,videoBytesReceived:0,framesDecoded:0,framesReceived:0,framesDropped:0,audioBitrate:0},this.reportSeq=s.getSeq(),this.retrySeq=0,this.videoSizeCallback=!1,this.qualityUpload=!1,this.qualityUploadInterval=3e4,this.qualityUploadLastTime=0,this.maxRetryCount=3,this.currentRetryCount=0,this.retryState=i.ENUM_RETRY_STATE.didNotStart,this.remoteStream=null,this.playStream=null,this.playOption={},this.closeSessionSignal=!1,this.stateNego=i.ENUM_PLAY_STATE_NEGO.stop,this.negoTimer=null,this.negoInterval=25e3,this.negoTryCount=1,this.negoTryMaxCount=2,this.playEvent=!1,this.nextSignalTryCount=1,this.waittingConnectedTimer=null,this.waittingConnectedInerval=15e3,this.tryingNexitSignal=!1,this.gotStreamStatus=!1,this.soundLevel=0,this.mic=null,this.script=null,this.logger=e,this.signal=t,this.dataReport=r,this.qualityTimeInterval=o,this.streamCenter=n,this.ac=a}</span>return e.prototype.startPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sp.1 called ",e),this.playEvent=!1,this.signal&amp;&amp;this.signal.negoInterval&amp;&amp;(this.negoInterval=this.signal.negoInterval),this.signal&amp;&amp;this.signal.negoTryCount&amp;&amp;(this.negoTryCount=this.signal.negoTryCount),this.signal&amp;&amp;this.signal.negoTryMaxCount&amp;&amp;(this.negoTryMaxCount=this.signal.negoTryMaxCount),e?(this.streamId=e,this.getRomoteStreamSuc=t,this.playOption=r||{},r&amp;&amp;r.videoCodec&amp;&amp;(this.playOption.videoCodec=r.videoCodec),this.sessionSeq=s.getSeq(),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"CreateSession"),this.signal.createSession(this.sessionSeq,1,0,e,r&amp;&amp;r.streamParams,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >n.dataReport.eventEndWithMsg(0==n.retrySeq?n.reportSeq:n.retrySeq,"CreateSession",{sessionId:r.session_id}),n.logger.info("zp.sp.1 sessionId:"+r.session_id),n.sessionSeq==e?0!==r.result?(n.logger.error("zp.sp.1 create error"),n.playStateUpdateError(o.playErrorList.CREATE_SESSION_ERROR)):(n.sessionId=r.session_id,n.onCreatePlaySessionSuccess(r)):n.logger.error("zp.sp.1 seq is not match.")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >n.dataReport.eventEndWithMsg(0==n.retrySeq?n.reportSeq:n.retrySeq,"CreateSession",{error:e}),n.playStateUpdateError(o.playErrorList.SEND_SESSION_TIMEOUT)}</span>)),this.state=i.ENUM_PLAY_STATE.waitingSessionRsp,this.logger.debug("zp.sp.1 called success"),this.stateNego=i.ENUM_PLAY_STATE_NEGO.start,this.negoTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.stateNego!==i.ENUM_PLAY_STATE_NEGO.iceConnected&amp;&amp;n.negoTryCount&lt;n.negoTryMaxCount?(n.signal.sendCloseSession(s.getSeq(),n.sessionId,1),n.resetPlay(),n.startPlay(e,t,r),++n.negoTryCount):n.stateNego!==i.ENUM_PLAY_STATE_NEGO.iceConnected&amp;&amp;n.negoTryCount===n.negoTryMaxCount&amp;&amp;(n.logger.error("zp.sp.1 waiting timeout"),n.playStateUpdateError(o.playErrorList.SERVER_NEGO_TIMEOUT))}</span>),this.negoInterval)):this.logger.warn("zp.sp.1 streamId is null")}</span>,e.prototype.onCreatePlaySessionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.1 success");v</span>ar r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e.turn_server&amp;&amp;r.push(e.turn_server),e.stun_server&amp;&amp;r.push(e.stun_server);v</span>ar i=<span class="cstat-no" title="statement not covered" >{iceTransportPolicy:"relay",iceServers:[{urls:r,username:e.turn_username,credential:e.turn_auth_key}]};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.1 username: "+e.turn_username),this.logger.info("zp.ops.1 credential: "+e.turn_auth_key),this.peerConnection=new RTCPeerConnection(i),this.peerConnection.onicecandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.onIceCandidate(e)}</span>,this.peerConnection.onsignalingstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.onConnectionStateChange(e)}</span>,this.peerConnection.oniceconnectionstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.onIceConnectionStateChange(e)}</span>,this.peerConnection.ontrack=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.onGotRemoteStream(e.streams[0])}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >{offerToReceiveAudio:1,offerToReceiveVideo:1};<span class="cstat-no" title="statement not covered" ></span>this.playOption&amp;&amp;!1===this.playOption.video&amp;&amp;(s.offerToReceiveVideo=0),this.playOption&amp;&amp;!1===this.playOption.audio&amp;&amp;(s.offerToReceiveAudio=0),this.logger.info("zp.ops.1 createOffer: "+JSON.stringify(s)),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"CreateOffer"),this.peerConnection.createOffer(s).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"CreateOffer"),t.onCreateOfferSuccess(e)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"CreateOffer",{error:e.toString()}),t.logger.error("zp.ops.0 create offer error "+e.toString()),t.playStateUpdateError(o.playErrorList.CREATE_OFFER_ERROR,!0)}</span>)),this.signal.registerPushCallback("MediaDescPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvMediaDesc(e,r,i)}</span>)),this.signal.registerPushCallback("CandidateInfoPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvCandidateInfo(e,r,i)}</span>)),this.signal.registerPushCallback("CloseSessionPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvCloseSession(e,r,i)}</span>)),this.signal.registerPushCallback("SessionResetPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvResetSession(e,r,i)}</span>)),this.signal.registerPushCallback("StreamStatusNotifyPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.gotStreamStatus=!0,t.streamStatus=i,t.playStream&amp;&amp;t.onRecvStreamStatus(i)}</span>)),this.signal.registerPushCallback("PlayEventPush",this.sessionId,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.onRecvPlayEvent(e,r,i)}</span>)),this.logger.debug("zp.ops.1 call success")}</span>,e.prototype.onCreateOfferSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.oco.1 localSdp1 "+e.sdp.substr(0,e.sdp.length/2)),this.logger.info("zp.oco.1 localSdp2 "+e.sdp.substr(e.sdp.length/2)),e.sdp=e.sdp.replace(/sendrecv/g,"recvonly"),this.playOption.videoCodec&amp;&amp;(e.sdp=n.SdpUtil.getSDPByVideDecodeType(e.sdp,this.playOption.videoCodec)),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SetLocalDescription"),this.peerConnection.setLocalDescription(e).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"SetLocalDescription"),t.onSetLocalDescriptionSuccess(e)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.logger.error("zp.oca.1 set error "+e.toString()),t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"SetLocalDescription",{error:e.toString()}),t.playStateUpdateError(o.playErrorList.SET_LOCAL_DESC_ERROR,!0)}</span>))}</span>,e.prototype.onSetLocalDescriptionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.osd.1 success");v</span>ar r=<span class="cstat-no" title="statement not covered" >{sdp:e.sdp};<span class="cstat-no" title="statement not covered" ></span>this.answerSeq=s.getSeq(),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SendMediaDesc"),this.signal.sendMediaDesc(this.answerSeq,this.sessionId,0,r,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,s){<span class="cstat-no" title="statement not covered" >t.logger.info("zp.osd.1 sendMediaDesc resp"),t.answerSeq==e&amp;&amp;t.sessionId==r?(t.logger.info("zp.osd.1 send success stateNego:waiterAnswer"),t.stateNego=i.ENUM_PLAY_STATE_NEGO.waiterAnswer,t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendMediaDesc"),t.waitingOfferTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.state==i.ENUM_PLAY_STATE.waitingOffserRsp&amp;&amp;(t.logger.error("zp.osd.1 waiting timeout"),t.playStateUpdateError(o.playErrorList.SERVER_CANDIDATE_TIMEOUT))}</span>),t.waitingOfferTimeInterval),t.state=i.ENUM_PLAY_STATE.waitingServerAnswer):t.logger.error("zp.osd.1 seq or sessionId is not equal "+t.answerSeq+" "+e,0+t.sessionId+" "+r)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.logger.error("zp.osd.1 failed to send "+e),t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendMediaDesc",{error:e}),t.playStateUpdateError(o.playErrorList.SEND_MEDIA_DESC_TIMEOUT)}</span>)),this.state=i.ENUM_PLAY_STATE.waitingOffserRsp}</span>,e.prototype.onRecvMediaDesc=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.orm.1 received ",r),this.stateNego=i.ENUM_PLAY_STATE_NEGO.waitingCandidate,this.logger.info("zp.orm.1 received stateNego:waitingCandidate"),this.state===i.ENUM_PLAY_STATE.waitingServerAnswer){<span class="cstat-no" title="statement not covered" >null!=this.waitingOfferTimer&amp;&amp;(clearTimeout(this.waitingOfferTimer),this.waitingOfferTimer=null),this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"RecvMediaDesc"),this.signal.sendMediaDescAck(e,this.sessionId,0);v</span>ar n=<span class="cstat-no" title="statement not covered" >{type:"answer",sdp:r.sdp,toJSON:<span class="fstat-no" title="function not covered" >fu</span>nction(){}};<span class="cstat-no" title="statement not covered" ></span>this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SetRemoteDescription"),this.logger.info("zp.orm.1 remoteSdp ",n.sdp),this.peerConnection.setRemoteDescription(new RTCSessionDescription(n)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >s.dataReport.eventEnd(0==s.retrySeq?s.reportSeq:s.retrySeq,"SetRemoteDescription"),s.logger.info("zp.orm.1 set success")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.logger.error("zp.orm.1 set remote error "+e.toString()),s.dataReport.eventEndWithMsg(0==s.retrySeq?s.reportSeq:s.retrySeq,"SetRemoteDescription",{error:e.toString()}),s.playStateUpdateError(o.playErrorList.SET_REMOTE_DESC_ERROR)}</span>)),this.waitICETimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >s.state==i.ENUM_PLAY_STATE.waitingServerICE&amp;&amp;(s.logger.error("zp.orm.1 waiting server timeout"),s.playStateUpdateError(o.playErrorList.SERVER_CANDIDATE_TIMEOUT))}</span>),this.waitingICETimeInterval),this.state=i.ENUM_PLAY_STATE.waitingServerICE,this.logger.debug("zp.orm.1 call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zp.orm.1 current state "+this.state+" not allowed")}</span></span>,e.prototype.onRecvCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.orci.1 received "),this.state==i.ENUM_PLAY_STATE.waitingServerICE){<span class="cstat-no" title="statement not covered" >null!=this.waitICETimer&amp;&amp;(clearTimeout(this.waitICETimer),this.waitICETimer=null),this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"RecvIceCandidate"),this.signal.sendCandidateInfoAck(e,this.sessionId,0),this.sendCandidateInfo(this.candidateInfo),this.candidateInfo=[];<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;r.infos.length;n++){var a=<span class="cstat-no" title="statement not covered" >{sdpMid:r.infos[n].sdpMid,sdpMLineIndex:r.infos[n].sdpMLineIndex,candidate:r.infos[n].candidate};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zp.orci.1 candidate "+a.candidate),this.peerConnection.addIceCandidate(new RTCIceCandidate(a)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >s.logger.debug("zp.orci.1 add success")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.logger.error("zp.orci.1 add error "+e.toString()),s.playStateUpdateError(o.playErrorList.SERVER_CANDIDATE_ERROR)}</span>))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.state=i.ENUM_PLAY_STATE.connecting,this.logger.debug("zp.orci.1 call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zp.orci.1 current state "+this.state+" not allowed")}</span></span>,e.prototype.onRecvPlayEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.orpe.1 received"),!0===this.playEvent&amp;&amp;0==r.event){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orpe.1 retry: "+this.streamId);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.streamId,</span>o=<span class="cstat-no" title="statement not covered" >this.playOption;<span class="cstat-no" title="statement not covered" ></span>this.signal.sendCloseSession(s.getSeq(),this.sessionId,1),this.resetPlay(),this.startPlay(i,this.getRomoteStreamSuc,o)}</span>else <span class="cstat-no" title="statement not covered" >this.playEvent=!0}</span></span>,e.prototype.onIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oic.1 called"),null!=e.candidate)<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zp.oic.1 candidate "+e.candidate.candidate),this.state&lt;i.ENUM_PLAY_STATE.connecting||this.state==i.ENUM_PLAY_STATE.stop)<span class="cstat-no" title="statement not covered" >this.logger.debug("zp.oic.1 cached"),this.candidateInfo.push({candidate:e.candidate.candidate,sdpMid:e.candidate.sdpMid,sdpMLineIndex:e.candidate.sdpMLineIndex});e</span>lse{<span class="cstat-no" title="statement not covered" >this.logger.debug("zp.oic.1 send");v</span>ar t=<span class="cstat-no" title="statement not covered" >{candidate:e.candidate.candidate,sdpMid:e.candidate.sdpMid,sdpMLineIndex:e.candidate.sdpMLineIndex};<span class="cstat-no" title="statement not covered" ></span>this.sendCandidateInfo([t])}</span>}</span></span>,e.prototype.onConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.oisc.1 called "+e.target.signalingState)}</span>,e.prototype.onIceConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.state!=i.ENUM_PLAY_STATE.stop&amp;&amp;null!=this.peerConnection)<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oisc.1  stateChanged "+this.peerConnection.iceConnectionState),"connected"===this.peerConnection.iceConnectionState){<span class="cstat-no" title="statement not covered" >for(var r in this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceConnected"),this.state!=i.ENUM_PLAY_STATE.playing&amp;&amp;this.onPlayStateUpdate(s.ENUM_PLAY_STATE_UPDATE.start,this.streamId,{code:0,msg:""}),this.state=i.ENUM_PLAY_STATE.playing,this.tryingNexitSignal=!1,this.retrySeq=0,this.retryState!=i.ENUM_RETRY_STATE.didNotStart&amp;&amp;(this.retryState=i.ENUM_RETRY_STATE.finished,this.currentRetryCount=0),this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"PlayState"),this.streamCenter.publisherList){<span class="cstat-no" title="statement not covered" >if(this.streamCenter.publisherList[r].publisher.state==i.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.broadcasterStatus==i.ENUM_BROADCASTER_STATUS.stop){<span class="cstat-no" title="statement not covered" >this.signal&amp;&amp;this.signal.sendBroadcasterStatus(s.getSeq(),this.sessionId,1),this.broadcasterStatus=i.ENUM_BROADCASTER_STATUS.start;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.setPlayQualityTimer(),this.stateNego=i.ENUM_PLAY_STATE_NEGO.iceConnected,this.logger.info("zp.oisc.1  stateNego:iceConnected"),this.negoTryCount=1,this.nextSignalTryCount=1,this.waittingConnectedTimer&amp;&amp;clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null,this.negoTimer&amp;&amp;clearTimeout(this.negoTimer)}</span>else<span class="cstat-no" title="statement not covered" >"closed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceClosed"),this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState)):"failed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceFailed"),this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState)):"disconnected"===this.peerConnection.iceConnectionState&amp;&amp;(this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"IceDisconnected"),this.waittingConnectedTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!t.tryingNexitSignal&amp;&amp;t.tryNextSignal(o.playErrorList.MEDIA_CONNECTION_DISCONNECTED)}</span>),this.waittingConnectedInerval))}</span></span></span>,e.prototype.checkPlayConnectionFailedState=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>"failed"==e?t=o.playErrorList.MEDIA_CONNECTION_FAILED:"closed"==e&amp;&amp;(t=o.playErrorList.MEDIA_CONNECTION_CLOSED),null!=t&amp;&amp;(this.state!=i.ENUM_PLAY_STATE.playing&amp;&amp;this.retryState==i.ENUM_PLAY_STATE.didNotStart?(this.logger.info("zp.oics.1  state "+this.state+" retryState "+this.retryState+" connectionState "+e),this.playStateUpdateError(t)):this.shouldRetryPlay()?(this.onPlayStateUpdate(s.ENUM_PLAY_STATE_UPDATE.retry,this.streamId,o.playErrorList.MEDIA_CONNECTION_FAILED),this.startRetryPlay()):this.playStateUpdateError(t))}</span>,e.prototype.shouldRetryPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.retryState==i.ENUM_RETRY_STATE.didNotStart&amp;&amp;this.state!=i.ENUM_PLAY_STATE.playing?(this.logger.info("zp.srp.1.0 connection didn't success"),!1):this.retryState==i.ENUM_RETRY_STATE.retrying?(this.logger.info("zp.srp.0.0 already retrying"),!1):this.currentRetryCount&gt;this.maxRetryCount?(this.logger.info("zp.srp.1.0 beyond max"),!1):(this.logger.debug("zp.srp.1.0 call success"),!0)}</span>,e.prototype.startRetryPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zp.srp.0 call");v</span>ar e=<span class="cstat-no" title="statement not covered" >this.streamId;<span class="cstat-no" title="statement not covered" ></span>this.resetPlay(),this.tryStartPlay(e)}</span>,e.prototype.clearTryPlayTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.waitingServerTimer&amp;&amp;(clearTimeout(this.waitingServerTimer),this.waitingServerTimer=null)}</span>,e.prototype.tryStartPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zp.tsp.1 call"),this.clearTryPlayTimer(),this.streamId=e,this.currentRetryCount&gt;this.maxRetryCount)<span class="cstat-no" title="statement not covered" >return this.logger.error("zp.tsp.1 beyond max limit"),void this.playStateUpdateError(o.playErrorList.WEBSOCKET_ERROR);<span class="cstat-no" title="statement not covered" >t</span></span>his.retryState=i.ENUM_RETRY_STATE.retrying,this.currentRetryCount+=1,this.signal.isServerConnected()?(this.logger.debug("zp.tsp.1 signal connected"),this.startPlay(e,this.getRomoteStreamSuc,this.playOption)):(this.logger.debug("zp.tsp.1 signal server not connected"),this.waitingServerTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.tryStartPlay(e)}</span>),this.waitingServerTimerInterval))}</span>,e.prototype.clearPlayQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.qualityTimer&amp;&amp;(clearInterval(this.qualityTimer),this.qualityTimer=null),this.lastPlayStats={audioPacketsLost:0,videoPacketsLost:0,time:0,audioTime:0,videoTime:0,audioBytesReceived:0,videoBytesReceived:0,framesDecoded:0,framesDropped:0,framesReceived:0,audioBitrate:0}}</span>,e.prototype.resetPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.rp.1 call"),this.state=i.ENUM_PLAY_STATE.stop,this.playEvent=!1,null!=this.peerConnection&amp;&amp;(this.peerConnection.close(),this.peerConnection=null),null!=this.waitingOfferTimer&amp;&amp;(clearTimeout(this.waitingOfferTimer),this.waitingOfferTimer=null),null!=this.waitICETimer&amp;&amp;(clearTimeout(this.waitICETimer),this.waitICETimer=null),null!=this.negoTimer&amp;&amp;(clearTimeout(this.negoTimer),this.negoTimer=null),null!=this.waittingConnectedTimer&amp;&amp;(clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null),this.clearPlayQualityTimer(),this.signal&amp;&amp;(this.signal.unregisterPushCallback("MediaDescPush",this.sessionId),this.signal.unregisterPushCallback("CandidateInfoPush",this.sessionId),this.signal.unregisterPushCallback("CloseSessionPush",this.sessionId)),this.sessionSeq=0,this.answerSeq=0,this.videoSizeCallback=!1,this.currentRetryCount=0,this.retryState=i.ENUM_RETRY_STATE.didNotStart,this.clearTryPlayTimer()}</span>,e.prototype.setPlayQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>null==this.qualityTimer&amp;&amp;(this.logger.debug("zp.spq.1 startTimer"),this.clearPlayQualityTimer(),this.qualityTimer=setInterval((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.peerConnection&amp;&amp;e.peerConnection.getStats(null).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.getPlayStats(t)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.info("zp.spq.1 getStats error "+t.toString())}</span>))}</span>),this.qualityTimeInterval),this.lastPlayStats={audioPacketsLost:0,videoPacketsLost:0,time:0,audioTime:0,videoTime:0,audioBytesReceived:0,videoBytesReceived:0,framesDecoded:0,framesReceived:0,framesDropped:0,audioBitrate:0})}</span>,e.prototype.getPlayStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(null!=e){var r=<span class="cstat-no" title="statement not covered" >{audioFractionLost:0,audioPacketsLost:0,audioPacketsLostRate:0,audioBitrate:0,audioLevel:0,audioSendLevel:0,audioSamplingRate:0,audioCodec:"opus",audioQuality:0,videoQuality:0,videoPacketsLostRate:0,videoBitrate:0,videoFPS:0,playData:0,nackCount:0,pliCount:0,audioJitter:0,videoFractionLost:0,videoFramesDecoded:0,frameHeight:0,frameWidth:0,videoTransferFPS:0,videoFramesDropped:0,totalRoundTripTime:0,currentRoundTripTime:0},</span>i=<span class="cstat-no" title="statement not covered" >this.lastPlayStats.time,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >("inbound-rtp"==e.type||"ssrc"==e.type&amp;&amp;null!=e.bytesReceived)&amp;&amp;("audio"==e.mediaType||e.id.indexOf("AudioStream")&gt;=0)?(0!=i&amp;&amp;(r.audioBitrate=8*(e.bytesReceived-t.lastPlayStats.audioBytesReceived)/(e.timestamp-i)),r.audioBitrate&lt;0&amp;&amp;(r.audioBitrate=0),r.audioJitter=e.jitter,r.audioPacketsLost=e.packetsLost,r.audioFractionLost=e.fractionLost,r.audioPacketsLostRate=(e.packetsLost-t.lastPlayStats.audioPacketsLost)/(e.timestamp-t.lastPlayStats.audioTime),t.lastPlayStats.audioBytesReceived=e.bytesReceived,t.lastPlayStats.audioPacketsLost=e.packetsLost,t.lastPlayStats.audioTime=e.timestamp,t.lastPlayStats.time=e.timestamp,t.lastPlayStats.audioBitrate=r.audioBitrate):("inbound-rtp"==e.type||"ssrc"==e.type&amp;&amp;null!=e.bytesReceived)&amp;&amp;("video"==e.mediaType||e.id.indexOf("VideoStream")&gt;=0)?(0!=i&amp;&amp;(r.videoBitrate=8*(e.bytesReceived-t.lastPlayStats.videoBytesReceived)/(e.timestamp-i),r.videoFPS=1e3*(e.framesDecoded-t.lastPlayStats.framesDecoded)/(e.timestamp-i)),r.videoBitrate&lt;0&amp;&amp;(r.videoBitrate=0),r.videoFPS&lt;0&amp;&amp;(r.videoFPS=0),r.nackCount=e.nackCount,r.pliCount=e.pliCount,r.videoFractionLost=e.fractionLost,r.videoFramesDecoded=e.framesDecoded,r.videoPacketsLostRate=(e.packetsLost-t.lastPlayStats.videoPacketsLost)/(e.timestamp-t.lastPlayStats.videoTime),t.lastPlayStats.videoBytesReceived=e.bytesReceived,t.lastPlayStats.framesDecoded=e.framesDecoded,t.lastPlayStats.videoPacketsLost=e.packetsLost,t.lastPlayStats.videoTime=e.timestamp,t.lastPlayStats.time=e.timestamp):"track"==e.type&amp;&amp;("video"==e.kind||e.id.indexOf("video")&gt;=0)||e.frameWidth?(r.frameHeight=e.frameHeight,r.frameWidth=e.frameWidth,0!=i&amp;&amp;(r.videoTransferFPS=1e3*(e.framesReceived-t.lastPlayStats.framesReceived)/(e.timestamp-i),r.videoFramesDropped=e.framesDropped-t.lastPlayStats.framesDropped),r.videoTransferFPS&lt;0&amp;&amp;(r.videoTransferFPS=0),r.videoFramesDropped&lt;0&amp;&amp;(r.videoFramesDropped=0),t.lastPlayStats.framesReceived=e.framesReceived,t.lastPlayStats.framesDropped=e.framesDropped):"track"==e.type&amp;&amp;("audio"==e.kind||e.id.indexOf("audio")&gt;=0)?(r.audioLevel=e.audioLevel,r.audioSendLevel=e.totalAudioEnergy,r.audioSamplingRate=e.totalSamplesDuration):"candidate-pair"==e.type&amp;&amp;(null!=e.totalRoundTripTime&amp;&amp;(r.totalRoundTripTime=e.totalRoundTripTime),null!=e.currentRoundTripTime&amp;&amp;(r.currentRoundTripTime=e.currentRoundTripTime,s=1e3*r.currentRoundTripTime))}</span>)),r.audioQuality=this.getNetQuality(s,r.audioFractionLost),r.videoQuality=this.getNetQuality(s,r.videoFractionLost),this.uploadPlayQuality(r);v</span>ar o=<span class="cstat-no" title="statement not covered" >{video:{videoBitrate:r.videoBitrate,videoFPS:r.videoFPS,videoTransferFPS:r.videoTransferFPS,videoFramesDecoded:r.videoFramesDecoded,videoFramesDropped:r.videoFramesDropped,videoPacketsLostRate:r.videoPacketsLostRate,videoQuality:r.videoQuality,frameHeight:r.frameHeight,frameWidth:r.frameWidth},audio:{audioBitrate:r.audioBitrate,audioCodec:r.audioCodec,audioJitter:r.audioJitter,audioLevel:r.audioLevel,audioPacketsLost:r.audioPacketsLost,audioPacketsLostRate:r.audioPacketsLostRate,audioQuality:r.audioQuality,audioSamplingRate:r.audioSamplingRate,audioSendLevel:r.audioSendLevel},nackCount:r.nackCount,pliCount:r.pliCount,totalRoundTripTime:r.totalRoundTripTime,playData:r.playData,currentRoundTripTime:r.currentRoundTripTime};<span class="cstat-no" title="statement not covered" ></span>0!=i&amp;&amp;this.onPlayQualityUpdate(this.streamId,o)}</span>}</span>,e.prototype.getNetQuality=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e&lt;600?t&gt;.4?2:t&gt;.3?4:5:e&lt;900?t&gt;.4?2:t&gt;.2?3:4:t&gt;.2?2:3}</span>,e.prototype.uploadPlayQuality=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.qualityUpload){var r=<span class="cstat-no" title="statement not covered" >Date.parse(new Date+"");<span class="cstat-no" title="statement not covered" ></span>(0==this.qualityUploadLastTime||r-this.qualityUploadLastTime&gt;=this.qualityUploadInterval)&amp;&amp;(e.stream_type="play",e.stream_id=this.streamId,e.timeStamp=r/1e3,this.logger.info("zp.upq.1 upload"+JSON.stringify(e)),this.signal.QualityReport(s.getSeq(),this.sessionId,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >void 0!==i.report&amp;&amp;(t.qualityUpload=i.report,t.qualityUploadInterval=i.report_interval_ms)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.logger.info("zp.upq.1 upload failed "+e)}</span>)),this.qualityUploadLastTime=r)}</span>}</span>,e.prototype.onRecvResetSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.orrs.1 received "),t==this.sessionId){<span class="cstat-no" title="statement not covered" >this.signal.sendCloseSessionAck(e,this.sessionId,0);v</span>ar i=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(o.playErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>this.negoTimer&amp;&amp;clearTimeout(this.negoTimer),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(i)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.orrs.1 cannot find session")}</span></span>,e.prototype.onRecvCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.1 reason: "+r.reason),this.signal.sendCloseSessionAck(e,this.sessionId,0);v</span>ar i=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(o.playErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>i.msg+=r.reason,this.negoTimer&amp;&amp;clearTimeout(this.negoTimer);v</span>ar n=<span class="cstat-no" title="statement not covered" >1*r.reason,</span>c=<span class="cstat-no" title="statement not covered" >r.err_info&amp;&amp;JSON.parse(r.err_info).action?JSON.parse(r.err_info).action:null;<span class="cstat-no" title="statement not covered" ></span>if("number"==typeof n&amp;&amp;[24,28].includes(n)&amp;&amp;this.negoTryCount&lt;this.negoTryMaxCount||5==c){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.1 retry: "+this.streamId),this.retrySeq=s.getReportSeq(),this.dataReport.newReport(this.retrySeq,a.eventList.kZegoTaskRePlay),this.dataReport.addMsgInfo(this.retrySeq,{reason:i});v</span>ar d=<span class="cstat-no" title="statement not covered" >this.streamId,</span>l=<span class="cstat-no" title="statement not covered" >this.playOption;<span class="cstat-no" title="statement not covered" ></span>this.signal.sendCloseSession(s.getSeq(),this.sessionId,1),this.onPlayStateUpdate(s.ENUM_PLAY_STATE_UPDATE.retry,this.streamId,{code:0,msg:""}),this.resetPlay(),this.startPlay(d,this.getRomoteStreamSuc,l),++this.negoTryCount}</span>else<span class="cstat-no" title="statement not covered" >[4,8,10,11,12,26,27].includes(n)||2==c?!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(i):this.playStateUpdateError(i,!0)}</span></span>,e.prototype.onRecvStreamStatus=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zp.orss.0 call"),this.cameraStatus!==e.camera_status&amp;&amp;this.onRemoteCameraStatusUpdate(this.streamId,this.getCameraMicStatus(e.camera_status)),this.micStatus!==e.mic_status&amp;&amp;this.onRemoteMicStatusUpdate(this.streamId,this.getCameraMicStatus(e.mic_status)),this.cameraStatus=e.camera_status,this.micStatus=e.mic_status,"boolean"!=typeof this.playOption.video&amp;&amp;"boolean"!=typeof this.playOption.audio){var t=<span class="cstat-no" title="statement not covered" >this.playStream;<span class="cstat-no" title="statement not covered" ></span>0!==e.camera_status&amp;&amp;t.getVideoTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.stop(),t.removeTrack(e)}</span>)),0==e.camera_status&amp;&amp;0==t.getVideoTracks().length&amp;&amp;t.addTrack(this.remoteStream.clone().getVideoTracks()[0]),this.logger.debug("zp.orss.0 call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.orss.0 has set playType, ignore stream status")}</span></span>,e.prototype.onGotRemoteStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ogrs.0 called "+e),e?(this.playStream?(this.playStream.getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.playStream.removeTrack(e)}</span>)),e.clone().getTracks().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.playStream.addTrack(e)}</span>))):this.playStream=e.clone(),this.remoteStream=e,this.getRomoteStreamSuc(this.playStream),this.gotStreamStatus&amp;&amp;this.onRecvStreamStatus(this.streamStatus),this.dataReport.addEvent(0==this.retrySeq?this.reportSeq:this.retrySeq,"GetRemoteStream"),this.streamCenter.soundLevelDelegate&amp;&amp;this.startSoundLevel()):this.logger.warn("zp.ogrs.0 remote stream is empty")}</span>,e.prototype.sendCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sci.1 called"),!(e=e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!(e.candidate.indexOf("tcp")&gt;0)&amp;&amp;(!!e.candidate||void 0)}</span>)))||e.length&lt;1?this.logger.info("zp.sci.1 cancelled"):(this.dataReport.eventStart(0==this.retrySeq?this.reportSeq:this.retrySeq,"SendIceCandidate"),this.stateNego!==i.ENUM_PLAY_STATE_NEGO.iceConnected&amp;&amp;(this.stateNego=i.ENUM_PLAY_STATE_NEGO.sendCandidate),this.logger.info("zp.sci.1  stateNego:sendCandidate"),this.signal.sendCandidateInfo(s.getSeq(),this.sessionId,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,i){<span class="cstat-no" title="statement not covered" >t.logger.debug("zp.sci.1 send success"),t.dataReport.eventEnd(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendIceCandidate")}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >t.logger.error("zp.sci.1 failed to send: "+e.toString()),t.dataReport.eventEndWithMsg(0==t.retrySeq?t.reportSeq:t.retrySeq,"SendIceCandidate",{error:e}),t.playStateUpdateError(o.playErrorList.SEND_CANDIDATE_ERROR)}</span>)))}</span>,e.prototype.shouldSendCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.state!=s.ENUM_PLAY_STATE_UPDATE.stop&amp;&amp;this.state!=i.ENUM_PLAY_STATE.waitingSessionRsp}</span>,e.prototype.playStateUpdateError=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.psue.1 called ",e.code),t||!(this.state===i.ENUM_PLAY_STATE.stop||this.negoTryCount&lt;this.negoTryMaxCount&amp;&amp;this.stateNego&lt;i.ENUM_PLAY_STATE_NEGO.iceConnected)?(0!=this.sessionId&amp;&amp;this.shouldSendCloseSession(e)&amp;&amp;(this.signal.sendCloseSession(s.getSeq(),this.sessionId,1),this.closeSessionSignal=!0),this.state=i.ENUM_PLAY_STATE.stop,this.onPlayStateUpdate(s.ENUM_PLAY_STATE_UPDATE.error,this.streamId,e),this.resetPlay()):this.logger.info("zp.psue.1 reset")}</span>,e.prototype.getCameraMicStatus=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0==e?"OPEN":"MUTE"}</span>,e.prototype.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.stopPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e in this.logger.info("zp.sp.1.1 called"),this.streamCenter.publisherList){<span class="cstat-no" title="statement not covered" >if(this.streamCenter.publisherList[e].publisher.state==i.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.broadcasterStatus==i.ENUM_BROADCASTER_STATUS.start){<span class="cstat-no" title="statement not covered" >this.signal&amp;&amp;this.signal.sendBroadcasterStatus(s.getSeq(),this.sessionId,0),this.broadcasterStatus=i.ENUM_BROADCASTER_STATUS.stop;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.sessionId&amp;&amp;!this.closeSessionSignal&amp;&amp;this.signal.sendCloseSession(s.getSeq(),this.sessionId,0),this.resetPlay()}</span>,e.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.od.1 call"),this.logger.info("zp.od.1 websocket disconnect"),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(o.playErrorList.WEBSOCKET_ERROR)}</span>,e.prototype.tryNextSignal=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.tryingNexitSignal=!0;v</span>ar t=<span class="cstat-no" title="statement not covered" >this.streamId,</span>r=<span class="cstat-no" title="statement not covered" >this.signal.server,</span>o=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[t],</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;o.serverUrls&amp;&amp;(n=o.serverUrls),this.retrySeq=s.getReportSeq(),this.streamCenter.stateCenter.reportSeqList.rePublish[t]=this.retrySeq,this.dataReport.newReport(this.retrySeq,a.eventList.kZegoTaskRePlay),this.dataReport.addMsgInfo(this.retrySeq,{serverUrls:n,reason:e}),this.nextSignalTryCount&gt;3*n.length?(this.logger.error("zp.tns.1 try max limit"),this.playStateUpdateError(e)):(this.onPlayStateUpdate(s.ENUM_PLAY_STATE_UPDATE.retry,this.streamId,{code:0,msg:""}),n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t&lt;=n.indexOf(r)&amp;&amp;n.push(e)}</span>)),n.splice(0,n.indexOf(r)+1),this.logger.info("zp.tns.1 try next signal "+t),this.signal&amp;&amp;this.signal.state==i.ENUM_CONNECT_STATE.connected&amp;&amp;this.signal.sendCloseSession(s.getSeq(),this.sessionId,1),this.signal&amp;&amp;this.signal.removeSession(this.sessionId),this.resetPlay(),this.streamCenter.connectPlayServer(t,this.getRomoteStreamSuc,!0),this.nextSignalTryCount++)}</span>,e.prototype.startSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.ssl.1 call streamID: "+this.streamId),this.remoteStream&amp;&amp;0!=this.remoteStream.getAudioTracks().length){<span class="cstat-no" title="statement not covered" >this.script&amp;&amp;this.script.disconnect()&amp;&amp;(this.script=null),this.mic&amp;&amp;this.mic.disconnect()&amp;&amp;(this.mic=null);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.mic=this.ac.createMediaStreamSource(this.remoteStream),this.script=this.ac.createScriptProcessor(4096,1,1),this.mic.connect(this.script),this.script.connect(this.ac.destination),this.script.onaudioprocess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var r=t.inputBuffer.getChannelData(0),i=0,s=0;s&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >i&lt;r[s]&amp;&amp;(i=r[s]);<span class="cstat-no" title="statement not covered" >e</span></span>.soundLevel=100*i}</span>,this.ac.resume()}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.logger.error("zp.ssl.1 get sound level failed "+e)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.1 remote stream no found")}</span></span>,e.prototype.stopSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.1.1 call streamID: "+this.streamId),this.script&amp;&amp;this.script.disconnect(),this.mic&amp;&amp;this.mic.disconnect(),this.script=null,this.mic=null}</span>,e}();t.ZegoPlayWeb=c},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){this.playerList={},this.publisherList={},this.playSuccessCallBackList={},this.playErrorCallBackList={}}return e.prototype.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.setSessionInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){},e}();t.ZegoStreamCenter=i},function(e,t,r){"use strict";var i,s=this&amp;&amp;this.__extends||(i=function(e,t){return(i=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.__proto__=t}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(r)&amp;&amp;(e[r]=t[r])}</span></span>)</span>(e,t)},function(e,t){function r(){this.constructor=e}i(e,t),e.prototype=null===t?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(t):</span>(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(19),n=r(0),a=r(20),c=r(21),d=r(22),l=r(23),u=r(24),h=r(25),p=r(1),g=r(3),m=r(2),f=r(4),v=function(e){function t(){return e.call(this)||this}return s(t,e),t.prototype.init=function(){this.bindSocketHandler(),this.bindStreamHandler(),this.bindHeatBeatHandler(),this.bindRoomHandler(),this.bindMessageHandler(),this.bindLiveHandler(),this.bindStreamCenterHandler()},t.prototype.bindSocketHandler=function(){var e=this;this.socketCenter=new a.SocketCenter(this.logger,this.stateCenter),this.socketCenter.registerRouter("push_signal",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.liveHandler.handlePushSignalMsg(t)}</span>)),this.socketCenter.getSocket=function(t){return e.getSocket(t)},this.socketCenter.handlePushKickout=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.info("zb.cm.bsh.0  call hpk");v</span>ar r=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(r,f.eventList.kZegoTaskKickout),e.roomHandler.setRunState(n.ENUM_RUN_STATE.logout),e.roomHandler.resetRoom(),e.dataReport.addMsgInfo(r,{user_id:e.stateCenter.idName}),e.logger.error("zb.cm.bsh.0 kick out reason "+t.body.reason),e.dataReport.addMsgInfo(r,{error:g.ClientUtil.getKickoutError(t.body.reason).code,message:g.ClientUtil.getKickoutError(t.body.reason).message}),e.dataReport.uploadReport(r),e.stateCenter.actionListener("roomStateUpdate",e.stateCenter.roomid,"DISCONNECTED",p.liveRoomErrorList.KICK_OUT,""),e.logger.debug("zb.cm.bsh.0  call hpk success")}</span>,this.socketCenter.handlePushCustomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.messageHandler.handlePushCustomMsg(t)}</span>,this.socketCenter.handlePushUserStateUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.roomHandler.handlePushUserStateUpdateMsg(t)}</span>,this.socketCenter.handlePushRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(r),e.dataReport.addMsgInfo(r,{room_sid:t.header.session_id});v</span>ar i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.body.chat_data.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var s=<span class="cstat-no" title="statement not covered" >{fromUser:{userID:t.id_name,userName:t.nick_name},message:t.msg_content,sendTime:t.send_time,messageID:t.msg_id};<span class="cstat-no" title="statement not covered" ></span>i.push(s),e.dataReport.addMsgInfo(r,{from_msg_id:t.id_name})}</span>)),e.dataReport.uploadReport(r,f.eventList.kZegoTaskLiveRoomGetRoomMessage),e.stateCenter.actionListener("IMRecvBroadcastMessage",e.stateCenter.roomid,i)}</span>,this.socketCenter.handlePushMergeMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.messageHandler.handlePushMergeMsg(t)}</span>,this.socketCenter.handlePushTransMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.messageHandler.handlePushTransMsg(t)}</span>,this.socketCenter.handleBigImMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.messageHandler.handleBigImMsgRsp(t)}</span>},t.prototype.bindStreamHandler=function(){var e=this;this.streamHandler=new d.StreamHandler(this.logger,this.stateCenter,this.socketCenter,this.dataReport),this.streamHandler.onStreamUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){var s=<span class="cstat-no" title="statement not covered" >i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{streamID:e.streamID,user:e.user,extraInfo:e.extraInfo,urlsFLV:e.urlsFLV,urlsRTMP:e.urlsRTMP,urlsHLS:e.urlsHLS,urlsHttpsFLV:e.urlsHttpsFLV,urlsHttpsHLS:e.urlsHttpsHLS}}</span>)),</span>o=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(o,f.eventList.kZegoTaskLiveRoomGetStreamUpdateInfo),e.dataReport.addMsgInfo(o,{stream_update_type:1===r?"added":"deleted",update_stream:s}),e.dataReport.uploadReport(o),e.stateCenter.actionListener("roomStreamUpdate",t,g.ClientUtil.getSteamUpdateType(r),s)}</span>,this.streamHandler.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){<span class="cstat-no" title="statement not covered" >if(e.logger.info("zb.opsu ",r),"xcx"==e.stateCenter.clientType)<span class="cstat-no" title="statement not covered" >0==t?(g.ClientUtil.actionSuccessCallback("kZegoTaskPublishStart"+r,e.stateCenter.reportList)&amp;&amp;g.ClientUtil.actionSuccessCallback("kZegoTaskPublishStart"+r,e.stateCenter.reportList)(m.REPORT_ACTION.eventEnd,"publish_state"),e.dataReport.uploadReport(e.stateCenter.reportSeqList.startPublish[r]),delete e.stateCenter.reportSeqList.startPublish[r],g.ClientUtil.unregisterCallback("kZegoTaskPublishStart"+r,e.stateCenter.reportList)):1==t&amp;&amp;(e.dataReport.addMsgInfo(e.stateCenter.reportSeqList.startPublish[r],{error:i.code,message:i.msg}),e.dataReport.uploadReport(e.stateCenter.reportSeqList.startPublish[r]),delete e.stateCenter.reportSeqList.startPublish[r],g.ClientUtil.unregisterCallback("kZegoTaskPublishStart"+r,e.stateCenter.reportList));e</span>lse{var s=<span class="cstat-no" title="statement not covered" >e.streamCenter.getTotalStreamId(r),</span>o=<span class="cstat-no" title="statement not covered" >e.stateCenter.reportSeqList.startPublish[s],</span>n=<span class="cstat-no" title="statement not covered" >e.streamCenter.publisherList[s];<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n.publisher&amp;&amp;(0==t||1==t))<span class="cstat-no" title="statement not covered" >if(0!==n.publisher.retrySeq){var a=<span class="cstat-no" title="statement not covered" >n.publisher.retrySeq;<span class="cstat-no" title="statement not covered" ></span>e.dataReport.eventEndWithMsgInfo(a,"PublishState",{type:t}),1==t&amp;&amp;e.dataReport.addMsgInfo(a,{error:i.code,message:i.msg}),e.dataReport.uploadReport(a),delete e.stateCenter.reportSeqList.rePublish[s]}</span>else <span class="cstat-no" title="statement not covered" >e.dataReport.eventEndWithMsgInfo(o,"PublishState",{type:t}),1==t&amp;&amp;e.dataReport.addMsgInfo(o,{error:i.code,message:i.msg}),e.dataReport.uploadReport(o),delete e.stateCenter.reportSeqList.startPublish[s]}<span class="cstat-no" title="statement not covered" ></span></span></span>e</span>.stateCenter.actionListener("publisherStateUpdate",{state:g.ClientUtil.getPublisherStateType(t),streamID:r,errorCode:i.code,extendedData:i.msg})}</span>,this.streamHandler.onStreamExtraInfoUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var i=<span class="cstat-no" title="statement not covered" >r.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{streamID:e.streamID,user:e.user,extraInfo:e.extraInfo}}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(s,f.eventList.kZegoTaskLiveRoomGetStreamExtraInfo),e.dataReport.addMsgInfo(s,{update_stream:i}),e.dataReport.uploadReport(s),e.stateCenter.actionListener("streamExtraInfoUpdate",t,i)}</span>,this.streamHandler.setCDNInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >e.setCDNInfo(t,r)}</span>},t.prototype.bindHeatBeatHandler=function(){var e=this;this.heartBeatHandler=new l.HeartBeatHandler(this.logger,this.stateCenter,this.socketCenter,this.dataReport),this.heartBeatHandler.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("recvReliableMessage",t,r,i)}</span>,this.heartBeatHandler.handleFetchStreamListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.streamHandler.handleFetchStreamListRsp(t)}</span>,this.heartBeatHandler.fetchUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.roomHandler.fetchUserList()}</span>,this.heartBeatHandler.onUpdateOnlineCount=function(t,r){e.stateCenter.actionListener("updateOnlineCount",t,r)},this.heartBeatHandler.updateStreamInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i,s){<span class="cstat-no" title="statement not covered" >void 0===i&amp;&amp;(i=""),e.streamHandler.updateStreamInfo(t,r,i,s)}</span>,this.heartBeatHandler.hbLogout=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.error("hhbr.0 "+t.msg),e.stateCenter.actionListener("roomStateUpdate",e.stateCenter.roomid,"DISCONNECTED",t.code,"")}</span>},t.prototype.bindRoomHandler=function(){var e=this;this.roomHandler=new c.RoomHandler(this.logger,this.stateCenter,this.socketCenter),this.roomHandler.loginSuccessCallBack=function(t,r){var i=r.body.hearbeat_interval&lt;n.MINIUM_HEARTBEAT_INTERVAL?<span class="branch-0 cbranch-no" title="branch not covered" >n.MINIUM_HEARTBEAT_INTERVAL:</span>r.body.hearbeat_interval;e.stateCenter.tryHeartbeatCount=0,e.stateCenter.heartbeatTimer&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >clearTimeout(e.stateCenter.heartbeatTimer),</span>e.heartBeatHandler.start(i),e.heartBeatHandler.resetCheckMessage(),e.heartBeatHandler.startCheckMessageTimeout(),e.streamCenter.setSessionInfo(e.stateCenter.appid,e.stateCenter.idName,e.stateCenter.token,e.stateCenter.testEnvironment),r.body.anchor_info&amp;&amp;e.stateCenter.actionListener("getAnchorInfo",r.body.anchor_info.anchor_id_name,r.body.anchor_info.anchor_nick_name),r.body.online_count&amp;&amp;e.stateCenter.actionListener("updateOnlineCount",e.stateCenter.roomid,r.body.online_count),e.logger.info("zb.cm.brh hls userStateUpdate "+e.stateCenter.userStateUpdate),e.stateCenter.userStateUpdate&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.logger.info("zb.cm.brh hls fetch all new userlist"),e.roomHandler.fetchUserList(t))</span>,e.streamHandler.handleStreamStart(t,r)},this.roomHandler.resetRoomCallBack=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.heartBeatHandler.resetHeartbeat(),e.heartBeatHandler.resetCheckMessage(),e.resetStreamCenter()}</span>,this.roomHandler.onUserStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){var s=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(s,f.eventList.kZegoTaskLiveRoomGetUserUpdateInfo);v</span>ar o=<span class="cstat-no" title="statement not covered" >i.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.userID!==e.stateCenter.idName}</span>));<span class="cstat-no" title="statement not covered" ></span>0!==o.length&amp;&amp;e.stateCenter.actionListener("roomUserUpdate",t,r,o),e.dataReport.addMsgInfo(s,{user_update_type:"ADD"==r?"added":"deleted"})}</span>,this.roomHandler.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(e.logger.error("zc.od.0 "+t.msg),"string"==typeof t.code&amp;&amp;"Error.Network"===t.code)<span class="cstat-no" title="statement not covered" >e.dataReport.addMsgInfo(e.stateCenter.reportSeqList.relogin,{error:f.errorList.kLiveRoomDisconnect.code,message:f.errorList.kLiveRoomDisconnect.message});e</span>lse <span class="cstat-no" title="statement not covered" >if("number"==typeof t.code){var r=<span class="cstat-no" title="statement not covered" >g.ClientUtil.decodeServerError(t.code,t.msg);<span class="cstat-no" title="statement not covered" ></span>e.dataReport.addMsgInfo(e.stateCenter.reportSeqList.relogin,{error:r.code,message:r.message})}<span class="cstat-no" title="statement not covered" ></span>e</span></span>.dataReport.uploadReport(e.stateCenter.reportSeqList.relogin),e.stateCenter.reportSeqList.relogin=0,g.ClientUtil.unregisterCallback("kZegoTaskReLoginRoom",e.stateCenter.reportList),e.stateCenter.actionListener("roomStateUpdate",e.stateCenter.roomid,"DISCONNECTED",t.code,"")}</span>,this.roomHandler.onConnecting=function(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(0===e.stateCenter.reportSeqList.login){var r=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.stateCenter.reportSeqList.relogin=r,e.dataReport.newReport(r,f.eventList.kZegoTaskReLoginRoom),g.ClientUtil.logReportCallback("kZegoTaskReLoginRoom",e.dataReport,r,e.stateCenter.reportList)}</span>e.stateCenter.actionListener("roomStateUpdate",e.stateCenter.roomid,"CONNECTING",t.code,t.msg)},this.roomHandler.loginBodyData=function(){return e.loginBodyData()}},t.prototype.bindMessageHandler=function(){var e=this;this.messageHandler=new u.MessageHandler(this.logger,this.stateCenter,this.socketCenter,this.dataReport),this.messageHandler.onRecvCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i,s){var o=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(o),e.dataReport.uploadReport(o,f.eventList.kZegoTaskLiveRoomGetCustomCommand),e.stateCenter.actionListener("IMRecvCustomCommand",i,{userID:t,userName:r},s)}</span>,this.messageHandler.onRecvBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var i=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(i);v</span>ar s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >{fromUser:{userID:e.idName,userName:e.nickName},message:e.content,sendTime:e.time,messageID:e.messageId};<span class="cstat-no" title="statement not covered" ></span>s.push(t)}</span>)),e.dataReport.uploadReport(i,f.eventList.kZegoTaskLiveGetRoomBigIM),e.stateCenter.actionListener("IMRecvBarrageMessage",r,s)}</span>,this.messageHandler.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("recvReliableMessage",t,r,i)}</span>},t.prototype.bindLiveHandler=function(){var e=this;this.liveHandler=new h.LiveHandler(this.logger,this.stateCenter,this.socketCenter),this.liveHandler.onRecvEndJoinLiveCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i,s){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("recvEndJoinLiveCommand",t,r,i,s)}</span>,this.liveHandler.onRecvInviteJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i,s){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("RecvInviteJoinLiveRequest",t,r,i,s)}</span>,this.liveHandler.onRecvJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i,s){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("recvJoinLiveRequest",t,r,i,s)}</span>},t.prototype.bindStreamCenterHandler=function(){var e=this;this.streamCenter.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){<span class="cstat-no" title="statement not covered" >if("xcx"==e.stateCenter.clientType)<span class="cstat-no" title="statement not covered" >0==t?(g.ClientUtil.actionSuccessCallback("kZegoTaskPlayStart"+r,e.stateCenter.reportList)&amp;&amp;g.ClientUtil.actionSuccessCallback("kZegoTaskPlayStart"+r,e.stateCenter.reportList)("eventEnd","play_state"),e.dataReport.uploadReport(e.stateCenter.reportSeqList.startPlay[r]),delete e.stateCenter.reportSeqList.startPlay[r],g.ClientUtil.unregisterCallback("kZegoTaskPlayStart"+r,e.stateCenter.reportList)):1==t&amp;&amp;(e.dataReport.uploadReport(e.stateCenter.reportSeqList.startPlay[r]),delete e.stateCenter.reportSeqList.startPlay[r],g.ClientUtil.unregisterCallback("kZegoTaskPlayStart"+r,e.stateCenter.reportList)),e.stateCenter.actionListener("playerStateUpdate",{state:g.ClientUtil.getPlayerStateType(t),streamID:r,errorCode:i.code,extendedData:i.msg});e</span>lse{var s=<span class="cstat-no" title="statement not covered" >e.streamCenter.getTotalStreamId(r),</span>o=<span class="cstat-no" title="statement not covered" >e.stateCenter.reportSeqList.startPlay[s],</span>n=<span class="cstat-no" title="statement not covered" >e.streamCenter.playerList[s];<span class="cstat-no" title="statement not covered" ></span>if(console.log(s),n&amp;&amp;n.player&amp;&amp;(0==t||1==t))<span class="cstat-no" title="statement not covered" >if(0!==n.player.retrySeq){var a=<span class="cstat-no" title="statement not covered" >n.player.retrySeq;<span class="cstat-no" title="statement not covered" ></span>e.dataReport.eventEndWithMsgInfo(a,"PlayState",{type:t}),1==t&amp;&amp;e.dataReport.addMsgInfo(a,{error:i.code,message:i.msg}),e.dataReport.uploadReport(a),delete e.stateCenter.reportSeqList.rePlay[s]}</span>else <span class="cstat-no" title="statement not covered" >e.dataReport.eventEndWithMsgInfo(o,"PlayState",{type:t}),1==t&amp;&amp;e.dataReport.addMsgInfo(o,{error:i.code,message:i.msg}),e.dataReport.uploadReport(o),delete e.stateCenter.reportSeqList.startPlay[s];<span class="cstat-no" title="statement not covered" >e</span></span></span>.stateCenter.actionListener("playerStateUpdate",{state:g.ClientUtil.getPlayerStateType(t),streamID:r,errorCode:i.code,extendedData:i.msg})}</span>}</span>,this.streamCenter.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,i){<span class="cstat-no" title="statement not covered" >e.onPublishStateUpdateHandle(t,r,i)}</span>,this.streamCenter.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("publishQualityUpdate",t,r)}</span>,this.streamCenter.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("playQualityUpdate",t,r)}</span>,this.streamCenter.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var i=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(i,f.eventList.kZegoTaskRemoteCameraUpdate),e.dataReport.uploadReport(i),e.stateCenter.actionListener("remoteCameraStatusUpdate",t,r)}</span>,this.streamCenter.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var i=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>e.dataReport.newReport(i,f.eventList.kZegoTaskRemoteMicUpdate),e.dataReport.uploadReport(i),e.stateCenter.actionListener("remoteMicStatusUpdate",t,r)}</span>,this.streamCenter.onSoundLevelUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.stateCenter.actionListener("soundLevelUpdate",t)}</span>},t.prototype.setLogConfig=function(e){this.logger.info("zb.cm.clf call");var t=m.getReportSeq();<span class="missing-if-branch" title="if path not taken" >I</span>if(this.dataReport.newReport(t),e.logLevel&amp;&amp;(this.logger.setLogLevel(g.ClientUtil.getLogLevel(e.logLevel)),this.dataReport.addMsgInfo(t,{log_level:e.logLevel})),e.remoteLogLevel&amp;&amp;[0,1,2,3,99,100].includes(g.ClientUtil.getLogLevel(e.remoteLogLevel))&amp;&amp;(this.logger.setRemoteLogLevel(g.ClientUtil.getLogLevel(e.remoteLogLevel)),this.dataReport.addMsgInfo(t,{remote_log_level:e.remoteLogLevel})),this.logger.setSessionInfo(this.stateCenter.appid,"","",this.stateCenter.idName,"",n.PROTO_VERSION),"string"==typeof e.logURL&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.logURL.startsWith("wss://")|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >e.logURL.startsWith("https://"))</span>)<span class="cstat-no" title="statement not covered" >this.logger.openLogServer(e.logURL),this.dataReport.addMsgInfo(t,{log_url:e.logURL});e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if(e.logURL)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.cm.clf log url must be a wss or https url"),!1;r</span>eturn this.dataReport.uploadReport(t,f.eventList.kZegoTaskSetLog),this.logger.info("zb.cm.clf call success"),!0},t.prototype.setDebugVerbose=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.cm.sd call");v</span>ar t=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>this.dataReport.newReport(t),"boolean"==typeof e&amp;&amp;(this.stateCenter.debug=e,this.stateCenter.debugCustom=!0,this.dataReport.addMsgInfo(t,{debug:e?"true":"false"})),this.dataReport.uploadReport(t,f.eventList.kZegoTaskSetDebug),this.logger.info("zb.cm.sd call success")}</span>,t.prototype.loginRoom=function(e,t,r,i){var s=this;return new Promise((function(o,n){var a=s.loginReport(o,n,t,i),c=a.interResolve,d=a.interReject;return"string"!=typeof e||""==e?(<span class="branch-0 cbranch-no" title="branch not covered" >s.logger.error("zb.rh.lg roomid must be string and not empty"),void d(p.commonErrorList.PARAM," param roomID error."))</span>:"string"!=typeof t||""==t?(<span class="branch-0 cbranch-no" title="branch not covered" >s.logger.error("zb.rh.lg token must be string and not empty"),void d(p.commonErrorList.PARAM," param token error."))</span>:r&amp;&amp;"object"==typeof r?r.userID&amp;&amp;"string"==typeof r.userID&amp;&amp;""!=r.userID?r.userName&amp;&amp;"string"==typeof r.userName&amp;&amp;""!=r.userName?void s.roomHandler.login(e,t,r,i,c,d):(<span class="branch-1 cbranch-no" title="branch not covered" >s.logger.error("zb.rh.lg userName must be string and not empty"),void d(p.commonErrorList.PARAM," param userName error."))</span>:(<span class="branch-1 cbranch-no" title="branch not covered" >s.logger.error("zb.rh.lg userID must be string and not empty"),void d(p.commonErrorList.PARAM," param userID error."))</span>:(<span class="branch-1 cbranch-no" title="branch not covered" >s.logger.error("zb.rh.lg user must be exist and is an object"),void d(p.commonErrorList.PARAM," param user error."))</span>}))},t.prototype.loginReport=function(e,t,r,i){var s=this;0!==this.stateCenter.reportSeqList.login&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.dataReport.uploadReport(this.stateCenter.reportSeqList.login),this.stateCenter.reportSeqList.login=0,g.ClientUtil.unregisterCallback("kZegoTaskLoginRoom",this.stateCenter.reportList))</span>;var o=m.getReportSeq();this.stateCenter.reportSeqList.login=o,this.dataReport.newReport(o,f.eventList.kZegoTaskLoginRoom),"string"==typeof r&amp;&amp;this.dataReport.addMsgInfo(o,{token:r}),i&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >i.userUpdate&amp;&amp;"boolean"==typeof i.userUpdate&amp;&amp;this.dataReport.addMsgInfo(o,{user_update:i.userUpdate}),i.maxMemberCount&amp;&amp;"number"==typeof i.maxMemberCount&amp;&amp;this.dataReport.addMsgInfo(o,{max_member_count:i.maxMemberCount}))</span>,g.ClientUtil.logReportCallback("kZegoTaskLoginRoom",this.dataReport,o,this.stateCenter.reportList);return{interResolve:function(t){s.dataReport.uploadReport(o),s.stateCenter.reportSeqList.login=0,g.ClientUtil.unregisterCallback("kZegoTaskLoginRoom",s.stateCenter.reportList),e(t)},interReject:<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var i;<span class="cstat-no" title="statement not covered" >if(void 0===r&amp;&amp;(r=""),e.code&lt;2e9)<span class="cstat-no" title="statement not covered" >i=g.ClientUtil.decodeServerError(e.code,e.msg);e</span>lse{var n=<span class="cstat-no" title="statement not covered" >f.codeErrMap[e.code];<span class="cstat-no" title="statement not covered" ></span>i=f.errorList[n]}<span class="cstat-no" title="statement not covered" ></span>s</span>.dataReport.addMsgInfo(o,{error:i.code,message:i.message+r}),s.dataReport.uploadReport(o),s.stateCenter.reportSeqList.login=0,g.ClientUtil.unregisterCallback("kZegoTaskLoginRoom",s.stateCenter.reportList),t(e)}</span>}},t.prototype.logoutRoom=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>this.dataReport.newReport(t),"string"==typeof e&amp;&amp;""!=e||(this.logger.debug("zb.rh.lg roomid must be string and not empty"),this.dataReport.addMsgInfo(t,{error:f.errorList.kInvalidParamError.code,message:f.errorList.kInvalidParamError.message+" param roomID error"})),this.roomHandler.logout(e),this.dataReport.uploadReport(t,f.eventList.kZegoTaskLogoutRoom)}</span>,t.prototype.sendCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){var n=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>i.dataReport.newReport(n,f.eventList.kZegoTaskLiveRoomSendCustomCommand),i.dataReport.addMsgInfo(n,{room_sid:i.stateCenter.sessionid});v</span>ar a=<span class="cstat-no" title="statement not covered" >g.ClientUtil.proxyRes(i.dataReport,n,s,o),</span>c=<span class="cstat-no" title="statement not covered" >a.interResolve,</span>d=<span class="cstat-no" title="statement not covered" >a.interReject;<span class="cstat-no" title="statement not covered" ></span>return"string"!=typeof e||""==e?(i.logger.error("zb.scc roomid must be string and not empty"),void d(p.commonErrorList.PARAM," param roomID error")):r instanceof Array&amp;&amp;!r.find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"string"!=typeof e}</span>))?"string"!=typeof t&amp;&amp;"object"!=typeof t?(i.logger.error("zb.scc custom content must be a non empty string or object"),void d(p.commonErrorList.PARAM," param command error")):void i.messageHandler.sendCustomCommand(r,t,c,d):(i.logger.error("zb.scc dstMembers must be string array"),void d(p.commonErrorList.PARAM," param toUserList error"))}</span>))}</span>,t.prototype.sendBroadcastMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(i,s){var o=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>r.dataReport.newReport(o,f.eventList.kZegoTaskLiveRoomSendRoomMessage),r.dataReport.addMsgInfo(o,{room_sid:r.stateCenter.sessionid});v</span>ar n=<span class="cstat-no" title="statement not covered" >g.ClientUtil.proxyRes(r.dataReport,o,i,s),</span>a=<span class="cstat-no" title="statement not covered" >n.interResolve,</span>c=<span class="cstat-no" title="statement not covered" >n.interReject;<span class="cstat-no" title="statement not covered" ></span>return"string"!=typeof e||""==e?(r.logger.error("zb.sbcm roomid must be string and not empty"),void c(p.commonErrorList.PARAM," param roomID error")):"string"!=typeof t?(r.logger.error("zb.sbcm message must be string"),void c(p.commonErrorList.PARAM," param message error")):void r.messageHandler.sendRoomMsg(r.stateCenter.msgCategory,e,t,a,c)}</span>))}</span>,t.prototype.sendReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >this.messageHandler.sendReliableMessage(e,t,r,i)}</span>,t.prototype.sendBarrageMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(i,s){var o=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>r.dataReport.newReport(o,f.eventList.kZegoTaskLiveSendRoomBigIM),r.dataReport.addMsgInfo(o,{room_sid:r.stateCenter.sessionid});v</span>ar n=<span class="cstat-no" title="statement not covered" >g.ClientUtil.proxyRes(r.dataReport,o,i,s),</span>a=<span class="cstat-no" title="statement not covered" >n.interResolve,</span>c=<span class="cstat-no" title="statement not covered" >n.interReject;<span class="cstat-no" title="statement not covered" ></span>return"string"!=typeof e||""==e?(r.logger.error("zb.sbm roomid must be string and not empty"),void c(p.commonErrorList.PARAM," param roomID error")):"string"!=typeof t?(r.logger.error("zb.sbm message must be string"),void c(p.commonErrorList.PARAM," param message error")):void r.messageHandler.sendBigRoomMessage(r.stateCenter.msgCategory,e,t,a,c)}</span>))}</span>,t.prototype.sendRelayMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >this.messageHandler.sendRelayMessage(e,t,r,i)}</span>,t.prototype.requestJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >return this.liveHandler.requestJoinLive(e,t,r,i)}</span>,t.prototype.inviteJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >return this.liveHandler.inviteJoinLive(e,t,r,i)}</span>,t.prototype.endJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return this.liveHandler.endJoinLive(e,t,r)}</span>,t.prototype.respondJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >return this.liveHandler.respondJoinLive(e,t,r,i)}</span>,t.prototype.startMixerTask=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(r,i){<span class="cstat-no" title="statement not covered" >e.outputConfig&amp;&amp;e.outputConfig.outputFps&amp;&amp;(e.outputConfig.outputFPS=e.outputConfig.outputFps);v</span>ar s=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>t.dataReport.newReport(s,f.eventList.kZegoTaskMixStart),g.ClientUtil.logReportCallback("kZegoTaskMixStart"+e.taskID,t.dataReport,s,t.stateCenter.reportList);<span class="cstat-no" title="statement not covered" >t</span>.streamHandler.updateMixStream(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.dataReport.uploadReport(s),g.ClientUtil.unregisterCallback("kZegoTaskMixStart"+e.taskID,t.stateCenter.reportList),r(i)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(r){var o;<span class="cstat-no" title="statement not covered" >o=r.errorCode&lt;2e9?g.ClientUtil.mixServerError(r.errorCode-n.MIXSTREAM_ERROR_CODE):f.codeErrMap[r.errorCode],t.dataReport.addMsgInfo(s,{error:f.errorList[o].code,message:f.errorList[o].message}),t.dataReport.uploadReport(s),g.ClientUtil.unregisterCallback("kZegoTaskMixStart"+e.taskID,t.stateCenter.reportList),i(r)}</span>))}</span>))}</span>,t.prototype.setMixerTaskConfig=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(r,i){var s=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>t.dataReport.newReport(s,f.eventList.kZegoTaskMixStart),g.ClientUtil.logReportCallback("kZegoTaskMixConfig",t.dataReport,s,t.stateCenter.reportList),t.streamHandler.setMixerTaskConfig(e).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.dataReport.uploadReport(s),g.ClientUtil.unregisterCallback("kZegoTaskMixConfig",t.stateCenter.reportList),r(e)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >f.codeErrMap[e.code];<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;t.dataReport.addMsgInfo(s,{error:f.errorList[r].code,message:f.errorList[r].message}),t.dataReport.uploadReport(s),g.ClientUtil.unregisterCallback("kZegoTaskMixConfig",t.stateCenter.reportList),i(e)}</span>))}</span>))}</span>,t.prototype.stopMixerTask=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(r,i){var s=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(t.dataReport.newReport(s,f.eventList.kZegoTaskMixStop),!e||"string"!=typeof e)<span class="cstat-no" title="statement not covered" >return t.logger.error("zb.smt taskID error"),t.dataReport.addMsgInfo(s,{error:f.errorList.kInvalidParamError.code,message:f.errorList.kInvalidParamError.message+" param taskID error"}),void t.dataReport.uploadReport(s);<span class="cstat-no" title="statement not covered" >t</span></span>.streamHandler.stopMixStream(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.dataReport.uploadReport(s),r(e)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r;<span class="cstat-no" title="statement not covered" >console.error(e),(r=e.errorCode&lt;2e9?g.ClientUtil.mixServerError(e.errorCode-n.MIXSTREAM_ERROR_CODE):f.codeErrMap[e.errorCode])?t.dataReport.addMsgInfo(s,{error:f.errorList[r].code,message:f.errorList[r].message}):t.dataReport.addMsgInfo(s,{error:e.errorCode,message:"stop mixtask error"}),t.dataReport.uploadReport(s),i(e)}</span>))}</span>))}</span>,t.prototype.addPublishCdnUrl=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>return this.dataReport.newReport(i,f.eventList.kZegoTaskAddPublishCdnUrl),this.dataReport.addMsgInfo(i,{stream_id:e,signature:t,target_url:r}),this.publishTarget({type:"addpush",streamID:e,pushUrl:r,signature:t},i)}</span>,t.prototype.removePublishCdnUrl=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>return this.dataReport.newReport(i,f.eventList.kZegoTaskRemovePublishCdnUrl),this.dataReport.addMsgInfo(i,{stream_id:e,signature:t,target_url:r}),this.publishTarget({type:"delpush",streamID:e,pushUrl:r,signature:t},i)}</span>,t.prototype.clearPublishCdnUrl=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>return this.dataReport.newReport(i,f.eventList.kZegoTaskRemovePublishCdnUrl),this.dataReport.addMsgInfo(i,{stream_id:e,signature:t,target_url:r}),this.publishTarget({type:"clearpush",streamID:e,pushUrl:r,signature:t},i)}</span>,t.prototype.publishTarget=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(i,s){<span class="cstat-no" title="statement not covered" >if(!e.streamID||"string"!=typeof e.streamID)<span class="cstat-no" title="statement not covered" >return r.logger.error("zb.pt streamid error"),r.dataReport.addMsgInfo(t,{error:f.errorList.kInvalidParamError.code,message:f.errorList.kInvalidParamError.message+" streamid error"}),void r.dataReport.uploadReport(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.pushUrl||"string"!=typeof e.pushUrl)<span class="cstat-no" title="statement not covered" >return r.logger.error("zb.pt pushurl error"),r.dataReport.addMsgInfo(t,{error:f.errorList.kInvalidParamError.code,message:f.errorList.kInvalidParamError.message+" pushurl error"}),void r.dataReport.uploadReport(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.signature||"string"!=typeof e.signature)<span class="cstat-no" title="statement not covered" >return r.logger.error("zb.pt appSecret error"),r.dataReport.addMsgInfo(t,{error:f.errorList.kInvalidParamError.code,message:f.errorList.kInvalidParamError.message+" signature error"}),void r.dataReport.uploadReport(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(!r.stateCenter.publishStreamList[e.streamID])<span class="cstat-no" title="statement not covered" >return r.logger.error("zb.pt publish stream no found"),r.dataReport.addMsgInfo(t,{error:f.errorList.kPublishStreamNotFound.code,message:f.errorList.kPublishStreamNotFound.message}),void r.dataReport.uploadReport(t);<span class="cstat-no" title="statement not covered" >r</span></span>.streamHandler.publishTarget(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.dataReport.uploadReport(t),i(e)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){var i=<span class="cstat-no" title="statement not covered" >g.ClientUtil.getServerError(e.errorCode),</span>o=<span class="cstat-no" title="statement not covered" >g.ClientUtil.decodeServerError(i.code,i.msg);<span class="cstat-no" title="statement not covered" ></span>r.dataReport.addMsgInfo(t,{error:o.code,message:o.message}),r.dataReport.uploadReport(t),s(e)}</span>))}</span>))}</span>,t.prototype.setStreamExtraInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >m.getReportSeq();<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.newReport(r,f.eventList.kZegoTaskLiveRoomSendStreamExtraInfo),this.dataReport.addMsgInfo(r,{stream_id:e,stream_extra_info:t,room_sid:this.stateCenter.sessionid}),"string"!=typeof e||""==e)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.ssei streamID must be string and not empty"),this.dataReport.addMsgInfo(r,{error:f.errorList.kInvalidParamError.code,message:f.errorList.kInvalidParamError.message+" streamID must be string and not empty"}),this.dataReport.uploadReport(r),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f("string"!=typeof t||""==t)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.ssei extraInfo must be string and not empty"),this.dataReport.addMsgInfo(r,{error:f.errorList.kInvalidParamError.code,message:f.errorList.kInvalidParamError.message+" extraInfo must be string and not empty"}),this.dataReport.uploadReport(r),!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.streamHandler.updateStreamExtraInfo(e,t);<span class="cstat-no" title="statement not covered" ></span>return this.dataReport.uploadReport(r),i}</span>,t.prototype.bindListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.stateCenter.listenerList[e]?"function"!=typeof t?(this.logger.error("zc.o.0 listener callBack must be funciton"),!1):(-1==this.stateCenter.listenerList[e].indexOf(t)&amp;&amp;this.stateCenter.listenerList[e].push(t),!0):(this.logger.error("zc.o.0 event "+e+" no found"),!1)}</span>,t.prototype.deleteListener=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(!this.stateCenter.listenerList[e])<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.o.1 listener no found"),!1;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.stateCenter.listenerList[e];<span class="cstat-no" title="statement not covered" ></span>return t?r.splice(r.indexOf(t),1):this.stateCenter.listenerList[e]=[],!0}</span>,t.prototype.getVersion=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.PROTO_VERSION}</span>,t}(o.Common);t.BaseCenter=v},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(1),o=r(3),n=function(){function e(){}return e.prototype.getSocket=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null}</span>,e.prototype.setCDNInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.onPublishStateUpdateHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>0==e?this.stateCenter.publishStreamList[t]&amp;&amp;(this.stateCenter.publishStreamList[t].state==i.ENUM_PUBLISH_STREAM_STATE.tryPublish?(this.stateCenter.publishStreamList[t].state=i.ENUM_PUBLISH_STREAM_STATE.update_info,this.streamHandler.updateStreamInfo(t,i.ENUM_STREAM_SUB_CMD.liveBegin,this.stateCenter.publishStreamList[t].extra_info,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.stateCenter.publishStreamList[t]&amp;&amp;s.stateCenter.publishStreamList[t].state==i.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;(s.stateCenter.publishStreamList[t].state=i.ENUM_PUBLISH_STREAM_STATE.stop,s.streamHandler.onPublishStateUpdate(i.ENUM_PUBLISH_STATE_UPDATE.error,t,e),s.streamCenter.stopPlayingStream(t))}</span>))):(this.WebrtcOnPublishStateUpdateHandle(e,t,r),"xcx"==this.stateCenter.clientType&amp;&amp;(this.dataReport.uploadReport(this.stateCenter.reportSeqList.startPublish[t]),delete this.stateCenter.reportSeqList.startPublish[t],o.ClientUtil.unregisterCallback("kZegoTaskPublishStart"+t,this.stateCenter.reportList)))):(this.streamHandler.onPublishStateUpdate(e,t,r),1==e&amp;&amp;(this.logger.info("cb.cm.opsuh trigger internal stop publish stream"),this.stopPublishingStream(t,!0)))}</span>,e.prototype.WebrtcOnPublishStateUpdateHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.loginBodyData=<span class="fstat-no" title="function not covered" >fu</span>nction(){},e.prototype.resetStreamCenter=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.customUrl&amp;&amp;(this.stateCenter.customUrl=null),this.streamCenter.reset(),!this.socketCenter.isDisConnect())<span class="cstat-no" title="statement not covered" >for(var e in this.stateCenter.publishStreamList)<span class="cstat-no" title="statement not covered" >this.stateCenter.publishStreamList[e].state==i.ENUM_PUBLISH_STREAM_STATE.publishing&amp;&amp;this.streamHandler.updateStreamInfo(e,i.ENUM_STREAM_SUB_CMD.liveEnd,this.stateCenter.publishStreamList[e].extra_info)}</span></span></span>,e.prototype.handleFetchWebRtcUrlRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.body.stream_id,</span>r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(e.body.urls&amp;&amp;Array.isArray(e.body.urls)&amp;&amp;e.body.urls.length&gt;0?r=!0:this.logger.error("cb.cm.hfwur signal url is empty"),"push"===e.body.ptype)<span class="cstat-no" title="statement not covered" >!r&amp;&amp;this.streamHandler.onPublishStateUpdate(1,t,s.publishErrorList.DISPATCH_ERROR)&amp;&amp;this.stopPublishingStream(t),this.stateCenter.publishStreamList[t]?this.streamCenter.startPublishingStream(t,e.body.urls):this.logger.error("cb.cm.hfwur no streamid to publish");e</span>lse <span class="cstat-no" title="statement not covered" >if("pull"==e.body.ptype){<span class="cstat-no" title="statement not covered" >!r&amp;&amp;this.streamCenter.onPlayStateUpdate(1,t,s.playErrorList.DISPATCH_ERROR)&amp;&amp;this.stopPlayingStream(t);<span class="cstat-no" title="statement not covered" >f</span>or(var i=!1,o=0;o&lt;this.stateCenter.streamList.length;o++)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.streamList[o].stream_id===t){<span class="cstat-no" title="statement not covered" >i=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>0</span></span>==i&amp;&amp;this.logger.warn("cb.cm.hfwur cannot find stream, continue to play"),this.streamCenter.startPlayingStream(t,e.body.urls,this.streamCenter.playSuccessCallBackList[t])}</span>}</span></span>,e}();t.Common=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(3),o=function(){function e(e,t){var r=this;this.websocket=null,this.cmdSeq=0,this.responseRouters={},this.logger=e,this.stateCenter=t,this.responseRouters={push_kickout:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handlePushKickout(e)}</span>,push_custommsg:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handlePushCustomMsg(e)}</span>,push_im_chat:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handlePushRoomMsg(e)}</span>,push_userlist_update:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handlePushUserStateUpdateMsg(e)}</span>,push_merge_message:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handlePushMergeMsg(e)}</span>,trans:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handleTransRsp(e)}</span>,push_trans:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handlePushTransMsg(e)}</span>}}return e.prototype.handlePushKickout=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.handlePushCustomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.handlePushRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.handlePushUserStateUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.handlePushMergeMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.handlePushTransMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.handleBigImMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.handleTransRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(0==e.body.err_code){var t=<span class="cstat-no" title="statement not covered" >e.body.trans_type;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.transSeqMap[t]?(this.stateCenter.transSeqMap[t].seq=e.body.trans_seq,this.logger.debug("zb.sc.htr trans "+t+" seq "+e.body.trans_seq)):this.logger.error("zb.sc.htr cannot match send info")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sc.htr trans send error "+e.body.err_code);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sc.htr not login")}</span></span>,e.prototype.handleBizChannelRspCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >0===e.body.err_code?null!=t.success&amp;&amp;t.success(e.header.seq,e.body.cmd,e.body.rsp_body):null!=t.error&amp;&amp;t.error(e.body.err_code,e.header.seq,e.body.rsp_body)}</span>,e.prototype.registerRouter=function(e,t){this.responseRouters[e]=t},e.prototype.getSocket=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null}</span>,e.prototype.getHeaderV2=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{Protocol:"req_v2",cmd:e,appid:this.stateCenter.appid,seq:++this.cmdSeq,user_id:this.stateCenter.userid,session_id:this.stateCenter.sessionid||"",room_id:this.stateCenter.roomid||""}}</span>,e.prototype.getHeader=function(e){return{Protocol:"req",cmd:e,appid:this.stateCenter.appid,seq:++this.cmdSeq,user_id:this.stateCenter.userid,session_id:this.stateCenter.sessionid||"",room_id:this.stateCenter.roomid||<span class="branch-1 cbranch-no" title="branch not covered" >""}</span>},e.prototype.sendMessage=function(e,t,r,s){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.logger.debug("zb.sc.sm call "+e),this.isDisConnect())<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sc.sm error "+e+" websocket is disconnected"),-1;v</span>ar o="V1"===i.ROOMVERSION?this.getHeader(e):<span class="branch-1 cbranch-no" title="branch not covered" >this.getHeaderV2(e),</span>n={header:o,body:t};<span class="missing-if-branch" title="if path not taken" >I</span>if(null==r&amp;&amp;(r=null),null==s&amp;&amp;(s=null),null!=r||null!=s){var a=<span class="cstat-no" title="statement not covered" >{data:n,seq:o.seq,deleted:!1,time:Date.parse(new Date+""),success:r,error:s},</span>c=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendCommandList.push(a);<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.sendCommandMap[a.seq]=c}</span>return this.websocket&amp;&amp;this.websocket.send(JSON.stringify(n)),this.logger.debug("zb.sc.sm success"),o.seq},e.prototype.sendCustomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.sc.scm call"),this.isDisConnect())<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sc.scm error"),!1;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >"V1"===i.ROOMVERSION?this.getHeader(e):this.getHeaderV2(e),</span>n=<span class="cstat-no" title="statement not covered" >{header:o,body:t},</span>a=<span class="cstat-no" title="statement not covered" >JSON.stringify(n);<span class="cstat-no" title="statement not covered" ></span>null==r&amp;&amp;(r=null),null==s&amp;&amp;(s=null);v</span>ar c=<span class="cstat-no" title="statement not covered" >{data:n,seq:o.seq,deleted:!1,time:Date.parse(new Date+""),success:r,error:s},</span>d=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendDataList.push(c);<span class="cstat-no" title="statement not covered" ></span>return this.stateCenter.sendDataMap[c.seq]=d,this.websocket&amp;&amp;this.websocket.send(a),this.logger.debug("zb.sc.scm success seq: ",o.seq),!0}</span>,e.prototype.isDisConnect=function(){return!this.websocket||1!==this.websocket.readyState},e.prototype.closeSocket=function(){this.websocket&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.info("zb.sc.cs close websocket"),this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null)</span>},e.prototype.createSocket=function(e){this.websocket=this.getSocket(e)},e.prototype.openHandler=function(e){this.websocket&amp;&amp;(this.websocket.onopen=e)},e.prototype.closeHandler=function(e){this.websocket&amp;&amp;(this.websocket.onclose=e)},e.prototype.errorHandler=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.websocket&amp;&amp;(this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.error("zb.sc.oe msg="+JSON.stringify(t))}</span>)}</span>,e.prototype.checkResponse=function(e){return(e.header.appid!==this.stateCenter.appid||e.header.session_id!==this.stateCenter.sessionid||e.header.user_id!==this.stateCenter.userid||e.header.room_id!==this.stateCenter.roomid||this.stateCenter.runState!==i.ENUM_RUN_STATE.login)&amp;&amp;(<span class="branch-5 cbranch-no" title="branch not covered" >this.logger.error("zb.sc.crp check session fail."),!0)</span>},e.prototype.responseHandler=function(){var e=this;this.websocket&amp;&amp;(this.websocket.onmessage=function(t){var r=JSON.parse(t.data);e.logger.info("zb.sc.ws.rph jsonmsg= ",r.header.cmd),e.logger.info("zb.sc.ws.rph jsonmsg= ",t.data),0!==r.body.err_code&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r.body.err_message&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.logger.error("zb.sc.ws.rph cmd="+r.header.cmd+", err_code="+r.body.err_code+", err_message="+r.body.err_message+" "),</span>"login"!==r.header.cmd?"logout"!==r.header.cmd?e.stateCenter.isLogin()?e.checkResponse(r)?<span class="branch-0 cbranch-no" title="branch not covered" >e.logger.error("zb.sc.ws.rph check session fail."):</span>(e.handleSendCommandMsgRsp(r),e.logger.info("zb.sc.ws.rph cmd="+r.header.cmd+",function="+!!e.responseRouters[r.header.cmd]),e.responseRouters[r.header.cmd]&amp;&amp;e.responseRouters[r.header.cmd](r)):<span class="branch-1 cbranch-no" title="branch not covered" >e.logger.warn("zb.sc.ws.rph  already logout"):<span class="branch-1 cbranch-no" title="branch not covered" ></span>e.responseRouters.logout(r,e.cmdSeq):</span>e.responseRouters.login(r,e.cmdSeq)})},e.prototype.handleSendCommandMsgRsp=function(e){this.logger.debug("zb.sc.hscmr call");var t,r=this.stateCenter.sendCommandMap[e.header.seq];null!=r&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >"login"==(t=r._data).data.header.cmd?this.logger.debug("zb.sc.hscmr don't check "+t.data.header.cmd):"relay"==t.data.header.cmd?this.handleRelayRspCallback(e,t):"bigim_chat"==t.data.header.cmd?this.handleBigImRspCallback(e,t):"biz_channel"==t.data.header.cmd?this.handleBizChannelRspCallback(e,t):0===e.body.err_code?null!=t.success&amp;&amp;t.success(e.header.seq):null!=t.error&amp;&amp;t.error(s.ClientUtil.getServerError(e.body.err_code),e.header.seq),delete this.stateCenter.sendCommandMap[e.header.seq],this.stateCenter.sendCommandList.remove(r))</span>,this.logger.debug("zb.sc.hscmr call success")},e.prototype.handleRelayRspCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >0===e.body.err_code?null!=t.success&amp;&amp;t.success(e.header.seq,e.body.relay_result):null!=t.error&amp;&amp;t.error(s.ClientUtil.getServerError(e.body.err_code),e.header.seq)}</span>,e.prototype.handleBigImRspCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >0===e.body.err_code?null!=t.success&amp;&amp;this.handleBigImMsgRsp(e):null!=t.error&amp;&amp;t.error({errorCode:s.ClientUtil.getServerError(e.body.err_code).code,messageID:""})}</span>,e}();t.SocketCenter=o},function(e,t,r){"use strict";var i=this&amp;&amp;this.__spreadArrays||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=0,t=0,r=arguments.length;t&lt;r;t++)<span class="cstat-no" title="statement not covered" >e+=arguments[t].length;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Array(e),</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;r;t++)<span class="cstat-no" title="statement not covered" >for(var o=arguments[t],n=0,a=o.length;n&lt;a;n++,s++)<span class="cstat-no" title="statement not covered" >i[s]=o[n];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>;Object.defineProperty(t,"__esModule",{value:!0});var s=r(0),o=r(3),n=r(1),a=r(2),c=function(){function e(e,t,r){this.logger=e,this.socketCenter=r,this.stateCenter=t}return e.prototype.setRunState=function(e){this.logger.debug("zb.rh.srs old="+this.stateCenter.runState+", new="+e),this.stateCenter.lastRunState=this.stateCenter.runState,this.stateCenter.runState=e},e.prototype.resetTryLogin=function(){this.logger.debug("zb.rh.rtl call"),clearTimeout(this.stateCenter.tryLoginTimer),this.stateCenter.tryLoginTimer=null,this.stateCenter.tryLoginCount=0,this.logger.debug("zb.rh.rtl call success")},e.prototype.resetBigRoomInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.stateCenter.transSeqMap={},this.stateCenter.realyMessageList=[],this.stateCenter.relayTimer&amp;&amp;(clearTimeout(this.stateCenter.relayTimer),this.stateCenter.relayTimer=null),this.stateCenter.bigImLastTimeIndex=0,this.stateCenter.bigIMmessageList=[],this.stateCenter.bigImCallbackMap={},this.stateCenter.bigImTimer&amp;&amp;(clearTimeout(this.stateCenter.bigImTimer),this.stateCenter.bigImTimer=null),this.stateCenter.serverTimeOffset=0,this.stateCenter.datiTimeWindow=0,this.stateCenter.bigimTimeWindow=0}</span>,e.prototype.resetRoom=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zb.rh.rr call"),this.resetTryLogin(),this.resetRoomCallBack(),this.stateCenter.streamList=[],this.stateCenter.streamQuerying=!1,this.stateCenter.publishStreamList={},this.stateCenter.joinLiveCallbackMap={},this.stateCenter.joinLiveRequestMap={},this.stateCenter.streamUrlMap={},this.resetBigRoomInfo(),this.stateCenter.cmdCallback={},this.logger.debug("zb.rh.rr call send logout=",this.stateCenter.sessionid),"0"!==this.stateCenter.sessionid&amp;&amp;this.stateCenter.runState!==s.ENUM_RUN_STATE.logout){<span class="cstat-no" title="statement not covered" >this.socketCenter.registerRouter("logout",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.handleLogoutRsp(e)}</span>)),this.socketCenter.sendMessage("logout",{reserve:0})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.socketCenter.closeSocket(),this.setRunState(s.ENUM_RUN_STATE.logout),this.stateCenter.userid="",this.stateCenter.sessionid="",this.logger.setSessionInfo(this.stateCenter.appid,this.stateCenter.roomid,this.stateCenter.sessionid,this.stateCenter.idName,this.stateCenter.nickName,s.PROTO_VERSION),this.logger.debug("zb.rh.rr call success")}</span>,e.prototype.resetRoomCallBack=<span class="fstat-no" title="function not covered" >fu</span>nction(){},e.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.onConnecting=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.loginSuccessCallBack=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.login=function(e,t,r,i,a,c){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.logger.setSessionInfo(this.stateCenter.appid,e,"",r.userID,"",s.PROTO_VERSION),this.logger.info("zb.rh.lg call:",e,t),i&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >i.userUpdate&amp;&amp;"boolean"==typeof i.userUpdate&amp;&amp;(this.stateCenter.userStateUpdate=i.userUpdate),i.maxMemberCount&amp;&amp;"number"==typeof i.maxMemberCount&amp;&amp;(this.stateCenter.maxMemberCount=i.maxMemberCount))</span>,!this.stateCenter.configOK)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.rh.lg init sdk wrong"),void c(n.commonErrorList.INIT);t</span>his.stateCenter.runState!==s.ENUM_RUN_STATE.logout&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.debug("zb.rh.lg reset"),this.setRunState(s.ENUM_RUN_STATE.logout),this.resetRoom())</span>,this.logger.debug("zb.rh.lg begin"),this.setRunState(s.ENUM_RUN_STATE.trylogin),this.stateCenter.roomid=e,this.stateCenter.token=t,this.stateCenter.third_token=t,this.stateCenter.idName=r.userID,this.stateCenter.nickName=r.userName,o.ClientUtil.registerCallback("login",{success:a,error:c},this.stateCenter.callbackList),this.resetTryLogin(),this.onConnecting({code:0,msg:""}),this.tryLogin(),this.logger.info("zb.rh.lg call success")},e.prototype.loginBodyData=<span class="fstat-no" title="function not covered" >fu</span>nction(){},e.prototype.tryLogin=function(){var e=this;<span class="missing-if-branch" title="else path not taken" >E</span>if(this.logger.debug("zb.rh.tl call"),this.stateCenter.runState===s.ENUM_RUN_STATE.trylogin){<span class="missing-if-branch" title="if path not taken" >I</span>if(++this.stateCenter.tryLoginCount&gt;s.MAX_TRY_LOGIN_COUNT){<span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.tl fail times limit");v</span>ar t=<span class="cstat-no" title="statement not covered" >this.stateCenter.lastRunState;<span class="cstat-no" title="statement not covered" ></span>return this.setRunState(s.ENUM_RUN_STATE.logout),this.resetRoom(),void(t==s.ENUM_RUN_STATE.login?(this.logger.error("zb.rh.tl fail and disconnect"),this.onDisconnect(s.sdkErrorList.LOGIN_DISCONNECT)):(this.logger.info("zb.rh.tl fail and callback user"),o.ClientUtil.actionErrorCallback("login",this.stateCenter.callbackList)(n.liveRoomErrorList.FREQ_LIMITED)))}</span>this.stateCenter.startConnceTime=(new Date).getTime(),console.warn("start connect",this.stateCenter.startConnceTime);var r=0!==this.stateCenter.reportSeqList.login?"kZegoTaskLoginRoom":<span class="branch-1 cbranch-no" title="branch not covered" >"kZegoTaskReLoginRoom";<span class="missing-if-branch" title="else path not taken" >E</span></span>if(this.socketCenter.isDisConnect()){this.logger.debug("zb.rh.tl need new websocket");try{this.socketCenter.closeSocket(),this.logger.debug("zb.rh.tl new websocket");var i=this.stateCenter.tryLoginCount%2==1?this.stateCenter.server:<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.serverBak;</span>o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)&amp;&amp;(this.stateCenter.tryLoginCount&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)(a.REPORT_ACTION.eventEnd,"create_socket"),</span>o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)(a.REPORT_ACTION.eventStart,"create_socket"),o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)(a.REPORT_ACTION.addEventMsg,"create_socket","server",i)),this.socketCenter.createSocket(i),this.socketCenter.registerRouter("login",(function(t,r){e.handleLoginRsp(t,r)})),this.socketCenter.closeHandler((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.socketCenter.closeSocket(),e.closeHandler(t)}</span>)),this.socketCenter.openHandler((function(){e.openHandler()}))}catch(e){<span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.tl websocket err:"+e)}</span>}else{var c=<span class="cstat-no" title="statement not covered" >this.loginBodyData();<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.rh.tl use current websocket and sent login"),o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)&amp;&amp;o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)(a.REPORT_ACTION.eventStart,"liveroom_login"),this.socketCenter.sendMessage("login",c)}</span>this.stateCenter.tryLoginTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.tryLogin()}</span>),s.TRY_LOGIN_INTERVAL[this.stateCenter.tryLoginCount%s.MAX_TRY_LOGIN_COUNT]),this.logger.info("zb.rh.tl call success")}else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.tl state error")}</span>,e.prototype.handleLoginRsp=function(e,t){this.logger.debug("zb.rh.hlr call");var r=0!==this.stateCenter.reportSeqList.login?"kZegoTaskLoginRoom":<span class="branch-1 cbranch-no" title="branch not covered" >"kZegoTaskReLoginRoom";<span class="missing-if-branch" title="else path not taken" >E</span></span>if(o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)&amp;&amp;o.ClientUtil.actionSuccessCallback(r,this.stateCenter.reportList)(a.REPORT_ACTION.eventEndWithMsgInfo,"liveroom_login"),this.stateCenter.runState===s.ENUM_RUN_STATE.trylogin){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.header.seq===t)return 0!==e.body.err_code?(<span class="branch-0 cbranch-no" title="branch not covered" >this.handleLoginFail(e),void this.logger.error("zb.rh.hlr server error=",e.body.err_code))</span>:(this.handleLoginSuccess(e),void this.logger.info("zb.rh.hlr call success."));<span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.hlr in wrong seq, local=",t,",recv=",e.header.seq)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.hlr state error")}</span>,e.prototype.handleLoginFail=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.rh.hlf call"),o.ClientUtil.isKeepTryLogin(e.body.err_code))<span class="cstat-no" title="statement not covered" >this.logger.warn("zb.rh.hlf KeepTry true");e</span>lse{var t=<span class="cstat-no" title="statement not covered" >this.stateCenter.lastRunState;<span class="cstat-no" title="statement not covered" ></span>this.setRunState(s.ENUM_RUN_STATE.logout),this.resetRoom();v</span>ar r=<span class="cstat-no" title="statement not covered" >o.ClientUtil.getServerError(e.body.err_code);<span class="cstat-no" title="statement not covered" ></span>t===s.ENUM_RUN_STATE.login?(this.logger.info("zb.rh.hlf callback disconnect"),this.onDisconnect(r)):(this.logger.info("zb.rh.hlf callback error"),o.ClientUtil.actionErrorCallback("login",this.stateCenter.callbackList)(r)),this.logger.debug("zb.rh.hlf call success")}</span>}</span>,e.prototype.handleLoginSuccess=function(e){this.stateCenter.startloginSucTime=(new Date).getTime(),console.warn("login suc",this.stateCenter.startloginSucTime,this.stateCenter.startloginSucTime-this.stateCenter.startloginTime,this.stateCenter.startloginSucTime-this.stateCenter.startConnceTime),this.logger.info("zb.rh.hls call");var t={},r=this.stateCenter.lastRunState;<span class="missing-if-branch" title="else path not taken" >E</span>if(this.setRunState(s.ENUM_RUN_STATE.login),this.stateCenter.userid=e.body.user_id,this.stateCenter.sessionid=e.body.session_id,this.stateCenter.anchor_info=e.body.anchor_info||<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.anchor_info,</span>this.stateCenter.userListInterval=e.body.userlist_interval||<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.userListInterval,</span>this.stateCenter.userListMergeInterval=e.body.userlist_merge_timeout||<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.userListMergeInterval,</span>this.logger.setSessionInfo(this.stateCenter.appid,this.stateCenter.roomid,this.stateCenter.sessionid,this.stateCenter.idName,this.stateCenter.nickName,s.PROTO_VERSION),e.body.config_info&amp;&amp;(this.logger.setRemoteLogLevel(e.body.config_info.log_level),t.log_level=e.body.config_info.log_level,""!=e.body.config_info.log_url&amp;&amp;(this.logger.openLogServer(e.body.config_info.log_url),t.log_url=e.body.config_info.log_url)),null!=e.body.ret_timestamp&amp;&amp;"string"==typeof e.body.ret_timestamp){var i=parseFloat(e.body.ret_timestamp);this.stateCenter.serverTimeOffset=0==i?<span class="branch-0 cbranch-no" title="branch not covered" >0:</span>e.body.ret_timestamp-(new Date).getTime()}e.body.bigim_time_window&amp;&amp;"number"==typeof e.body.bigim_time_window&amp;&amp;(this.stateCenter.bigimTimeWindow=e.body.bigim_time_window),e.body.dati_time_window&amp;&amp;"number"==typeof e.body.dati_time_window&amp;&amp;(this.stateCenter.datiTimeWindow=e.body.dati_time_window),e.body.cluster_env&amp;&amp;1===e.body.cluster_env&amp;&amp;(this.stateCenter.testEnvironment=!0,t.test_environment="true",!this.stateCenter.debugCustom&amp;&amp;(this.stateCenter.debug=!0));var n=0!==this.stateCenter.reportSeqList.login?"kZegoTaskLoginRoom":<span class="branch-1 cbranch-no" title="branch not covered" >"kZegoTaskReLoginRoom";</span>o.ClientUtil.actionSuccessCallback(n,this.stateCenter.reportList)&amp;&amp;o.ClientUtil.actionSuccessCallback(n,this.stateCenter.reportList)(a.REPORT_ACTION.addEventMsg,"liveroom_login","respond_info",t),this.resetTryLogin(),this.loginSuccessCallBack(r,e)},e.prototype.openHandler=function(){this.logger.info("zb.rh.oh websocket.onpen call");var e=0!==this.stateCenter.reportSeqList.login?"kZegoTaskLoginRoom":<span class="branch-1 cbranch-no" title="branch not covered" >"kZegoTaskReLoginRoom";</span>o.ClientUtil.actionSuccessCallback(e,this.stateCenter.reportList)&amp;&amp;o.ClientUtil.actionSuccessCallback(e,this.stateCenter.reportList)(a.REPORT_ACTION.eventEndWithMsgInfo,"create_socket",{try_cnt:this.stateCenter.tryLoginCount}),this.socketCenter.responseHandler();var t=this.loginBodyData();this.logger.info("zb.rh.oh websocket.onpen send login"),this.stateCenter.startloginTime=(new Date).getTime(),console.warn("start login",this.stateCenter.startloginTime,this.stateCenter.startloginTime-this.stateCenter.startConnceTime),o.ClientUtil.actionSuccessCallback(e,this.stateCenter.reportList)&amp;&amp;o.ClientUtil.actionSuccessCallback(e,this.stateCenter.reportList)(a.REPORT_ACTION.eventStart,"liveroom_login"),this.socketCenter.sendMessage("login",t),this.logger.debug("zb.rh.oh websocket.onpen call success")},e.prototype.closeHandler=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.rh.ws.oc msg="+JSON.stringify(e)),this.stateCenter.runState!==s.ENUM_RUN_STATE.logout?this.stateCenter.runState===s.ENUM_RUN_STATE.trylogin&amp;&amp;this.stateCenter.tryLoginCount&lt;=s.MAX_TRY_LOGIN_COUNT?this.logger.info("zb.rh.ws.oc is called because of try login"):this.stateCenter.runState===s.ENUM_RUN_STATE.login?(this.logger.info("zb.rh.ws.oc is called because of network broken, try again"),this.setRunState(s.ENUM_RUN_STATE.trylogin),this.resetTryLogin(),this.onConnecting({code:0,msg:""}),this.tryLogin()):(this.logger.error("zb.rh.ws.oc out of think!!!"),this.setRunState(s.ENUM_RUN_STATE.logout),this.resetRoom(),this.onDisconnect(s.sdkErrorList.UNKNOWN)):this.logger.info("zb.rh.ws.oc onclose logout flow call websocket.close")}</span>,e.prototype.logout=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.rh.lo call"),this.stateCenter.runState!==s.ENUM_RUN_STATE.logout?(this.resetRoom(e),this.logger.info("zb.rh.lo call success")):this.logger.warn("zb.rh.lo at logout")}</span>,e.prototype.fetchUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.rh.ful call"),this.stateCenter.userQuerying?this.logger.warn("zb.rh.ful is already querying"):(this.stateCenter.userQuerying=!0,this.stateCenter.userTempList=[],"V1"===s.ROOMVERSION?this.fetchUserListWithPage(0,e||0):this.fetchUserListWithPageV2(0),this.logger.info("zb.rh.ful the first time call"))}</span>,e.prototype.fetchUserListWithPageV2=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.rh.fulwp call"),this.socketCenter.registerRouter("user_list_v2",(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >t.handleFetchUserListRspV2(e,r)}</span>)),this.socketCenter.sendMessage("user_list_v2",{marker:0===e?"":e+"",mode:0,limit:100}),this.logger.info("zb.rh.fulwp call success")}</span>,e.prototype.fetchUserListWithPage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.rh.fulwp call"),this.socketCenter.registerRouter("user_list",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handleFetchUserListRsp(e,t)}</span>)),this.socketCenter.sendMessage("user_list",{user_index:e,sort_type:0}),this.logger.info("zb.rh.fulwp call success")}</span>,e.prototype.handleFetchUserListRspV2=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.rh.hfulr call"),0!=t.body.err_code)<span class="cstat-no" title="statement not covered" >return this.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,void this.logger.info("zb.rh.hfulr fetch error "+t.body.err_code);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.stateCenter.userStateUpdate){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.userTempList=i(this.stateCenter.userTempList,t.body.user_baseinfos),e!=t.body.marker)<span class="cstat-no" title="statement not covered" >return this.logger.warn("zb.rh.hfulr fetch another page"),void this.fetchUserListWithPageV2(e+1);<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.userSeq=t.body.server_user_seq,this.logger.info("zb.rh.hfulr set user Seq "+this.stateCenter.userSeq);<span class="cstat-no" title="statement not covered" >f</span>or(var r=[],s=0;s&lt;this.stateCenter.userTempList.length;s++){var o=<span class="cstat-no" title="statement not covered" >{userId:this.stateCenter.userTempList[s].id_name,userName:this.stateCenter.userTempList[s].nick_name};<span class="cstat-no" title="statement not covered" ></span>r.push(o)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,this.stateCenter.userTempList=[],this.logger.info("zb.rh.hfulr call success user_list "+r+" count "+r.length)}</span>}</span>,e.prototype.handleFetchUserListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zb.rh.hfulr call"),0!=e.body.err_code)<span class="cstat-no" title="statement not covered" >return this.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,void this.logger.info("zb.rh.hfulr fetch error "+e.body.err_code);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.stateCenter.userStateUpdate){<span class="cstat-no" title="statement not covered" >this.stateCenter.userTempList=i(this.stateCenter.userTempList,e.body.user_baseinfos);v</span>ar n=<span class="cstat-no" title="statement not covered" >e.body.ret_user_index;<span class="cstat-no" title="statement not covered" ></span>if(n!=e.body.server_user_index)<span class="cstat-no" title="statement not covered" >return this.logger.warn("zb.rh.hfulr fetch another page"),void this.fetchUserListWithPage(n+1,t);<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.userSeq=e.body.server_user_seq,this.logger.info("zb.rh.hfulr set user Seq "+this.stateCenter.userSeq);<span class="cstat-no" title="statement not covered" >f</span>or(var a=[],c=0;c&lt;this.stateCenter.userTempList.length;c++){var d=<span class="cstat-no" title="statement not covered" >{userID:this.stateCenter.userTempList[c].id_name,userName:this.stateCenter.userTempList[c].nick_name};<span class="cstat-no" title="statement not covered" ></span>a.push(d)}<span class="cstat-no" title="statement not covered" ></span>t</span>==s.ENUM_RUN_STATE.login?(o.ClientUtil.mergeUserList(this.logger,this.stateCenter.userList,a,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >0!==e.length&amp;&amp;r.onUserStateUpdate(r.stateCenter.roomid,"ADD",e),0!==t.length&amp;&amp;r.onUserStateUpdate(r.stateCenter.roomid,"DELETE",t)}</span>)),this.stateCenter.userList=a):(this.stateCenter.userList=a,0!==a.length&amp;&amp;this.onUserStateUpdate(this.stateCenter.roomid,"ADD",a)),this.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,this.stateCenter.userTempList=[],this.logger.info("zb.rh.hfulr call success user_list "+a+" count "+a.length)}</span>}</span>,e.prototype.handleLogoutRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.rh.hlor result=",e.body.err_code)}</span>,e.prototype.handlePushUserStateUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.rh.hpus call"),this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(this.stateCenter.userStateUpdate)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.userSeq+e.body.user_actions.length===e.body.user_list_seq){<span class="cstat-no" title="statement not covered" >this.stateCenter.userSeq=e.body.user_list_seq,this.logger.debug("zb.rh.hpus push userSeq "+this.stateCenter.userSeq);<span class="cstat-no" title="statement not covered" >f</span>or(var t=[],r=0;r&lt;e.body.user_actions.length;r++){var i=<span class="cstat-no" title="statement not covered" >{action:e.body.user_actions[r].Action,idName:e.body.user_actions[r].IdName,nickName:e.body.user_actions[r].NickName,loginTime:e.body.user_actions[r].LoginTime};<span class="cstat-no" title="statement not covered" ></span>t.push(i)}</span>v</span>ar s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >1==e.action?s.push({userID:e.idName,userName:e.nickName}):2==e.action&amp;&amp;o.push({userID:e.idName,userName:e.nickName})}</span>)),this.stateCenter.userList=this.stateCenter.userList.concat(s).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!o.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.userID==e.userID}</span>))}</span>)),0!==s.length&amp;&amp;this.onUserStateUpdate(e.body.room_id,"ADD",s),0!==o.length&amp;&amp;this.onUserStateUpdate(e.body.room_id,"DELETE",o),this.logger.info("zb.rh.hpus call success")}</span>else <span class="cstat-no" title="statement not covered" >this.mergeUserByUserSeq(e.body.user_list_seq,e.body.user_actions);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.info("zb.rh.hpus no userStateUpdate flag");e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.hpus not login")}</span></span>,e.prototype.onUserStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.mergeUserByUserSeq=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.userSeqMergeMap||(this.logger.warn("zb.rh.hpus new merge userlist "+this.stateCenter.userSeq+" server "+e),this.stateCenter.userSeqMergeMap={},this.stateCenter.userSeqMergeTimer&amp;&amp;clearTimeout(this.stateCenter.userSeqMergeTimer),this.stateCenter.userSeqMergeTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >Object.keys(r.stateCenter.userSeqMergeMap).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return+e}</span>)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e-t}</span>));<span class="cstat-no" title="statement not covered" ></span>if(e[e.length-1]-e[0]+1===e.length)<span class="cstat-no" title="statement not covered" >r.mergeUser(e);e</span>lse{<span class="cstat-no" title="statement not covered" >r.stateCenter.userSeqMergeMap=null;v</span>ar t=<span class="cstat-no" title="statement not covered" >r.stateCenter.lastUserQueryTime-Date.now();<span class="cstat-no" title="statement not covered" ></span>r.logger.info("zb.rh.hpus fetch merge userlist "+r.stateCenter.userSeq+" userSeqList "+e.join(",")+" wait "+t),t&gt;0?(r.stateCenter.userQueryTimer&amp;&amp;clearTimeout(r.stateCenter.userQueryTimer),r.stateCenter.userQueryTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >r.fetchUserList()}</span>),t)):r.fetchUserList()}</span>}</span>),this.stateCenter.userListMergeInterval)),this.logger.warn("zb.rh.hpus merge userlist "+this.stateCenter.userSeq+" server "+e+" userlist "+t.length),this.stateCenter.userSeqMergeMap[e]=t}</span>,e.prototype.mergeUser=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.rh.hpus merge userlist "+this.stateCenter.userSeq+" userSeqList "+e.join(",")),this.stateCenter.userSeq=e[e.length-1];v</span>ar r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.stateCenter.userSeqMergeMap[e].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r[e.IdName]=e}</span>))}</span>)),this.stateCenter.userSeqMergeMap=null;v</span>ar i=<span class="cstat-no" title="statement not covered" >Object.values(r).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{action:e.Action,idName:e.IdName,nickName:e.NickName,role:e.Role,loginTime:e.LoginTime?String(e.LoginTime):""}}</span>));<span class="cstat-no" title="statement not covered" ></span>i.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.loginTime.localeCompare(t.loginTime)}</span>));v</span>ar s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >1==e.action?s.push({userID:e.idName,userName:e.nickName}):2==e.action&amp;&amp;o.push({userID:e.idName,userName:e.nickName})}</span>)),this.stateCenter.userList=this.stateCenter.userList.concat(s).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!o.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.userID==e.userID}</span>))}</span>)),0!==s.length&amp;&amp;this.onUserStateUpdate(this.stateCenter.roomid,"ADD",s),0!==o.length&amp;&amp;this.onUserStateUpdate(this.stateCenter.roomid,"DELETE",o)}</span>,e}();t.RoomHandler=c},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(3),o=r(1),n=r(2),a=function(){function e(e,t,r,i){this.logger=e,this.socketCenter=r,this.stateCenter=t,this.dataReport=i}return e.prototype.setCDNInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.onStreamUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.onStreamExtraInfoUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.handleStreamStart=function(e,t){var r=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(this.stateCenter.streamQuerying=!1,this.socketCenter.registerRouter("stream",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handleStreamUpdateRsp(e)}</span>)),this.socketCenter.registerRouter("push_stream_update",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handlePushStreamUpdateMsg(e)}</span>)),this.stateCenter.reportSeqList.relogin&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.dataReport.uploadReport(this.stateCenter.reportSeqList.relogin),this.stateCenter.reportSeqList.relogin=0,s.ClientUtil.unregisterCallback("kZegoTaskReLoginRoom",this.stateCenter.reportList))</span>,this.stateCenter.actionListener("roomStateUpdate",this.stateCenter.roomid,"CONNECTED",0,""),e==i.ENUM_RUN_STATE.login)<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hss recover from disconnect so call streamupdate"),this.handleFullUpdateStream(t.body.stream_seq,t.body.stream_info||[]);e</span>lse{this.logger.info("zb.sh.hss success callback user"),this.stateCenter.streamList=t.body.stream_info||<span class="branch-1 cbranch-no" title="branch not covered" >[],</span>this.stateCenter.streamSeq=t.body.stream_seq;for(var o=0;o&lt;this.stateCenter.streamList.length;o++)<span class="cstat-no" title="statement not covered" >this.stateCenter.streamList[o].anchor_id_name==this.stateCenter.idName&amp;&amp;(this.updateStreamInfo(this.stateCenter.streamList[o].stream_id,i.ENUM_STREAM_SUB_CMD.liveEnd),this.stateCenter.streamList.splice(o--,1));v</span>ar n=this.makeCallbackStreamList(this.stateCenter.streamList).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{streamID:e.streamID,user:e.user,extraInfo:e.extraInfo,urlsFLV:e.urlFlv,urlsRTMP:e.urlRtmp,urlsHLS:e.urlHls,urlsHttpsFLV:e.urlHttpsFlv,urlsHttpsHLS:e.urlHttpsHls}}</span>));s.ClientUtil.actionSuccessCallback("login",this.stateCenter.callbackList)&amp;&amp;s.ClientUtil.actionSuccessCallback("login",this.stateCenter.callbackList)(!0),n.length&gt;0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.onStreamUpdated(this.stateCenter.roomid,i.ENUM_STREAM_UPDATE_TYPE.added,n)}</span>},e.prototype.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.updateStreamInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){var s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>void 0===r&amp;&amp;(r=""),this.logger.debug("zb.sh.usi call");v</span>ar o=<span class="cstat-no" title="statement not covered" >{stream_id:e,extra_info:r},</span>n=<span class="cstat-no" title="statement not covered" >{sub_cmd:t,stream_msg:JSON.stringify(o)};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.registerRouter("stream",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >s.handleStreamUpdateRsp(e)}</span>)),this.socketCenter.sendMessage("stream",n,void 0,i),this.logger.info("zb.sh.usi call success cmd "+t)}</span>,e.prototype.handleStreamUpdateRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(0==e.body.err_code){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hsur stream seq "+this.stateCenter.streamSeq+" server seq "+e.body.stream_seq),this.stateCenter.streamSeq=e.body.stream_seq;<span class="cstat-no" title="statement not covered" >f</span>or(var t=0;t&lt;e.body.stream_info.length;t++){var r=<span class="cstat-no" title="statement not covered" >e.body.stream_info[t].stream_id;<span class="cstat-no" title="statement not covered" ></span>if(!this.stateCenter.publishStreamList[r])<span class="cstat-no" title="statement not covered" >return void this.logger.info("hsur.0 stream is not exist");<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.publishStreamList[r].state==i.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;(this.stateCenter.publishStreamList[r].state=i.ENUM_PUBLISH_STREAM_STATE.publishing,this.onPublishStateUpdate(0,r,{code:0,msg:""}))}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.hsur stream update error "+e.body.err_code);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.hsur not login")}</span></span>,e.prototype.handleFetchStreamListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hfslr call"),this.stateCenter.streamQuerying=!1,0===e.body.err_code?this.stateCenter.streamSeq!==e.body.stream_seq?(this.handleFullUpdateStream(e.body.stream_seq,e.body.stream_info),this.logger.debug("zb.sh.hfslr call success")):this.logger.info("zb.sh.hfslr same seq"):this.logger.info("zb.sh.hfslr server error=",e.body.err_code)}</span>,e.prototype.handleFullUpdateStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.sh.hfus call"),this.stateCenter.streamSeq=e,this.logger.debug("zb.sh.hfus server seq "+this.stateCenter.streamSeq),s.ClientUtil.mergeStreamList(this.logger,this.stateCenter.idName,this.stateCenter.streamList,t,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,s){<span class="cstat-no" title="statement not covered" >0!==e.length&amp;&amp;(r.logger.debug("zb.sh.hfus callback addstream"),r.onStreamUpdated(r.stateCenter.roomid,i.ENUM_STREAM_UPDATE_TYPE.added,r.makeCallbackStreamList(e))),0!==t.length&amp;&amp;(r.logger.debug("zb.sh.hfus callback delstream"),r.onStreamUpdated(r.stateCenter.roomid,i.ENUM_STREAM_UPDATE_TYPE.deleted,r.makeCallbackStreamList(t))),0!==s.length&amp;&amp;(r.logger.debug("zb.sh.hfus callback updatestream"),r.onStreamExtraInfoUpdated(r.stateCenter.roomid,r.makeCallbackStreamList(s)))}</span>)),this.logger.info("zb.sh.hfus call success")}</span>,e.prototype.handlePushStreamUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.sh.hpsum call"),e.body.stream_info&amp;&amp;0!==e.body.stream_info.length){<span class="cstat-no" title="statement not covered" >if(e.body.stream_info.length+this.stateCenter.streamSeq!==e.body.stream_seq)<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.sh.hpsum call updatestream"),void this.fetchStreamList();<span class="cstat-no" title="statement not covered" >s</span></span>witch(this.stateCenter.streamSeq=e.body.stream_seq,e.body.stream_cmd){case i.ENUM_STREAM_UPDATE_CMD.added:<span class="cstat-no" title="statement not covered" >this.handleAddedStreamList(e.body.stream_info);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.ENUM_STREAM_UPDATE_CMD.deleted:<span class="cstat-no" title="statement not covered" >this.handleDeletedStreamList(e.body.stream_info);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.ENUM_STREAM_UPDATE_CMD.updated:<span class="cstat-no" title="statement not covered" >this.handleUpdatedStreamList(e.body.stream_info)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.info("zb.sh.hpsum call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hpsum, emtpy list")}</span></span>,e.prototype.handleAddedStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hasl call");<span class="cstat-no" title="statement not covered" >f</span>or(var t,r=[],s=0;s&lt;e.length;s++)<span class="cstat-no" title="statement not covered" >if(e[s].anchor_id_name!=this.stateCenter.idName){<span class="cstat-no" title="statement not covered" >t=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var o=0;o&lt;this.stateCenter.streamList.length;o++)<span class="cstat-no" title="statement not covered" >if(e[s].stream_id===this.stateCenter.streamList[o].stream_id){<span class="cstat-no" title="statement not covered" >t=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span></span>||r.push(e[s])}</span>else <span class="cstat-no" title="statement not covered" >this.logger.debug("hdsl.0 have self stream added");<span class="cstat-no" title="statement not covered" >i</span></span></span>f(0!==r.length){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hasl callback addstream");<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;r.length;n++)<span class="cstat-no" title="statement not covered" >this.stateCenter.streamList.push(r[n]);<span class="cstat-no" title="statement not covered" >t</span></span>his.onStreamUpdated(this.stateCenter.roomid,i.ENUM_STREAM_UPDATE_TYPE.added,this.makeCallbackStreamList(r))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.info("zb.sh.hasl call success")}</span>,e.prototype.handleDeletedStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hdsl call");<span class="cstat-no" title="statement not covered" >f</span>or(var t=[],r=0;r&lt;e.length;r++)<span class="cstat-no" title="statement not covered" >if(e[r].anchor_id_name!=this.stateCenter.idName){<span class="cstat-no" title="statement not covered" >for(var s=this.stateCenter.streamList.length-1;s&gt;=0;s--)<span class="cstat-no" title="statement not covered" >if(e[r].stream_id===this.stateCenter.streamList[s].stream_id){<span class="cstat-no" title="statement not covered" >this.stateCenter.streamList.splice(s,1),t.push(e[r]);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hdsl have self stream deleted");<span class="cstat-no" title="statement not covered" >0</span></span></span>!==t.length&amp;&amp;(this.logger.debug("zb.sh.hdsl callback delstream"),this.onStreamUpdated(this.stateCenter.roomid,i.ENUM_STREAM_UPDATE_TYPE.deleted,this.makeCallbackStreamList(t))),this.logger.info("zb.sh.hdsl call")}</span>,e.prototype.handleUpdatedStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.husl call");<span class="cstat-no" title="statement not covered" >f</span>or(var t=[],r=0;r&lt;e.length;r++)<span class="cstat-no" title="statement not covered" >if(e[r].anchor_id_name!=this.stateCenter.idName){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;this.stateCenter.streamList.length;i++)<span class="cstat-no" title="statement not covered" >if(e[r].stream_id===this.stateCenter.streamList[i].stream_id){<span class="cstat-no" title="statement not covered" >e[r].extra_info!==this.stateCenter.streamList[i].extra_info&amp;&amp;(this.stateCenter.streamList[i]=e[r],t.push(e[r]));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.debug("hsul.0 have self stream updated");<span class="cstat-no" title="statement not covered" >0</span></span></span>!==t.length&amp;&amp;(this.logger.debug("zb.sh.husl callback updatestream"),this.onStreamExtraInfoUpdated(this.stateCenter.roomid,this.makeCallbackStreamList(t))),this.logger.info("zb.sh.husl call success")}</span>,e.prototype.fetchStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.sh.fsl call"),this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(this.stateCenter.streamQuerying)<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.fsl already doing");e</span>lse{<span class="cstat-no" title="statement not covered" >this.stateCenter.streamQuerying=!0,this.logger.debug("zb.sh.fsl send fetch request");<span class="cstat-no" title="statement not covered" >t</span>his.socketCenter.registerRouter("stream_info",this.handleFetchStreamListRsp),this.socketCenter.sendMessage("stream_info",{reserve:0}),this.logger.debug("zb.sh.fsl call success")}</span>e</span>lse <span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.fsl state error")}</span></span>,e.prototype.makeCallbackStreamList=function(e){var t=[];<span class="missing-if-branch" title="if path not taken" >I</span>if(e&amp;&amp;e.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var r=0;r&lt;e.length;r++){var i=<span class="cstat-no" title="statement not covered" >{user:{userID:e[r].anchor_id_name,userName:e[r].anchor_nick_name},extraInfo:e[r].extra_info,streamID:e[r].stream_id,roomID:"",urlFlv:"",urlRtmp:"",urlHls:"",urlHttpsFlv:"",urlHttpsHls:""};<span class="cstat-no" title="statement not covered" ></span>this.setCDNInfo(i,e[r]),t.push(i)}</span>r</span>eturn t},e.prototype.updateMixStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var a,c=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.sh.ums call");<span class="cstat-no" title="statement not covered" >i</span>f(!e.taskID)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no taskId found"),r({errorCode:o.commonErrorList.PARAM.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.inputList||0==e.inputList.length)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums input list wrong"),r({errorCode:o.commonErrorList.PARAM.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.outputList||0==e.outputList.length)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no output list found"),r({errorCode:o.commonErrorList.MIX_OUTPUT.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.outputConfig||"object"!=typeof e.outputConfig)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no output config found"),r({errorCode:o.commonErrorList.MIX_OUTPUT.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.outputConfig.outputBitrate||"number"!=typeof e.outputConfig.outputBitrate)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums bitrate param is required and must be number"),r({errorCode:o.commonErrorList.PARAM.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.outputConfig.outputFPS||"number"!=typeof e.outputConfig.outputFPS)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums fps param is required and must be number"),r({errorCode:o.commonErrorList.PARAM.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.outputConfig.outputWidth||"number"!=typeof e.outputConfig.outputWidth)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums width param is required and must be number"),r({errorCode:o.commonErrorList.PARAM.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.outputConfig.outputHeight||"number"!=typeof e.outputConfig.outputHeight)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums height param is required and must be number"),r({errorCode:o.commonErrorList.PARAM.code,extendedData:""}),!1;v</span></span>ar d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e.outputConfig.singleStreamPassThrough&amp;&amp;"boolean"==typeof e.outputConfig.singleStreamPassThrough&amp;&amp;(d=e.outputConfig.singleStreamPassThrough?1:0);v</span>ar l=<span class="cstat-no" title="statement not covered" >{task_id:e.taskID,id_name:this.stateCenter.idName,live_channel:this.stateCenter.roomid,appid:this.stateCenter.appid,version:i.PROTO_VERSION,bypass:d},</span>u=<span class="cstat-no" title="statement not covered" >this.stateCenter.mixStreamAdvance;<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(u.videoCodec&amp;&amp;(l.extra_params=[{key:"video_encode",value:u.videoCodec}]),u.backgroundColor&amp;&amp;(l.output_bg_color=u.backgroundColor),u.backgroundImage&amp;&amp;(l.output_bg_image=u.backgroundImage),u.waterMark&amp;&amp;(l.watermark=u.waterMark),u.extraParams&amp;&amp;(!l.extra_params&amp;&amp;(l.extra_params=[]),(a=l.extra_params).push.apply(a,u.extraParams)));<span class="cstat-no" title="statement not covered" >f</span>or(var h=[],p=0;p&lt;e.inputList.length;p++){var g=<span class="cstat-no" title="statement not covered" >e.inputList[p],</span>m=<span class="cstat-no" title="statement not covered" >g.streamID;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.testEnvironment&amp;&amp;(m="zegotest-"+this.stateCenter.appid+"-"+g.streamID),h.push({stream_id:m,content_control:"AUDIO"===g.contentType?2:0,rect:{layer:p,top:g.layout.top,left:g.layout.left,bottom:g.layout.bottom,right:g.layout.right}})}<span class="cstat-no" title="statement not covered" ></span>l</span>.MixInput=h,s.ClientUtil.actionSuccessCallback("kZegoTaskMixStart"+e.taskID,this.stateCenter.reportList)&amp;&amp;s.ClientUtil.actionSuccessCallback("kZegoTaskMixStart"+e.taskID,this.stateCenter.reportList)(n.REPORT_ACTION.addMsgInfo,void 0,{mix_stream_id:e.taskID,stream_cnt:h.length,input_stream_list:h});v</span>ar f=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e.outputList.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof t)<span class="cstat-no" title="statement not covered" >s=t;e</span>lse{<span class="cstat-no" title="statement not covered" >if("object"!=typeof t||!t.target)<span class="cstat-no" title="statement not covered" >return c.logger.error("zb.sh.ums output target required"),r({errorCode:o.commonErrorList.MIX_OUTPUT.code,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >s</span></span>=t.target}<span class="cstat-no" title="statement not covered" ></span>s</span>.startsWith("rtmp://")||s.startsWith("https://")&amp;&amp;s.endsWith(".flv")||s.startsWith("https://")&amp;&amp;s.endsWith(".m3u8")?i.mixurl=s:c.stateCenter.testEnvironment?i.stream_id="zegotest-"+c.stateCenter.appid+"-"+s:i.stream_id=s,i.bitrate=1e3*e.outputConfig.outputBitrate,i.fps=e.outputConfig.outputFPS,i.width=e.outputConfig.outputWidth,i.height=e.outputConfig.outputHeight,e.outputConfig.outputAudioCodecID&amp;&amp;(i.audio_enc_id=e.outputConfig.outputAudioCodecID),"vp8"===u.videoCodec?i.audio_enc_id=3:"h264"===u.videoCodec&amp;&amp;(i.audio_enc_id=0),e.outputConfig.outputAudioBitrate&amp;&amp;(i.audio_bitrate=1e3*e.outputConfig.outputAudioBitrate),e.outputConfig.outputAudioChannels&amp;&amp;(i.audio_channel_cnt=e.outputConfig.outputAudioChannels),c.stateCenter.testEnvironment?i.testenv=1:i.testenv=0,f.push(i)}</span>)),l.MixOutput=f,s.ClientUtil.actionSuccessCallback("kZegoTaskMixStart"+e.taskID,this.stateCenter.reportList)&amp;&amp;s.ClientUtil.actionSuccessCallback("kZegoTaskMixStart"+e.taskID,this.stateCenter.reportList)(n.REPORT_ACTION.addMsgInfo,void 0,{output_target_list:f});v</span>ar v=<span class="cstat-no" title="statement not covered" >{channel:"zeus",cmd:"start_mix",req_body:JSON.stringify(l)};<span class="cstat-no" title="statement not covered" ></span>return this.logger.debug("zb.sh.ums send command"),this.socketCenter.sendMessage("biz_channel",v,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,o,n){<span class="cstat-no" title="statement not covered" >c.logger.debug("zb.sh.ums receive message");v</span>ar a=<span class="cstat-no" title="statement not covered" >"zegotest-"+c.stateCenter.appid+"-";<span class="cstat-no" title="statement not covered" ></span>if(0!=n.length){<span class="cstat-no" title="statement not covered" >for(var d=JSON.parse(n),l=[],u=0;u&lt;d.play.length;u++){var h=<span class="cstat-no" title="statement not covered" >{rtmpURL:"",hlsURL:"",flvURL:""},</span>p=<span class="cstat-no" title="statement not covered" >d.play[u].stream_alias||"";<span class="cstat-no" title="statement not covered" ></span>c.stateCenter.testEnvironment&amp;&amp;p&amp;&amp;p.startsWith(a)&amp;&amp;(p=p.slice(a.length)),h.streamID=p,d.play[u].rtmp_url&amp;&amp;d.play[u].rtmp_url.length&gt;0&amp;&amp;(h.rtmpURL=d.play[u].rtmp_url),d.play[u].hls_url&amp;&amp;d.play[u].hls_url.length&gt;0&amp;&amp;(h.hlsURL=d.play[u].hls_url),d.play[u].hdl_url&amp;&amp;d.play[u].hdl_url.length&gt;0&amp;&amp;(h.flvURL=d.play[u].hdl_url),l.push(h)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t){var g=<span class="cstat-no" title="statement not covered" >{mixerOutputList:l};<span class="cstat-no" title="statement not covered" ></span>t({errorCode:0,extendedData:JSON.stringify(g)})}</span>}</span>else <span class="cstat-no" title="statement not covered" >r&amp;&amp;r({errorCode:s.ClientUtil.getServerError(i.MIXSTREAM_ERROR_CODE+1).code,extendedData:""})}</span></span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,o){<span class="cstat-no" title="statement not covered" >if("number"==typeof e){<span class="cstat-no" title="statement not covered" >c.logger.debug("zb.sh.ums error: "+e);v</span>ar n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(1000000150==e&amp;&amp;0!=o.length)<span class="cstat-no" title="statement not covered" >for(var a=JSON.parse(o),d="zegotest-"+c.stateCenter.appid+"-",l=0;l&lt;a.non_exist_streams.length;l++){var u=<span class="cstat-no" title="statement not covered" >a.non_exist_streams[l];<span class="cstat-no" title="statement not covered" ></span>c.stateCenter.testEnvironment&amp;&amp;u.startsWith(d)?n.push(u.slice(d.length)):n.push(u)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>&amp;&amp;r({errorCode:s.ClientUtil.getServerError(i.MIXSTREAM_ERROR_CODE+e).code,extendedData:""})}</span>else <span class="cstat-no" title="statement not covered" >c.logger.debug("zb.sh.ums error code "+e.code),r&amp;&amp;r({errorCode:e.code,extendedData:""})}</span></span>)),!0}</span>,e.prototype.setMixerTaskConfig=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(r,i){var a=<span class="cstat-no" title="statement not covered" >{},</span>c=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;e.videoCodec){<span class="cstat-no" title="statement not covered" >if("h264"!==e.videoCodec&amp;&amp;"vp8"!==e.videoCodec)<span class="cstat-no" title="statement not covered" >return t.logger.error("zb.sh.ums param videoCode error"),i({errorCode:o.commonErrorList.MIX_VIDEOC,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >"</span></span>vp8"==e.videoCodec&amp;&amp;!0,a.videoCodec=e.videoCodec,c.video_codec=e.videoCodec}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.backgroundColor){<span class="cstat-no" title="statement not covered" >if("number"!=typeof e.backgroundColor)<span class="cstat-no" title="statement not covered" >return t.logger.error("zb.sh.ums param outputBgColor error"),i({errorCode:o.commonErrorList.PARAM,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >a</span></span>.backgroundColor=e.backgroundColor,c.background_color=e.backgroundColor}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.backgroundImage){<span class="cstat-no" title="statement not covered" >if("string"!=typeof e.backgroundImage||!e.backgroundImage.startsWith("preset-id://"))<span class="cstat-no" title="statement not covered" >return t.logger.error("zb.sh.ums param outputBgImage error"),i({errorCode:o.commonErrorList.PARAM,extendedData:""}),!1;<span class="cstat-no" title="statement not covered" >a</span></span>.backgroundImage=e.backgroundImage,c.background_image=e.backgroundImage}<span class="cstat-no" title="statement not covered" ></span>e</span>.waterMark&amp;&amp;(a.waterMark=e.waterMark,c.water_mark=e.waterMark),t.stateCenter.mixStreamAdvance=a,s.ClientUtil.actionSuccessCallback("kZegoTaskMixConfig",t.stateCenter.reportList)&amp;&amp;s.ClientUtil.actionSuccessCallback("kZegoTaskMixConfig",t.stateCenter.reportList)(n.REPORT_ACTION.addMsgInfo,void 0,{config:c}),r({errorCode:0,extendedData:""})}</span>))}</span>,e.prototype.publishTarget=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(-1!=["addpush","delpush","clearpush"].indexOf(e.type)){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.ptcall");v</span>ar n=<span class="cstat-no" title="statement not covered" >Math.ceil((new Date).getTime()/1e3),</span>a=<span class="cstat-no" title="statement not covered" >e.streamID;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.testEnvironment&amp;&amp;(a="zegotest-"+this.stateCenter.appid+"-"+e.streamID);v</span>ar c=<span class="cstat-no" title="statement not covered" >{appid:this.stateCenter.appid,biz_type:0,timestamp:n,signature:e.signature,seq:this.stateCenter.cdnSeq++,version:1*i.PROTO_VERSION,stream_id:a,pushurl:e.pushUrl},</span>d=<span class="cstat-no" title="statement not covered" >{channel:"media",cmd:e.type,req_body:JSON.stringify(c)};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.sh.pt send command"),this.socketCenter.sendMessage("biz_channel",d,(<span class="fstat-no" title="function not covered" >fu</span>nction(n,a,c){<span class="cstat-no" title="statement not covered" >if(o.logger.debug("zb.sh.pt receive message"),0!=c.length){var d=<span class="cstat-no" title="statement not covered" >JSON.parse(c),</span>l=<span class="cstat-no" title="statement not covered" >d.code,</span>u=<span class="cstat-no" title="statement not covered" >d.message;<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;0!=l)<span class="cstat-no" title="statement not covered" >return o.logger.error("zb.sh.pt "+e.type+" error code: "+l+" "+u),void(r&amp;&amp;r({errorCode:l}));<span class="cstat-no" title="statement not covered" >o</span></span>.logger.info("zb.sh.pt "+e.type+" success"),t&amp;&amp;t({errorCode:0})}</span>else <span class="cstat-no" title="statement not covered" >r&amp;&amp;r({errorCode:s.ClientUtil.getServerError(i.MIXSTREAM_ERROR_CODE+1).code})}</span></span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,i){<span class="cstat-no" title="statement not covered" >o.logger.debug("zb.sh.pt error: "+r);v</span>ar s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>2001==e?s="invalid channel":2002==e&amp;&amp;(s="bizchannel error"),o.logger.error("zb.sh.pt "+s),r&amp;&amp;r({errorCode:e})}</span>))}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.pt cdn push type error")}</span></span>,e.prototype.stopMixStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.sh.sms call");v</span>ar a=<span class="cstat-no" title="statement not covered" >{id_name:this.stateCenter.idName,live_channel:this.stateCenter.roomid,appid:this.stateCenter.appid,version:i.PROTO_VERSION,task_id:e},</span>c=<span class="cstat-no" title="statement not covered" >{channel:"zeus",cmd:"stop_mix",req_body:JSON.stringify(a)};<span class="cstat-no" title="statement not covered" ></span>return this.socketCenter.sendMessage("biz_channel",c,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t({errorCode:0})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >"number"==typeof e?r&amp;&amp;r({errorCode:s.ClientUtil.getServerError(i.MIXSTREAM_ERROR_CODE+e).code,extendedData:""}):(n.logger.error("zb.sh.sms stop mix fail "+JSON.stringify(e)),r&amp;&amp;r({errorCode:o.commonErrorList.STOP_MIX_FAIL.code,extendedData:""}))}</span>)),!0}</span>,e.prototype.updateStreamExtraInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.sh.usei call"),this.stateCenter.publishStreamList[e]&amp;&amp;(this.stateCenter.publishStreamList[e].extra_info=t,this.stateCenter.publishStreamList[e].state&gt;=i.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;this.updateStreamInfo(e,i.ENUM_STREAM_SUB_CMD.liveUpdate,t)),!0}</span>,e}();t.StreamHandler=a},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(3),o=r(1),n=r(2),a=r(4),c=function(){function e(e,t,r,i){this.logger=e,this.socketCenter=r,this.stateCenter=t,this.dataReport=i}return e.prototype.resetHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.hb.rht call"),clearTimeout(this.stateCenter.heartbeatTimer),this.stateCenter.heartbeatTimer=null,this.stateCenter.tryHeartbeatCount=0,this.logger.debug("zb.hb.rht call success")}</span>,e.prototype.hbLogout=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.start=function(e){var t=this;this.logger.debug("zb.hb.sht call");var r=n.getReportSeq();<span class="missing-if-branch" title="if path not taken" >I</span>if(this.dataReport.newReport(r,a.eventList.kZegoTaskLiveRoomhHB),this.dataReport.addMsgInfo(r,{room_sid:this.stateCenter.sessionid}),!this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.hb.sht state error"),this.dataReport.addMsgInfo(r,{error:a.errorList.kLiveRoomNotLoginError.code,message:a.errorList.kLiveRoomNotLoginError.message}),void this.dataReport.uploadReport(r);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(++this.stateCenter.tryHeartbeatCount&gt;3)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.hb.sht come to try limit"),this.dataReport.addMsgInfo(r,{error:a.errorList.kLiveRoomHBTimeoutError.code,message:a.errorList.kLiveRoomHBTimeoutError.message}),this.dataReport.uploadReport(r),void this.hbLogout(o.liveRoomErrorList.HEARTBEAT_TIMEOUT);t</span>his.logger.debug("zb.hb.sht send packet");this.socketCenter.registerRouter("hb",(function(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(0!==e.body.err_code){var i=<span class="cstat-no" title="statement not covered" >s.ClientUtil.decodeServerError(e.body.err_code,e.body.err_message);<span class="cstat-no" title="statement not covered" ></span>t.dataReport.addMsgInfo(r,{error:i.code,message:i.message})}</span>t.dataReport.uploadReport(r),t.handleHeartbeatRsp(e)})),this.socketCenter.sendMessage("hb",{reserve:0}),this.logger.debug("zb.hb.sht call success"),this.stateCenter.heartbeatInterval=e,this.stateCenter.heartbeatTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.start(t.stateCenter.heartbeatInterval)}</span>),this.stateCenter.heartbeatInterval)},e.prototype.handleHeartbeatRsp=function(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.logger.debug("zb.hb.hhbr call"),0!==e.body.err_code)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.hb.hhbr call disconnect, server error=",e.body.err_code),void this.hbLogout(s.ClientUtil.getServerError(e.body.err_code));f</span>or(var t in this.stateCenter.tryHeartbeatCount=0,this.stateCenter.heartbeatInterval=e.body.hearbeat_interval,this.stateCenter.heartbeatInterval&lt;i.MINIUM_HEARTBEAT_INTERVAL&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.heartbeatInterval=i.MINIUM_HEARTBEAT_INTERVAL)</span>,e.body.bigim_time_window&amp;&amp;"number"==typeof e.body.bigim_time_window&amp;&amp;(this.stateCenter.bigimTimeWindow=e.body.bigim_time_window),e.body.dati_time_window&amp;&amp;"number"==typeof e.body.dati_time_window&amp;&amp;(this.stateCenter.datiTimeWindow=e.body.dati_time_window),this.ReliableMessageHandler(e),this.fetchStreamList(e),this.patchUserList(e),this.stateCenter.publishStreamList)<span class="cstat-no" title="statement not covered" >this.stateCenter.publishStreamList[t].state==i.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;(this.logger.info("zb.hb.hhbr try to update stream info"),this.updateStreamInfo(t,i.ENUM_STREAM_SUB_CMD.liveBegin,this.stateCenter.publishStreamList[t].extra_info));n</span>ull!=e.body.online_count&amp;&amp;0!=e.body.online_count&amp;&amp;this.onUpdateOnlineCount(this.stateCenter.roomid,e.body.online_count),this.logger.debug("zb.hb.hhbr call success")},e.prototype.ReliableMessageHandler=function(e){var t=this;<span class="missing-if-branch" title="else path not taken" >E</span>if(e.body.trans_seqs)for(var r=0;r&lt;e.body.trans_seqs.length;r++){var i=<span class="cstat-no" title="statement not covered" >e.body.trans_seqs[r].trans_channel,</span>s=<span class="cstat-no" title="statement not covered" >e.body.trans_seqs[r].trans_seq_array;<span class="cstat-no" title="statement not covered" ></span>(s=s.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.trans_type,</span>i=<span class="cstat-no" title="statement not covered" >e.trans_seq;<span class="cstat-no" title="statement not covered" ></span>return!t.stateCenter.transSeqMap[r]||t.stateCenter.transSeqMap[r].seq!==i}</span>))).length&gt;0&amp;&amp;this.fetchReliableMessage(i,s)}</span>},e.prototype.fetchReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.hb.frm call");v</span>ar i=<span class="cstat-no" title="statement not covered" >{trans_channel:e,fetch_array:t};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.registerRouter("trans_fetch",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.handleFetchTransRsp(e)}</span>)),this.socketCenter.sendMessage("trans_fetch",i),this.logger.debug("zb.hb.frm call success")}</span>,e.prototype.handleFetchTransRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.isLogin()?0==e.body.err_code?e.body.trans_fetch_results.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >e.trans_type,</span>i=<span class="cstat-no" title="statement not covered" >e.trans_seq;<span class="cstat-no" title="statement not covered" ></span>t.stateCenter.transSeqMap[r]={seq:i},e.trans_user_idname!=t.stateCenter.idName&amp;&amp;e.trans_idname!=t.stateCenter.idName&amp;&amp;t.onRecvReliableMessage(r,i,e.trans_data),t.logger.debug("zb.hb.hftr trans "+r+" seq "+i)}</span>)):this.logger.error("zb.hb.hftr trans send error "+e.body.err_code):this.logger.error("zb.hb.hftr not login")}</span>,e.prototype.fetchStreamList=function(e){var t=this;e.body.stream_seq!==this.stateCenter.streamSeq&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.debug("zb.hb.fsl current seq "+this.stateCenter.streamSeq+" server Seq "+e.body.stream_seq),this.logger.debug("zb.hb.fsl call"),this.stateCenter.isLogin()?this.stateCenter.streamQuerying?this.logger.warn("zb.hb.fsl already doing"):(this.stateCenter.streamQuerying=!0,this.logger.debug("zb.hb.fsl send fetch request"),this.socketCenter.registerRouter("stream_info",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t.handleFetchStreamListRsp(e)}</span>)),this.socketCenter.sendMessage("stream_info",{reserve:0}),this.logger.debug("zb.hb.fsl call success")):this.logger.error("zb.hb.fsl state error"))</span>},e.prototype.patchUserList=function(e){var t=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(e.body.server_user_seq!==this.stateCenter.userSeq&amp;&amp;this.stateCenter.userStateUpdate&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >!this.stateCenter.userSeqMergeMap)</span>{var r=<span class="cstat-no" title="statement not covered" >this.stateCenter.lastUserQueryTime-Date.now();<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.hb.hhbr call update user "+this.stateCenter.userSeq+" server "+e.body.server_user_seq+" wait "+r),r&gt;0?(this.stateCenter.userQueryTimer&amp;&amp;clearTimeout(this.stateCenter.userQueryTimer),this.stateCenter.userQueryTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.fetchUserList()}</span>),r)):this.fetchUserList()}</span>},e.prototype.handleFetchStreamListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.fetchUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(){},e.prototype.updateStreamInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r="")}</span>,e.prototype.onUpdateOnlineCount=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.resetCheckMessage=function(){this.logger.debug("zb.hb.rcm call"),clearTimeout(this.stateCenter.sendDataCheckTimer),this.stateCenter.sendDataCheckTimer=null,this.checkSendMessageList(this.stateCenter.sendDataList),this.checkSendMessageList(this.stateCenter.sendCommandList),this.stateCenter.sendDataMap={},this.stateCenter.sendCommandMap={},this.logger.debug("zb.hb.rcm call success")},e.prototype.checkSendMessageList=function(e){for(var t=e.getFirst();null!=t;)<span class="cstat-no" title="statement not covered" >e.remove(t),t._data.error&amp;&amp;(t._data.data.body.custom_msg?t._data.error(o.liveRoomErrorList.SEND_MSG_TIMEOUT,t._data.data.header.seq,t._data.data.body.custom_msg):t._data.error(o.liveRoomErrorList.SEND_MSG_TIMEOUT,t._data.data.header.seq)),t=e.getFirst()}</span>,e.prototype.checkMessageListTimeout=function(e,t){for(var r=e.getFirst(),i=Date.parse(new Date+""),s=0,n=0,a=0;!(null==r||<span class="branch-1 cbranch-no" title="branch not covered" >r._data.time+this.stateCenter.sendDataTimeout&gt;i|</span>|(<span class="branch-2 cbranch-no" title="branch not covered" >delete t[r._data.data.header.seq],e.remove(r),++n,null==r._data.error||this.stateCenter.sendDataDropTimeout&gt;0&amp;&amp;r._data.time+this.stateCenter.sendDataDropTimeout&lt;i?++a:r._data.data.body.custom_msg?r._data.error(o.liveRoomErrorList.SEND_MSG_TIMEOUT,r._data.data.header.seq,r._data.data.body.custom_msg):r._data.error(o.liveRoomErrorList.SEND_MSG_TIMEOUT,r._data.data.header.seq),++s&gt;=this.stateCenter.sendDataCheckOnceCount)</span>);)<span class="cstat-no" title="statement not covered" >r=e.getFirst();0</span>==n&amp;&amp;0==a||<span class="branch-2 cbranch-no" title="branch not covered" >this.logger.debug("zb.hb.cmt call success, stat: timeout=",n,"drop=",a)}</span>,e.prototype.startCheckMessageTimeout=function(){var e=this;this.stateCenter.isLogin()?(this.checkMessageListTimeout(this.stateCenter.sendDataList,this.stateCenter.sendDataMap),this.checkMessageListTimeout(this.stateCenter.sendCommandList,this.stateCenter.sendCommandMap),this.stateCenter.sendDataCheckTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.startCheckMessageTimeout()}</span>),this.stateCenter.sendDataCheckInterval)):<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.error("zb.hb.scmt state error")}</span>,e}();t.HeartBeatHandler=c},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(3),o=function(){function e(e,t,r,i){this.logger=e,this.socketCenter=r,this.stateCenter=t,this.dataReport=i}return e.prototype.sendCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){var o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zb.mh.scc call"),this.stateCenter.isLogin()){var n=<span class="cstat-no" title="statement not covered" >{from_userid:this.stateCenter.idName,from_username:this.stateCenter.nickName,request_id:this.stateCenter.getRequestId(),custom_content:t||"",room_id:this.stateCenter.roomid},</span>a=<span class="cstat-no" title="statement not covered" >{dest_id_name:e,custom_msg:JSON.stringify(n)};<span class="cstat-no" title="statement not covered" ></span>s.ClientUtil.checkCustomCommandParam(a)?(this.socketCenter.registerRouter("custommsg",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o.handleSendCustomMsgRsp(e)}</span>)),this.socketCenter.sendCustomMessage("custommsg",a,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=[],t=0;t&lt;arguments.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=arguments[t];v</span></span>ar i=<span class="cstat-no" title="statement not covered" >e[0],</span>s=<span class="cstat-no" title="statement not covered" >e[1];<span class="cstat-no" title="statement not covered" ></span>r({errorCode:i,messageID:s})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=[],t=0;t&lt;arguments.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=arguments[t];v</span></span>ar r=<span class="cstat-no" title="statement not covered" >e[0],</span>s=<span class="cstat-no" title="statement not covered" >e[1];<span class="cstat-no" title="statement not covered" ></span>o.logger.error("zb.mh.scc "+r.msg),i({errorCode:r,messageID:s})}</span>)),this.logger.info("zb.mh.scc call success")):this.logger.error("zb.mh.scc param error")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.mh.scc state error")}</span></span>,e.prototype.handleSendCustomMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.hscmrcall");v</span>ar t,r=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendDataMap[e.header.seq];<span class="cstat-no" title="statement not covered" ></span>null!=r?("custommsg"!=(t=r._data).data.header.cmd?this.logger.error("zb.mh.hscmrcmd wrong"+t.data.header.cmd):0===e.body.err_code?(JSON.parse(t.data.body.custom_msg),null!=t.success&amp;&amp;t.success(0,e.body.msg_id)):null!=t.error&amp;&amp;t.error(s.ClientUtil.getServerError(e.body.err_code),e.body.msg_id),delete this.stateCenter.sendDataMap[e.header.seq],this.stateCenter.sendDataList.remove(r)):this.logger.error("zb.mh.hscmrno found seq="+e.header.seq),this.logger.debug("zb.mh.hscmr  call success")}</span>,e.prototype.handlePushCustomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >JSON.parse(e.body.custommsg);<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.mh.hpcm submsg=",t),this.onRecvCustomCommand(t.from_userid,t.from_username,t.room_id,t.custom_content)}</span>,e.prototype.onRecvCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){},e.prototype.sendRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s,o){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zb.mh.srm call"),this.stateCenter.isLogin()){var a=<span class="cstat-no" title="statement not covered" >Date.parse(new Date+"");<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.sendRoomMsgTime&gt;0&amp;&amp;this.stateCenter.sendRoomMsgTime+this.stateCenter.SendRoomMsgInterval&gt;a)<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.mh.srm freq error"),void(o&amp;&amp;o(i.sdkErrorList.FREQ_LIMITED,0,e,r));<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.sendRoomMsgTime=a,this.logger.debug("zb.mh.srm send fetch request");v</span>ar c=<span class="cstat-no" title="statement not covered" >{msg_category:e,msg_type:1,msg_content:r};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.registerRouter("im_chat",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >n.handleSendRoomMsgRsp(e)}</span>)),this.socketCenter.sendCustomMessage("im_chat",c,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=[],t=0;t&lt;arguments.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=arguments[t];v</span></span>ar r=<span class="cstat-no" title="statement not covered" >e[0],</span>i=<span class="cstat-no" title="statement not covered" >e[1];<span class="cstat-no" title="statement not covered" ></span>s({errorCode:r,messageID:i})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=[],t=0;t&lt;arguments.length;t++)<span class="cstat-no" title="statement not covered" >e[t]=arguments[t];v</span></span>ar r=<span class="cstat-no" title="statement not covered" >e[0],</span>i=<span class="cstat-no" title="statement not covered" >e[1];<span class="cstat-no" title="statement not covered" ></span>n.logger.error("zb.mh.srm "+r.msg),o({errorCode:r,messageID:i})}</span>)),this.logger.info("zb.mh.srm call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.mh.srm state error")}</span></span>,e.prototype.handleSendRoomMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.hsrmr call");v</span>ar t,r=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendDataMap[e.header.seq];<span class="cstat-no" title="statement not covered" ></span>null!=r?("im_chat"!=(t=r._data).data.header.cmd?this.logger.error("zb.mh.hsrmr cmd wrong"+t.data.header.cmd):0===e.body.err_code?t.success&amp;&amp;t.success(0,e.body.msg_id):t.error&amp;&amp;t.error(s.ClientUtil.getServerError(e.body.err_code),e.body.msg_id),delete this.stateCenter.sendDataMap[e.header.seq],this.stateCenter.sendDataList.remove(r)):this.logger.error("hzb.mh.hsrmr no found seq="+e.header.seq),this.logger.info("zb.mh.hsrmr call success")}</span>,e.prototype.onRecvRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e.prototype.sendReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.srirm call"),this.stateCenter.transSeqMap[e]||(this.stateCenter.transSeqMap[e]={seq:0});v</span>ar s=<span class="cstat-no" title="statement not covered" >{trans_type:e,trans_data:t,trans_local_seq:this.stateCenter.transSeqMap[e].seq,trans_channel:"clt"};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("trans",s,r,i)}</span>,e.prototype.sendBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){var o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>console.log(t),this.logger.debug("zb.mh.sbim call");v</span>ar n=<span class="cstat-no" title="statement not covered" >this.stateCenter.bigimTimeWindow,</span>a=<span class="cstat-no" title="statement not covered" >this.stateCenter.serverTimeOffset,</span>c=<span class="cstat-no" title="statement not covered" >(new Date).getTime()+a,</span>d=<span class="cstat-no" title="statement not covered" >(++this.stateCenter.cmdSeq).toString();<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.bigImCallbackMap[d]={success:i,error:s},0==n){var l=<span class="cstat-no" title="statement not covered" >{msg_category:e,msg_type:1,msg_content:r,bigmsg_client_id:d};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.mh.sbim no time window"),this.sendBigRoomMessageInternal([l],(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o.handleBigImMsgRsp(e)}</span>),s)}</span>else{var u=<span class="cstat-no" title="statement not covered" >Math.floor(c/n);<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("currentIndex "+u+" lastTimeIndex "+this.stateCenter.bigImLastTimeIndex),this.stateCenter.bigImLastTimeIndex&lt;u&amp;&amp;0==this.stateCenter.bigImMessageList.length){<span class="cstat-no" title="statement not covered" >this.stateCenter.bigImLastTimeIndex=u;v</span>ar h=<span class="cstat-no" title="statement not covered" >{msg_category:e,msg_type:1,msg_content:r,bigmsg_client_id:d};<span class="cstat-no" title="statement not covered" ></span>this.sendBigRoomMessageInternal([h],(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o.handleBigImMsgRsp(e)}</span>),s)}</span>else <span class="cstat-no" title="statement not covered" >this.stateCenter.bigImMessageList.push({msg_category:e,msg_type:1,msg_content:r,bigmsg_client_id:d}),1==this.stateCenter.bigImMessageList.length&amp;&amp;this.setBigImTimer(a,n)}</span></span>}</span>,e.prototype.handlePushMergeMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){<span class="cstat-no" title="statement not covered" >for(var t=0;t&lt;e.body.messages.length;t++)<span class="cstat-no" title="statement not covered" >14001===e.body.messages[t].sub_cmd&amp;&amp;this.handlePushBigRooMsg(e.body.messages[t].msg_body);<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.debug("zb.mh.hpmm call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.mh.hpmmnot login")}</span></span>,e.prototype.handlePushBigRooMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=JSON.parse(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void this.logger.warn("zb.mh.hpbrm parse json error")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t){<span class="cstat-no" title="statement not covered" >for(var r=t.room_id,i=[],s=0;s&lt;t.msg_data.length;s++){var o=<span class="cstat-no" title="statement not covered" >t.msg_data[s];<span class="cstat-no" title="statement not covered" ></span>o.id_name!=this.stateCenter.idName?i.push({idName:o.id_name,nickName:o.nick_name,messageId:o.bigmsg_id,category:o.msg_category,type:o.msg_type,content:o.msg_content,time:o.send_time}):this.logger.debug("zb.mh.hpbrm self message")}<span class="cstat-no" title="statement not covered" ></span>0</span>==i.length?this.logger.debug("zb.mh.hpbrm no other pushData except self"):this.onRecvBigRoomMessage(i,r),this.logger.debug("zb.mh.hpbrm call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zb.mh.hpbrm cann't find message body")}</span></span>,e.prototype.onRecvBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){},e.prototype.sendBigRoomMessageInternal=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.sbim call");v</span>ar i=<span class="cstat-no" title="statement not covered" >{msgs:e};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("bigim_chat",i,t,r)}</span>,e.prototype.handleBigImMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){<span class="cstat-no" title="statement not covered" >this.stateCenter.bigimTimeWindow!=e.body.bigim_time_window&amp;&amp;(this.stateCenter.bigimTimeWindow=e.body.bigim_time_window);<span class="cstat-no" title="statement not covered" >f</span>or(var t=0;t&lt;e.body.msgs.length;t++){var r=<span class="cstat-no" title="statement not covered" >e.body.msgs[t].bigmsg_client_id,</span>i=<span class="cstat-no" title="statement not covered" >e.body.msgs[t].bigmsg_id;<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.bigImCallbackMap[r]){var s=<span class="cstat-no" title="statement not covered" >this.stateCenter.bigImCallbackMap[r].success;<span class="cstat-no" title="statement not covered" ></span>null!=s&amp;&amp;s({errorCode:0,messageID:i}),delete this.stateCenter.bigImCallbackMap[r]}</span>}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.mh.hbmr not login")}</span></span>,e.prototype.setBigImTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >t-((new Date).getTime()+e)%t,</span>o=<span class="cstat-no" title="statement not covered" >s.ClientUtil.generateRandumNumber(t)+i;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.mh.sbt setTimer "+o),this.stateCenter.bigImTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >r.onBigImTimer()}</span>),o)}</span>,e.prototype.onBigImTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >(new Date).getTime()+this.stateCenter.serverTimeOffset;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.bigImLastTimeIndex=Math.floor(t/this.stateCenter.bigimTimeWindow);<span class="cstat-no" title="statement not covered" >f</span>or(var r=[],i=[],s=0;s&lt;this.stateCenter.bigImMessageList.length&amp;&amp;!(s&gt;=20);s++){var o=<span class="cstat-no" title="statement not covered" >this.stateCenter.bigImMessageList[s];<span class="cstat-no" title="statement not covered" ></span>r.push({msg_category:o.msg_category,msg_type:o.msg_type,msg_content:o.msg_content,bigmsg_client_id:o.bigmsg_client_id}),i.push(o.bigmsg_client_id)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.stateCenter.bigImMessageList.length&gt;20?this.stateCenter.bigImMessageList.splice(0,20):this.stateCenter.bigImMessageList=[],this.sendBigRoomMessageInternal(r,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.handleBigImMsgRsp(t)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >for(var s=0;s&lt;i.length;s++){var o=<span class="cstat-no" title="statement not covered" >i[s],</span>n=<span class="cstat-no" title="statement not covered" >e.stateCenter.bigImCallbackMap[o];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(null!=n.error&amp;&amp;n.error(t,r),delete e.stateCenter.bigImCallbackMap[o])}</span>}</span>)),clearTimeout(this.stateCenter.bigImTimer),this.stateCenter.bigImTimer=null,this.stateCenter.bigImMessageList.length&gt;0&amp;&amp;this.setBigImTimer(this.stateCenter.serverTimeOffset,this.stateCenter.bigimTimeWindow)}</span>,e.prototype.sendRelayMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.srm call");v</span>ar s=<span class="cstat-no" title="statement not covered" >this.stateCenter.datiTimeWindow,</span>o=<span class="cstat-no" title="statement not covered" >this.stateCenter.serverTimeOffset;<span class="cstat-no" title="statement not covered" ></span>s&gt;0?(this.stateCenter.realyMessageList.push({type:e,data:t,success:r,error:i}),1==this.stateCenter.realyMessageList.length&amp;&amp;this.setRelayTimer(o,s)):this.sendRelayMessageInternal(e,t,r,i)}</span>,e.prototype.sendRelayMessageInternal=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.srmi call");v</span>ar s=<span class="cstat-no" title="statement not covered" >{relay_type:e,relay_data:t};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("relay",s,r,i)}</span>,e.prototype.setRelayTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >2*t-((new Date).getTime()+e)%t,</span>o=<span class="cstat-no" title="statement not covered" >s.ClientUtil.generateRandumNumber(i);<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.mh.srt setTimer "+o),this.stateCenter.relayTimer=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >r.onRelayTimer()}</span>),o)}</span>,e.prototype.onRelayTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(0!=this.stateCenter.realyMessageList.length){var e=<span class="cstat-no" title="statement not covered" >this.stateCenter.realyMessageList[0];<span class="cstat-no" title="statement not covered" ></span>this.sendRelayMessageInternal(e.type,e.data,e.success,e.error),clearTimeout(this.stateCenter.relayTimer),this.stateCenter.relayTimer=null,this.stateCenter.realyMessageList.splice(0,1),this.stateCenter.realyMessageList.length&gt;0&amp;&amp;this.setRelayTimer(this.stateCenter.serverTimeOffset,this.stateCenter.datiTimeWindow)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.mh.ort no relay data")}</span></span>,e.prototype.handlePushTransMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){var t=<span class="cstat-no" title="statement not covered" >e.body.trans_type,</span>r=<span class="cstat-no" title="statement not covered" >e.body.trans_seq;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.transSeqMap[t]?this.stateCenter.transSeqMap[t].seq=r:this.stateCenter.transSeqMap[t]={seq:r},e.body.trans_user_idname!=this.stateCenter.idName&amp;&amp;e.body.trans_idname!=this.stateCenter.idName?this.onRecvReliableMessage(t,r,e.body.trans_data):this.logger.debug("zb.mh.hptr receive self trans message"),this.logger.info("zb.mh.hptr trans "+t+" seq "+r)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.mh.hptr not login")}</span></span>,e.prototype.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){},e}();t.MessageHandler=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=function(){function e(e,t,r){this.logger=e,this.socketCenter=r,this.stateCenter=t}return e.prototype.requestJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.rjl call");v</span>ar o=<span class="cstat-no" title="statement not covered" >this.stateCenter.getRequestId(),</span>n=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(o,e);<span class="cstat-no" title="statement not covered" ></span>return null!=s&amp;&amp;(this.stateCenter.joinLiveCallbackMap[o]=s,this.sendSignalCmd(i.ENUM_SIGNAL_SUB_CMD.joinLiveRequest,n,e,t,r),!0)}</span>,e.prototype.inviteJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.ijl call");v</span>ar o=<span class="cstat-no" title="statement not covered" >this.stateCenter.getRequestId(),</span>n=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(o,e);<span class="cstat-no" title="statement not covered" ></span>return null!=s&amp;&amp;(this.stateCenter.joinLiveCallbackMap[o]=s,this.sendSignalCmd(i.ENUM_SIGNAL_SUB_CMD.joinLiveInvite,n,e,t,r),!0)}</span>,e.prototype.endJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.ejl call");v</span>ar s=<span class="cstat-no" title="statement not covered" >this.stateCenter.getRequestId(),</span>o=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(s,e);<span class="cstat-no" title="statement not covered" ></span>return this.sendSignalCmd(i.ENUM_SIGNAL_SUB_CMD.joinLiveStop,o,e,t,r),!0}</span>,e.prototype.respondJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,s){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.rpjl call");v</span>ar o=<span class="cstat-no" title="statement not covered" >this.stateCenter.joinLiveRequestMap[e];<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.lh.rpjl no dest id name"),!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>!0===t&amp;&amp;(n=1);v</span>ar a=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(e,o,n);<span class="cstat-no" title="statement not covered" ></span>return this.sendSignalCmd(i.ENUM_SIGNAL_SUB_CMD.joinLiveResult,a,o,r,s),delete this.stateCenter.joinLiveRequestMap[e],!0}</span>,e.prototype.sendSignalCmd=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i,s){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.lh.ssc call"),this.stateCenter.isLogin()){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.ssc send signal cmd "+e);v</span>ar o=<span class="cstat-no" title="statement not covered" >{sub_cmd:e,signal_msg:t,dest_id_name:[r]};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("signal",o,i,s),this.logger.info("zb.lh.ssc call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.ssc state error")}</span></span>,e.prototype.handlePushSignalMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){var t=<span class="cstat-no" title="statement not covered" >JSON.parse(e.body.signal_msg);<span class="cstat-no" title="statement not covered" ></span>switch(this.logger.debug("zb.lh.hpcm hpsm= ",t),e.body.sub_cmd){case i.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveRequest:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveRequestMsg(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveResult:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveResultMsg(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveInvite:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveInviteMsg(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase i.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveStop:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveStopMsg(t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.debug("zb.lh.hpsm call end")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zb.lh.hpsm not login")}</span></span>,e.prototype.handlePushJoinLiveRequestMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.request_id;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof t){var r=<span class="cstat-no" title="statement not covered" >e.from_userid;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof r?(this.stateCenter.joinLiveRequestMap[t]=r,this.logger.info("zb.lh.hpjlrm onRecvJoinLiveRequest "+r),this.onRecvJoinLiveRequest(t,e.from_userid,e.from_username,e.room_id)):this.logger.error("zb.lh.hpjlrm no from user")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.hpjlrm no requestId")}</span></span>,e.prototype.onRecvJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){},e.prototype.handlePushJoinLiveInviteMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.request_id;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof t){var r=<span class="cstat-no" title="statement not covered" >e.from_userid;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof r?(this.stateCenter.joinLiveRequestMap[t]=r,this.logger.info("zb.lh.hpjlim onRecvInviteJoinLiveRequest "+r),this.onRecvInviteJoinLiveRequest(t,e.from_userid,e.from_username,e.room_id)):this.logger.error("zb.lh.hpjlim no from user")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.hpjlim no requestId")}</span></span>,e.prototype.onRecvInviteJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){},e.prototype.handlePushJoinLiveResultMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.request_id;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof t){var r=<span class="cstat-no" title="statement not covered" >e.result;<span class="cstat-no" title="statement not covered" ></span>if(null!=r){var i=<span class="cstat-no" title="statement not covered" >1==r;<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.joinLiveCallbackMap[t]){var s=<span class="cstat-no" title="statement not covered" >this.stateCenter.joinLiveCallbackMap[t];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return void this.logger.info("hpjlrm.o no callback");<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.info("zb.lh.hpjlrm joinLiveRequest/invite result "+i),delete this.stateCenter.joinLiveCallbackMap[t],s(i,e.from_userid,e.from_username)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.lh.hpjlrm no result")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.hpjlrm no requestId")}</span></span>,e.prototype.handlePushJoinLiveStopMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.request_id;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof t?(this.logger.info("zb.lh.hpjlsm onRecvEndJoinLiveCommand "+e.from_userid),this.onRecvEndJoinLiveCommand(t,e.from_userid,e.from_username,e.room_id)):this.logger.error("zb.lh.hpjlsm no requestId")}</span>,e.prototype.onRecvEndJoinLiveCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){},e}();t.LiveHandler=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(0),s=r(2),o=function(){function e(){this.debug=!1,this.debugCustom=!1,this.testEnvironment=!1,this.third_token="",this.pullLimited=!0,this.configOK=!1,this.role=2,this.maxMemberCount=0,this.roomCreateFlag=1,this.runState=i.ENUM_RUN_STATE.logout,this.lastRunState=i.ENUM_RUN_STATE.logout,this.callbackList={},this.streamQuerying=!1,this.streamSeq=0,this.streamList=[],this.publishStreamList={},this.userQuerying=!1,this.userTempList=[],this.userList=[],this.userSeq=0,this.userSeqMergeMap=null,this.userSeqMergeTimer=null,this.userQueryTimer=null,this.lastUserQueryTime=0,this.userListInterval=3e4,this.userListMergeInterval=5e3,this.anchor_info={anchor_id:"",anchor_id_name:"",anchor_nick_name:""},this.sendCommandMap={},this.sendCommandList=new i.LinkedList,this.sendDataMap={},this.sendDataList=new i.LinkedList,this.joinLiveCallbackMap={},this.joinLiveRequestMap={},this.streamUrlMap={},this.cmdCallback={},this.customUrl=[],this.customPlayUrl=[],this.transSeqMap={},this.realyMessageList=[],this.relayTimer=null,this.bigImLastTimeIndex=0,this.bigIMmessageList=[],this.bigImCallbackMap={},this.bigImTimer=null,this.msgCategory=2,this.serverTimeOffset=0,this.datiTimeWindow=0,this.bigimTimeWindow=0,this.bigImMessageList=[],this.tryLoginCount=0,this.tryLoginTimer=null,this.heartbeatTimer=null,this.sendDataCheckTimer=null,this.sendDataCheckInterval=2e3,this.sendDataTimeout=5e3,this.sendDataDropTimeout=1e4,this.sendDataCheckOnceCount=100,this.sendRoomMsgTime=0,this.SendRoomMsgInterval=500,this.cmdSeq=0,this.audioEffectBuffer={},this.audioBitRate=48e3,this.cdnSeq=0,this.listenerList={roomUserUpdate:[],updateOnlineCount:[],getAnchorInfo:[],IMRecvCustomCommand:[],IMRecvBroadcastMessage:[],recvReliableMessage:[],IMRecvBarrageMessage:[],recvJoinLiveRequest:[],recvInviteJoinLiveRequest:[],recvEndJoinLiveCommand:[],roomStreamUpdate:[],streamExtraInfoUpdate:[],playerStateUpdate:[],publisherStateUpdate:[],roomStateUpdate:[],screenSharingEnded:[],publishQualityUpdate:[],playQualityUpdate:[],remoteCameraStatusUpdate:[],remoteMicStatusUpdate:[],soundLevelUpdate:[]},this.reportList={},this.reportSeqList={login:0,relogin:0,startPublish:{},rePublish:{},startPlay:{},rePlay:{},stopPublish:{},stopPlay:{}},this.streamTrigger={},this.mixStreamAdvance={},this.audioStreamList={}}return e.prototype.isLogin=function(){return this.runState===i.ENUM_RUN_STATE.login},e.prototype.getRequestId=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.idName+"-"+s.getSeq()}</span>,e.prototype.getSignalCmdContent=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){var i=<span class="cstat-no" title="statement not covered" >{request_id:e,room_id:this.roomid,from_userid:this.idName,from_username:this.nickName,to_userid:t};<span class="cstat-no" title="statement not covered" ></span>return null!=r&amp;&amp;(i.result=r),JSON.stringify(i)}</span>,e.prototype.actionListener=function(e){for(var t=[],r=1;r&lt;arguments.length;r++)t[r-1]=arguments[r];this.listenerList[e]&amp;&amp;this.listenerList[e].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.apply(void 0,t)}</span>))},e}();t.StateCenter=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(3),s=function(){function <span class="fstat-no" title="function not covered" >e(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >t.type,</span>s=<span class="cstat-no" title="statement not covered" >t.channels,</span>o=<span class="cstat-no" title="statement not covered" >void 0===s?1:s,</span>n=<span class="cstat-no" title="statement not covered" >t.bufferSize,</span>a=<span class="cstat-no" title="statement not covered" >void 0===n?0:n,</span>c=<span class="cstat-no" title="statement not covered" >t.sampleBit,</span>d=<span class="cstat-no" title="statement not covered" >void 0===c?16:c,</span>l=<span class="cstat-no" title="statement not covered" >t.sampleRate,</span>u=<span class="cstat-no" title="statement not covered" >void 0===l?44100:l;<span class="cstat-no" title="statement not covered" ></span>this.instant=0,this.slow=0,this.clip=0,this.context=e,this.type=i,this.channels=o,this.bufferSize=a,this.sampleBit=d,this.sampleRate=u,this.script=e.createScriptProcessor(a,o,o);<span class="cstat-no" title="statement not covered" >(</span>new Date).getTime();<span class="cstat-no" title="statement not covered" >t</span>his.script.addEventListener("audioprocess",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,s=<span class="cstat-no" title="statement not covered" >e.inputBuffer.getChannelData(0),</span>o=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;s.length;++t)<span class="cstat-no" title="statement not covered" >o+=s[t]*s[t],Math.abs(s[t])&gt;.99&amp;&amp;(n+=1);<span class="cstat-no" title="statement not covered" >i</span></span>f(r.instant=Math.sqrt(o/s.length),r.slow=.95*r.slow+.05*r.instant,r.clip=n/s.length,"pcm"===i||"wav"===i){<span class="cstat-no" title="statement not covered" >for(var a=[],c=0;c&lt;r.channels;c++)<span class="cstat-no" title="statement not covered" >a.push(e.inputBuffer.getChannelData(c));<span class="cstat-no" title="statement not covered" >r</span></span>.recorderBuffer(a)}</span>}</span>)),"pcm"!==i&amp;&amp;"wav"!==i||this.initRecorderBuffer(i)}</span>return e.prototype.connectToSource=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >console.log("SoundMeter connecting");<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.mic=this.context.createMediaStreamSource(e),this.mic.connect(this.script),this.script.connect(this.context.destination),void 0!==t&amp;&amp;t(null)}</span>catch(e){<span class="cstat-no" title="statement not covered" >console.error(e),void 0!==t&amp;&amp;t(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,e.prototype.recorderBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >this.worker.postMessage({command:"record",val:e})}</span>,e.prototype.initRecorderBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.worker=i.ClientUtil.inlineWorker((<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,r,i,s,o,n,a=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >t;</span>function <span class="fstat-no" title="function not covered" >d(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;r.length;i++,t+=2){var s=<span class="cstat-no" title="statement not covered" >Math.max(-1,Math.min(1,r[i]));<span class="cstat-no" title="statement not covered" ></span>e.setInt16(t,s&lt;0?32768*s:32767*s,!0)}</span>}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;r.length;i++,t++){var s=<span class="cstat-no" title="statement not covered" >Math.max(-1,Math.min(1,r[i])),</span>o=<span class="cstat-no" title="statement not covered" >s&lt;0?128*s:127*s;<span class="cstat-no" title="statement not covered" ></span>o+=128,e.setInt8(t,o)}</span>}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >e.setUint8(t+i,r.charCodeAt(i))}</span></span>function <span class="fstat-no" title="function not covered" >h(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var r=new Float32Array(t.length/e),i=0,s=0;i&lt;r.length;)<span class="cstat-no" title="statement not covered" >r[i]=t[s],s+=e,i++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >p(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(var i=new Float32Array(t*e.length),s=0,o=0;o&lt;r[0].length;o++)<span class="cstat-no" title="statement not covered" >i.set(r[0][o],s),s+=r[0][o].length;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >g(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var r=new Float32Array(e.length+t.length),i=0;i&lt;e.length+t.length;i+=2)<span class="cstat-no" title="statement not covered" >r[i]=e[i/2&gt;&gt;0],r[i+1]=t[i/2&gt;&gt;0];<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >m(</span>t){var r,i;<span class="cstat-no" title="statement not covered" >if(1==e)<span class="cstat-no" title="statement not covered" >r=p(a[0],o,a),1!=t&amp;&amp;(i=h(t,r));e</span>lse <span class="cstat-no" title="statement not covered" >if(2==e){var s=<span class="cstat-no" title="statement not covered" >p(a[0],o,a),</span>n=<span class="cstat-no" title="statement not covered" >p(a[1],o,a);<span class="cstat-no" title="statement not covered" ></span>1!=t?i=g(h(t,s),h(t,n)):r=g(s,n)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn 1!=t?i:r}</span>function <span class="fstat-no" title="function not covered" >f(</span>e){var t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var i;<span class="cstat-no" title="statement not covered" >8==t?i=e.length:16==t&amp;&amp;(i=e.length,i*=2);v</span>ar s=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(i),</span>o=<span class="cstat-no" title="statement not covered" >new DataView(s);<span class="cstat-no" title="statement not covered" ></span>return 8==t?l(o,0,e):16==r&amp;&amp;d(o,0,e),o}</span>(m(e),r);<span class="cstat-no" title="statement not covered" ></span>c.postMessage({command:"exportPcmLive",val:t})}</span>function <span class="fstat-no" title="function not covered" >v(</span>t){var s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,s){var o;<span class="cstat-no" title="statement not covered" >8==s?o=t.length:16==r&amp;&amp;(o=t.length,o*=2);v</span>ar n=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(o+44),</span>a=<span class="cstat-no" title="statement not covered" >new DataView(n),</span>c=<span class="cstat-no" title="statement not covered" >i,</span>h=<span class="cstat-no" title="statement not covered" >r,</span>p=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return u(a,0,"RIFF"),a.setUint32(4,36+o,!0),u(a,8,"WAVE"),u(a,12,"fmt "),a.setUint32(16,16,!0),a.setUint16(20,1,!0),a.setUint16(22,p,!0),a.setUint32(24,c,!0),a.setUint32(28,c*p*(h/8),!0),a.setUint16(32,p*(h/8),!0),a.setUint16(34,h,!0),u(a,36,"data"),a.setUint32(40,o,!0),8==r?l(a,44,t):16==r&amp;&amp;d(a,44,t),a}</span>(m(t),r);<span class="cstat-no" title="statement not covered" ></span>c.postMessage({command:"exportWav",val:s})}<span class="cstat-no" title="statement not covered" ></span>t.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(t.data.command){case"init":<span class="cstat-no" title="statement not covered" >c=t.data.val,e=c.sampleChannel,r=c.sampleBit,i=c.sampleRate,s=c.oldSampleRate,o=c.bufferSize,n=c.type;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"record":<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var r=0;r&lt;e;r++)<span class="cstat-no" title="statement not covered" >a[r]||(a[r]=[]),a[r].push(t[r]);v</span></span>ar o=<span class="cstat-no" title="statement not covered" >Math.round(s/i);<span class="cstat-no" title="statement not covered" ></span>"pcm"===n?f(o):"wav"===n&amp;&amp;v(o),a=[]}</span>(t.data.val)}</span>v</span>ar c}}</span>)),this.worker.postMessage({command:"init",val:{sampleChannel:this.channels,sampleBit:this.sampleBit,sampleRate:this.sampleRate,oldSampleRate:this.context.sampleRate,bufferSize:this.bufferSize,type:e}}),this.worker.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >switch(e.data.command){case"exportPcmLive":<span class="cstat-no" title="statement not covered" >r.onReceiveBuffer(e.data.val);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"exportWav":<span class="cstat-no" title="statement not covered" >r.onReceiveWav(e.data.val)}</span>}</span>}</span>,e.prototype.onReceiveBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.onReceiveWav=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},e.prototype.writeString=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >e.setUint8(t+i,r.charCodeAt(i))}</span></span>,e.prototype.writeBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;r.byteLength;i++)<span class="cstat-no" title="statement not covered" >e.setUint8(t+i,r[i])}</span></span>,e.prototype.concatenation=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t=0,r=0;r&lt;e.length;++r)<span class="cstat-no" title="statement not covered" >t+=e[r].buffer.byteLength;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >new Uint8Array(t),</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(r=0;r&lt;e.length;++r)<span class="cstat-no" title="statement not covered" >i.set(new Uint8Array(e[r].buffer),s),s+=e[r].buffer.byteLength;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>,e.prototype.encodeWave=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.concatenation(e),</span>r=<span class="cstat-no" title="statement not covered" >t.byteLength,</span>i=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(r+44),</span>s=<span class="cstat-no" title="statement not covered" >new DataView(i),</span>o=<span class="cstat-no" title="statement not covered" >this.sampleRate,</span>n=<span class="cstat-no" title="statement not covered" >this.sampleBit,</span>a=<span class="cstat-no" title="statement not covered" >this.channels;<span class="cstat-no" title="statement not covered" ></span>return this.writeString(s,0,"RIFF"),s.setUint32(4,36+r,!0),this.writeString(s,8,"WAVE"),this.writeString(s,12,"fmt "),s.setUint32(16,16,!0),s.setUint16(20,1,!0),s.setUint16(22,a,!0),s.setUint32(24,o,!0),s.setUint32(28,o*a*(n/8),!0),s.setUint16(32,a*(n/8),!0),s.setUint16(34,n,!0),this.writeString(s,36,"data"),s.setUint32(40,r,!0),this.writeBuffer(s,44,t),s}</span>,e.prototype.stop=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.mic.disconnect(),this.script.disconnect()}</span>,e}();t.MediaUtil=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0})},function(e,t,r){"use strict";var i=this&amp;&amp;this.__assign||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(i=Object.assign||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t,r=1,i=arguments.length;r&lt;i;r++)<span class="cstat-no" title="statement not covered" >for(var s in t=arguments[r])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,s)&amp;&amp;(e[s]=t[s]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>).apply(this,arguments)}</span>;Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e){this.log=e,this.dataStatistics={},this.logger=e}return e.prototype.newReport=function(e,t){this.dataStatistics[e]={event_time:Date.now(),time_consumed:0,seq:e,error:0,message:"success",event:t,events:[]}},e.prototype.addMsgExt=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >this.dataStatistics[e]?this.dataStatistics[e].msg_ext=t:console.warn(e+" not exist")}</span>,e.prototype.addMsgInfo=function(e,t){this.dataStatistics[e]?Object.assign(this.dataStatistics[e],t):<span class="branch-1 cbranch-no" title="branch not covered" >console.warn(e+" not exist")}</span>,e.prototype.eventStart=function(e,t){this.dataStatistics[e]?null!=this.dataStatistics[e].events?this.dataStatistics[e].events.push({event:t,event_time:Date.now(),time_consumed:0}):<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.warn("zd.es.0 no events"):<span class="branch-1 cbranch-no" title="branch not covered" ></span>this.logger.warn("zd.es.0 no seq match")}</span>,e.prototype.eventEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if(this.dataStatistics[e]){var i=<span class="cstat-no" title="statement not covered" >this.dataStatistics[e].events;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;0!==i.length){<span class="cstat-no" title="statement not covered" >for(var s=i.length-1;s&gt;=0;s--)<span class="cstat-no" title="statement not covered" >if(i[s].event==t&amp;&amp;0==i[s].time_consumed){<span class="cstat-no" title="statement not covered" >i[s].time_consumed=Date.now()-i[s].event_time;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zd.ee.0 no events")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zd.ee.0 no seq match")}</span></span>,e.prototype.eventEndWithMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if(this.dataStatistics[e]){var s=<span class="cstat-no" title="statement not covered" >this.dataStatistics[e].events;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >for(var o=s.length-1;o&gt;=0;o--)<span class="cstat-no" title="statement not covered" >if(s[o].event==t&amp;&amp;0==s[o].time_consumed){<span class="cstat-no" title="statement not covered" >s[o].time_consumed=Date.now()-s[o].event_time,null==s[o].msg_ext&amp;&amp;(s[o].msg_ext={}),s[o].msg_ext=i({},r);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.ee.0 no events")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.ee.0 no seq match")}</span></span>,e.prototype.eventEndWithMsgInfo=function(e,t,r){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.dataStatistics[e]){var i=this.dataStatistics[e].events;<span class="missing-if-branch" title="else path not taken" >E</span>if(i){for(var s=i.length-1;s&gt;=0;s--)<span class="missing-if-branch" title="else path not taken" >E</span>if(i[s].event==t&amp;&amp;0==i[s].time_consumed){i[s].time_consumed=Date.now()-i[s].event_time,Object.assign(i[s],r);break}}else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.ee.0 no events")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.ee.0 no seq match")}</span>,e.prototype.addEventInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,i){<span class="cstat-no" title="statement not covered" >if(this.dataStatistics[e]){var s=<span class="cstat-no" title="statement not covered" >this.dataStatistics[e].events;<span class="cstat-no" title="statement not covered" ></span>if(null!=s){<span class="cstat-no" title="statement not covered" >for(var o=s.length-1;o&gt;=0;o--)<span class="cstat-no" title="statement not covered" >if(s[o].event==t&amp;&amp;null!=s[o].time_consumed){<span class="cstat-no" title="statement not covered" >null==s[o].msg_ext?s[o].msg_ext={}:s[o].msg_ext&amp;&amp;(s[o].msg_ext[r]=i);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.aei.0 no events")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.aei.0 no seq match")}</span></span>,e.prototype.addEventMsg=function(e,t,r,i){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.dataStatistics[e]){var s=this.dataStatistics[e].events;<span class="missing-if-branch" title="else path not taken" >E</span>if(null!=s){for(var o=s.length-1;o&gt;=0;o--)<span class="missing-if-branch" title="else path not taken" >E</span>if(s[o].event==t){s[o][r]=i;break}}else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.aem.0 no events")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.aem.0 no seq match")}</span>,e.prototype.addEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >this.dataStatistics[e]?this.dataStatistics[e].events&amp;&amp;(r?this.dataStatistics[e].events.push({event:t,event_time:Date.now(),msg_ext:r}):this.dataStatistics[e].events.push({event:t,event_time:Date.now()})):this.logger.warn("zd.ae.0 no seq match")}</span>,e.prototype.uploadReport=function(e,t,r,i){var s=this.dataStatistics[e];null!=s&amp;&amp;(t&amp;&amp;(s.event=t),s.time_consumed=Date.now()-s.event_time,r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.addMsgInfo(e,{error:r.code,message:r.message+" "+(i||"")}),</span>this.logger.report(s),delete this.dataStatistics[e])},e}();t.ZegoDataReport=s}])}));</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Fri Jul 17 2020 12:23:43 GMT+0800 (中国标准时间)
            </div>
        </div>
        <script src="prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="sorter.js"></script>
        <script src="block-navigation.js"></script>
    </body>
</html>
    