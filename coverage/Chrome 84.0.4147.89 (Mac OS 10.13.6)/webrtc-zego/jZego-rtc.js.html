
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for webrtc-zego/jZego-rtc.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../prettify.css" />
    <link rel="stylesheet" href="../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../index.html">All files</a> / <a href="index.html">webrtc-zego</a> jZego-rtc.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">14.56% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>601/4128</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">8.79% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>431/4905</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">15.68% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>235/1499</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>1/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">148x</span></td><td class="text"><pre class="prettyprint lang-js">!function(t,i){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"==typeof exports&amp;&amp;"object"==typeof module)module.exports=i();else <span class="cstat-no" title="statement not covered" >if("function"==typeof define&amp;&amp;define.amd)<span class="cstat-no" title="statement not covered" >define([],i);e</span>lse{var n=<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" ></span>for(var l in n)<span class="cstat-no" title="statement not covered" >("object"==typeof exports?exports:t)[l]=n[l]}</span></span>}</span>("undefined"!=typeof self?self:<span class="branch-1 cbranch-no" title="branch not covered" >this,</span>function(){return function(t){var i={};function n(l){if(i[l])return i[l].exports;var p=i[l]={i:l,l:!1,exports:{}};return t[l].call(p.exports,p,p.exports,n),p.l=!0,p.exports}return n.m=t,n.c=i,n.d=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,l){<span class="cstat-no" title="statement not covered" >n.o(t,i)||Object.defineProperty(t,i,{enumerable:!0,get:l})}</span>,n.r=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"undefined"!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}</span>,n.t=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >if(1&amp;i&amp;&amp;(t=n(t)),8&amp;i)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(4&amp;i&amp;&amp;"object"==typeof t&amp;&amp;t&amp;&amp;t.__esModule)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(n.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:t}),2&amp;i&amp;&amp;"string"!=typeof t)<span class="cstat-no" title="statement not covered" >for(var p in t)<span class="cstat-no" title="statement not covered" >n.d(l,p,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return t[i]}</span>.bind(null,p));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn l}</span>,n.n=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.__esModule?<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.default}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t}</span>;<span class="cstat-no" title="statement not covered" ></span>return n.d(i,"a",i),i}</span>,n.o=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(t,i)}</span>,n.p="",n(n.s=5)}([function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.PROTO_VERSION="1.8.0",i.ROOMVERSION="V1",function(t){t[t.debug=0]="debug",t[t.info=1]="info",t[t.warn=2]="warn",t[t.error=3]="error",t[t.report=99]="report",t[t.disable=100]="disable"}(i.ENUM_LOG_LEVEL||(i.ENUM_LOG_LEVEL={})),function(t){t[t.disable=0]="disable",t[t.websocket=1]="websocket",t[t.https=2]="https"}(i.ENUM_REMOTE_TYPE||(i.ENUM_REMOTE_TYPE={}));var l=function(){function t(t,i){void 0===t&amp;&amp;(t=null),void 0===i&amp;&amp;(i=null),this._id=null,this.next=null,this.prev=null,this._id=t,this._data=i}return Object.defineProperty(t.prototype,"id",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._id}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._id=t}</span>,enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"data",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._data}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._data=t}</span>,enumerable:!0,configurable:!0}),t.prototype.hasNext=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.next&amp;&amp;this.next.id}</span>,t.prototype.hasPrev=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.prev&amp;&amp;this.prev.id}</span>,t}();i.ListNode=l;var p=function(){function t(){this.start=new l,this.end=new l,this._idCounter=0,this._numNodes=0,this.start.next=this.end,this.start.prev=null,this.end.prev=this.start,this.end.next=null}return t.prototype.insertBefore=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >new l(this._idCounter,i);<span class="cstat-no" title="statement not covered" ></span>return n.next=t,n.prev=t.prev,t.prev.next=n,t.prev=n,++this._idCounter,++this._numNodes,n}</span>,t.prototype.addLast=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.insertBefore(this.end,t)}</span>,t.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.addLast(t)}</span>,t.prototype.getFirst=function(){return 0===this._numNodes?null:<span class="branch-1 cbranch-no" title="branch not covered" >this.start.next}</span>,t.prototype.getLast=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0===this._numNodes?null:this.end.prev}</span>,t.prototype.size=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._numNodes}</span>,t.prototype.getFromFirst=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.start.next;<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=0)<span class="cstat-no" title="statement not covered" >for(;i&lt;t&amp;&amp;null!==n;)<span class="cstat-no" title="statement not covered" >n=n.next,++i;e</span></span>lse <span class="cstat-no" title="statement not covered" >n=null;<span class="cstat-no" title="statement not covered" >i</span></span>f(null===n)<span class="cstat-no" title="statement not covered" >throw"Index out of bounds.";<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,t.prototype.get=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0===t?this.getFirst():t===this._numNodes-1?this.getLast():this.getFromFirst(t)}</span>,t.prototype.remove=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.prev.next=t.next,t.next.prev=t.prev,--this._numNodes,t}</span>,t.prototype.removeFirst=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return this._numNodes&gt;0&amp;&amp;(t=this.remove(this.start.next)),t}</span>,t.prototype.removeLast=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return this._numNodes&gt;0&amp;&amp;(t=this.remove(this.end.prev)),t}</span>,t.prototype.removeAll=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.start.next=this.end,this.end.prev=this.start,this._numNodes=0,this._idCounter=0}</span>,t.prototype.each=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i=this.start;i.hasNext();)<span class="cstat-no" title="statement not covered" >t(i=i.next)}</span></span>,t.prototype.find=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i=this.start,n=!1,l=null;i.hasNext()&amp;&amp;!n;)<span class="cstat-no" title="statement not covered" >t(i=i.next)&amp;&amp;(l=i,n=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>,t.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i=this.start,n=[];i.hasNext();)<span class="cstat-no" title="statement not covered" >t(i=i.next)&amp;&amp;n.push(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,t.prototype.push=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.addLast(t)}</span>,t.prototype.unshift=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._numNodes&gt;0?this.insertBefore(this.start.next,t):this.insertBefore(this.end,t)}</span>,t.prototype.pop=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.removeLast()}</span>,t.prototype.shift=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.removeFirst()}</span>,t}();i.LinkedList=p,i.sdkErrorList={SUCCESS:{code:"ZegoClient.Success",msg:"success."},PARAM:{code:"ZegoClient.Error.Param",msg:"input error."},HEARTBEAT_TIMEOUT:{code:"ZegoClient.Error.Timeout",msg:"heartbeat timeout."},LOGIN_TIMEOUT:{code:"ZegoClient.Error.Timeout",msg:"login timeout."},SEND_MSG_TIMEOUT:{code:"ZegoClient.Error.Timeout",msg:"send customsg timeout."},RESET_QUEUE:{code:"ZegoClient.Error.Timeout",msg:"msg waiting ack is clear when reset."},LOGIN_DISCONNECT:{code:"ZegoClient.Error.Network",msg:"network is broken and login fail."},KICK_OUT:{code:"ZegoClient.Error.Kickout",msg:"kickout reason="},UNKNOWN:{code:"ZegoClient.Error.Unknown",msg:"unknown error."},FREQ_LIMITED:{code:"ZegoClient.Error.requencyLimited",msg:"Frequency Limited."}},function(t){t[t.disconnected=0]="disconnected",t[t.connecting=1]="connecting",t[t.connected=2]="connected"}(i.ENUM_SIGNAL_STATE||(i.ENUM_SIGNAL_STATE={})),i.ENUM_RESOLUTION_TYPE={LOW:{width:240,height:320,frameRate:15,bitRate:300},MEDIUM:{width:480,height:640,frameRate:15,bitRate:800},HIGH:{width:720,height:1280,frameRate:20,bitRate:1500}},i.ENUM_RETRY_STATE={didNotStart:0,retrying:1,finished:2},i.ENUM_PUBLISH_STATE={start:0,waitingSessionRsp:1,waitingOffserRsp:2,waitingServerAnswer:3,waitingServerICE:4,connecting:5,publishing:6,stop:7,didNotStart:8},i.ENUM_PUBLISH_STATE_NEGO={stop:0,start:1,waiterAnswer:2,waitingCandidate:3,sendCandidate:4,iceConnected:5},i.ENUM_PLAY_STATE={start:0,waitingSessionRsp:1,waitingOffserRsp:2,waitingServerAnswer:3,waitingServerICE:4,connecting:5,playing:6,stop:7,didNotStart:8},i.ENUM_PLAY_STATE_NEGO={stop:0,start:1,waiterAnswer:2,waitingCandidate:3,sendCandidate:4,iceConnected:5},i.ENUM_CONNECT_STATE={disconnect:0,connecting:1,connected:2},i.MAX_TRY_CONNECT_COUNT=1,i.SEND_MSG_RESET=2,i.SEND_MSG_TIMEOUT=1,i.MAX_TRY_HEARTBEAT_COUNT=5,i.ENUM_PUBLISH_STREAM_STATE={waiting_url:1,tryPublish:2,update_info:3,publishing:4,stop:5},i.ENUM_STREAM_SUB_CMD={liveNone:0,liveBegin:2001,liveEnd:2002,liveUpdate:2003},i.ENUM_STREAM_UPDATE_TYPE={added:0,deleted:1},function(t){t[t.logout=0]="logout",t[t.trylogin=1]="trylogin",t[t.login=2]="login"}(i.ENUM_RUN_STATE||(i.ENUM_RUN_STATE={})),i.ENUM_PUBLISH_STATE_UPDATE={start:0,error:1,retry:2},i.ENUM_PLAY_STATE_UPDATE={start:0,error:1,retry:2},i.MAX_TRY_LOGIN_COUNT=5,i.TRY_LOGIN_INTERVAL=[2e3,4e3,6e3,8e3,1e4],i.MINIUM_HEARTBEAT_INTERVAL=3e3,i.ENUM_STREAM_UPDATE_CMD={added:12001,deleted:12002,updated:12003},i.SERVER_ERROR_CODE=1e4,i.MIXSTREAM_ERROR_CODE=1e4,function(t){t[t.low=1]="low",t[t.stantard=2]="stantard",t[t.hight=3]="hight",t[t.custome=4]="custome"}(i.QUALITYLEVEL||(i.QUALITYLEVEL={})),i.ENUM_SIGNAL_SUB_CMD={none:0,joinLiveRequest:1001,joinLiveResult:1002,joinLiveInvite:1003,joinLiveStop:1004},i.ENUM_PUSH_SIGNAL_SUB_CMD={none:0,pushJoinLiveRequest:11001,pushJoinLiveResult:11002,pushJoinLiveInvite:11003,pushJoinLiveStop:11004},function(t){t[t.auto=0]="auto",t[t.ultra=1]="ultra"}(i.ENUM_PLAY_SOURCE_TYPE||(i.ENUM_PLAY_SOURCE_TYPE={})),function(t){t[t.stop=0]="stop",t[t.start=1]="start"}(i.ENUM_BROADCASTER_STATUS||(i.ENUM_BROADCASTER_STATUS={})),function(t){t[t.cdn=0]="cdn",t[t.ultra=1]="ultra",t[t.customUrl=2]="customUrl"}(i.ENUM_DISPATCH_TYPE||(i.ENUM_DISPATCH_TYPE={})),function(t){t[t.ClientType_None=0]="ClientType_None",t[t.ClientType_H5=1]="ClientType_H5",t[t.ClientType_SmallPragram=2]="ClientType_SmallPragram",t[t.ClientType_Webrtc=3]="ClientType_Webrtc"}(i.E_CLIENT_TYPE||(i.E_CLIENT_TYPE={}))},function(t,i,n){"use strict";var l;Object.defineProperty(i,"__esModule",{value:!0}),i.playErrorList={DISPATCH_ERROR:{code:"ZegoPlayWeb.Error.Dispatch",msg:"dispatch request error"},DISPATCH_TIMEOUT:{code:"ZegoPlayWeb.Timeout.Dispatch",msg:"dispatch request timeout"},TOKEN_ERROR:{code:"ZegoPlayWeb.Error.Token",msg:"login token error"},SEND_SESSION_TIMEOUT:{code:"ZegoPlayWeb.Timeout.Session",msg:"send session request timeout"},CREATE_SESSION_ERROR:{code:"ZegoPlayWeb.Error.Session",msg:"create session error"},CREATE_OFFER_ERROR:{code:"ZegoPublish.Error.CreateOffer",msg:"create offer error"},SERVER_MEDIA_DESC_TIMEOUT:{code:"ZegoPlayWeb.Timeout.RemoteOffer",msg:"wating server mediaDesc timeout"},SET_REMOTE_DESC_ERROR:{code:"ZegoPlayWeb.Error.RemoteOffer",msg:"other side offer error"},CREATE_ANSWER_ERROR:{code:"ZegoPlayWeb.Error.CreateAnswer",msg:"create offer error"},SET_LOCAL_DESC_ERROR:{code:"ZegoPlayWeb.Error.LocalDesc",msg:"setLocalDescription error"},SEND_MEDIA_DESC_TIMEOUT:{code:"ZegoPlayWeb.Timeout.Desc",msg:"send mediaDesc timeout"},SEND_CANDIDATE_ERROR:{code:"ZegoPlayWeb.Error.Candidate",msg:"send candidate error"},SEND_CANDIDATE_TIMEOUT:{code:"ZegoPlayWeb.Timeout.Candidate",msg:"send candidate timeout"},SERVER_NEGO_TIMEOUT:{code:"ZegoPlayWeb.Timeout.negotiation",msg:"negotiation timeout"},SERVER_CANDIDATE_TIMEOUT:{code:"ZegoPlayWeb.Timeout.ServerCandidate",msg:"waiting candidate timeout"},SERVER_CANDIDATE_ERROR:{code:"ZegoPlayWeb.Error.ServerCandidate",msg:"recv candidate error"},MEDIA_CONNECTION_FAILED:{code:"ZegoPlayWeb.Error.ConnectionFailed",msg:"ice Connection state failed"},MEDIA_CONNECTION_CLOSED:{code:"ZegoPlayWeb.Error.ConnectionClosed",msg:"ice connection state closed"},SESSION_CLOSED:{code:"ZegoPlayWeb.Error.SessionClosed",msg:"server session closed"},WEBSOCKET_ERROR:{code:"ZegoPlayWeb.Error.SocketError",msg:"network error"}},i.publishErrorList={DISPATCH_ERROR:{code:"ZegoPublish.Error.Dispatch",msg:"dispatch request error"},DISPATCH_TIMEOUT:{code:"ZegoPublish.Timeout.Dispatch",msg:"dispatch request timeout"},TOKEN_ERROR:{code:"ZegoPublish.Error.Token",msg:"login token error"},SEND_SESSION_TIMEOUT:{code:"ZegoPublish.Timeout.Session",msg:"send session request timeout"},CREATE_SESSION_ERROR:{code:"ZegoPublish.Error.Session",msg:"create session error"},CREATE_OFFER_ERROR:{code:"ZegoPublish.Error.CreateOffer",msg:"create offer error"},SET_LOCAL_DESC_ERROR:{code:"ZegoPublish.Error.LocalDesc",msg:"setLocalDescription error"},SEND_MEDIA_DESC_TIMEOUT:{code:"ZegoPublish.Timeout.Desc",msg:"send mediaDesc timeout"},SERVER_MEDIA_DESC_TIMEOUT:{code:"ZegoPublish.Timeout.ServerAnswer",msg:"waiting server mediaDesc timeout"},SERVER_MEDIA_DESC_ERROR:{code:"ZegoPublish.Error.ServerAnswer",msg:"server mediaDesc type error"},SET_REMOTE_DESC_ERROR:{code:"ZegoPublish.Error.RemoteDesc",msg:"other side offer error"},SEND_CANDIDATE_TIMEOUT:{code:"ZegoPublish.Timeout.Candidate",msg:"sendIceCandidate error"},SERVER_CANDIDATE_TIMEOUT:{code:"ZegoPublish.Timeout.ServerCandidate",msg:"waiting candidate timeout"},SERVER_NEGO_TIMEOUT:{code:"ZegoPublish.Timeout.negotiation",msg:"negotiation timeout"},SERVER_CANDIDATE_ERROR:{code:"ZegoPublish.Error.ServerCandidate",msg:"recv candidate error"},SESSION_CLOSED:{code:"ZegoPublish.Error.SessionClosed",msg:"server session closed"},MEDIA_CONNECTION_FAILED:{code:"ZegoPublish.Error.IConnectionFailed",msg:"Iice Connection state failed"},MEDIA_CONNECTION_CLOSED:{code:"ZegoPublish.Error.ConnectionClosed",msg:"ice connection state closed"},MEDIA_CONNECTION_DISCONNECTED:{code:"ZegoPublish.Error.IConnectionDisconnected",msg:"ice connection state disconnected"},WEBSOCKET_ERROR:{code:"ZegoPublish.Error.SocketError",msg:"network error"}},i.ENUM_PUBLISH_STATE_UPDATE={start:0,error:1,retry:2},i.ENUM_PLAY_STATE_UPDATE={start:0,error:1,retry:2,stop:3},i.ENUM_RETRY_STATE={didNotStart:0,retrying:1,finished:2},i.getSeq=(l=1,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return l++}</span>)},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=function(){function <span class="fstat-no" title="function not covered" >t(</span>){}return t.checkConfigParam=function(t,i){return t.appid&amp;&amp;"number"==typeof t.appid?!t.server||t.server.length&lt;1||"string"!=typeof t.server&amp;&amp;!Array.isArray(t.server)?(<span class="branch-0 cbranch-no" title="branch not covered" >i.error("ccp.0 server must be string or string[] and not empty"),!1)</span>:!(!t.idName||"string"!=typeof t.idName)||(<span class="branch-1 cbranch-no" title="branch not covered" >i.error("ccp.0 idName must be string and not empty"),!1)</span>:(<span class="branch-1 cbranch-no" title="branch not covered" >i.error("ccp.0 appid must be number"),!1)</span>},t.checkLoginParam=function(t,i){return!0},t.checkPreviewParam=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >t.bitRate;<span class="cstat-no" title="statement not covered" ></span>if(4===t.videoQuality||t.externalMediaStream){<span class="cstat-no" title="statement not covered" >if("number"!=typeof t.width)<span class="cstat-no" title="statement not covered" >return i.error("zc.p.sp.0 width must be number"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f("number"!=typeof t.height)<span class="cstat-no" title="statement not covered" >return i.error("zc.p.sp.0 height must be number"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f("number"!=typeof t.frameRate)<span class="cstat-no" title="statement not covered" >return i.error("zc.p.sp.0 frameRate must be number"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f("number"==typeof n)<span class="cstat-no" title="statement not covered" >n&lt;48&amp;&amp;(n=48),n&gt;1e4&amp;&amp;(n=1e4),t.minBitRate=t.maxBitRate=t.bitRate;e</span>lse <span class="cstat-no" title="statement not covered" >if(n.minBitRate&amp;&amp;n.maxBitRate&amp;&amp;"number"==typeof n.minBitRate&amp;&amp;"number"==typeof n.maxBitRate&amp;&amp;n.minBitRate&lt;=n.maxBitRate)<span class="cstat-no" title="statement not covered" >t.minBitRate=n.minBitRate&lt;48?48:n.minBitRate,t.maxBitRate=n.maxBitRate&gt;1e4?1e4:n.maxBitRate;e</span>lse <span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >return i.error("zc.p.sp.0 bitRate must be number or object which has minBitRate and maxBitRate"),!1}<span class="cstat-no" title="statement not covered" ></span></span></span></span>r</span>eturn!0}</span>,t.registerCallback=function(t,i,n){var l,p;i.success&amp;&amp;(l=i.success),i.error&amp;&amp;(p=i.error),n[t+"SuccessCallback"]=l,n[t+"ErrorCallback"]=p},t.actionErrorCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return i[t+"ErrorCallback"]}</span>,t.actionSuccessCallback=function(t,i){return i[t+"SuccessCallback"]},t.getServerError=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >{1:"parse json error.",1001:"login is processing.",1002:"liveroom request error.",1003:"zpush connect fail.",1004:"zpush handshake fail.",1005:"zpush login fail.",1006:"user login state is wrong.",1007:"got no zpush addr",1008:"token error",1009:"dispatch error",1010:"token expired",2002:"biz channel error",1000000000:"liveroom cmd error, result="};<span class="cstat-no" title="statement not covered" ></span>if(0===t)<span class="cstat-no" title="statement not covered" >return{code:"ZegoClient.Success",msg:"success"};v</span></span>ar n=<span class="cstat-no" title="statement not covered" >{code:"ZegoClient.Error.Server",msg:""};<span class="cstat-no" title="statement not covered" ></span>return n.msg=t&gt;1e9?i[1e9]+t:i[t]?i[t]:"unknown error code:"+t,n}</span>,t.isKeepTryLogin=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(t){case 1002:case 1003:<span class="cstat-no" title="statement not covered" >return!0;d</span>efault:<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>,t.mergeStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){<span class="cstat-no" title="statement not covered" >t.debug("msl.0 call");v</span>ar e,v=<span class="cstat-no" title="statement not covered" >[],</span>T=<span class="cstat-no" title="statement not covered" >[],</span>E=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>l||(l=[]);<span class="cstat-no" title="statement not covered" >f</span>or(var S=0;S&lt;l.length;S++)<span class="cstat-no" title="statement not covered" >if(l[S].anchor_id_name!=i){<span class="cstat-no" title="statement not covered" >e=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var R=0;R&lt;n.length;R++)<span class="cstat-no" title="statement not covered" >if(l[S].stream_id===n[R].stream_id){<span class="cstat-no" title="statement not covered" >l[S].extra_info!==n[R].extra_info&amp;&amp;E.push(l[S]),e=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>e</span></span>||v.push(l[S])}</span>else <span class="cstat-no" title="statement not covered" >t.debug("msl.0 have self stream added");<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var r=0;r&lt;n.length;r++){<span class="cstat-no" title="statement not covered" >e=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var h=0;h&lt;l.length;h++)<span class="cstat-no" title="statement not covered" >if(n[r].stream_id===l[h].stream_id){<span class="cstat-no" title="statement not covered" >e=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>e</span></span>||T.push(n[r])}<span class="cstat-no" title="statement not covered" ></span>n</span>.splice(0);<span class="cstat-no" title="statement not covered" >f</span>or(S=0;S&lt;l.length;S++)<span class="cstat-no" title="statement not covered" >n.push(l[S]);<span class="cstat-no" title="statement not covered" >p</span></span>(v,T,E),t.debug("msl.0 call success")}</span>,t.checkCustomCommandParam=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!0}</span>,t.generateRandumNumber=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return parseInt(Math.random()*(t+1)+"",10)}</span>,t.uuid=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n,l=<span class="cstat-no" title="statement not covered" >"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),</span>p=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(i=i||l.length,t)<span class="cstat-no" title="statement not covered" >for(n=0;n&lt;t;n++)<span class="cstat-no" title="statement not covered" >p[n]=l[0|Math.random()*i];e</span></span>lse{var e=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>for(p[8]=p[13]=p[18]=p[23]="-",p[14]="4",n=0;n&lt;36;n++)<span class="cstat-no" title="statement not covered" >p[n]||(e=0|16*Math.random(),p[n]=l[19==n?3&amp;e|8:e])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn p.join("")}</span>,t.supportDetection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >{webRtc:!1,capture:!1,videoDecodeType:{H264:!1,VP8:!1},screenSharing:t};<span class="cstat-no" title="statement not covered" ></span>navigator&amp;&amp;(navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.msGetUserMedia||navigator.mozGetUserMedia||navigator.mediaDevices&amp;&amp;navigator.mediaDevices.getUserMedia)&amp;&amp;(l.capture=!0),window.RTCPeerConnection||window.mozRTCPeerConnection||window.webkitRTCPeerConnection?(l.webRtc=!0,this.supportVideoCodeType(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.videoDecodeType.H264=t.H264,l.videoDecodeType.VP8=t.VP8,i&amp;&amp;i(l)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n&amp;&amp;n(t)}</span>)):i&amp;&amp;i(l)}</span>,t.compareVersion=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t=t.split("."),i=i.split(".");<span class="cstat-no" title="statement not covered" >f</span>or(var n=Math.max(t.length,i.length);t.length&lt;n;)<span class="cstat-no" title="statement not covered" >t.push("0");<span class="cstat-no" title="statement not covered" >f</span></span>or(;i.length&lt;n;)<span class="cstat-no" title="statement not covered" >i.push("0");<span class="cstat-no" title="statement not covered" >f</span></span>or(var l=0;l&lt;n;l++){var p=<span class="cstat-no" title="statement not covered" >parseInt(t[l]),</span>e=<span class="cstat-no" title="statement not covered" >parseInt(i[l]);<span class="cstat-no" title="statement not covered" ></span>if(p&gt;e)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f(p&lt;e)<span class="cstat-no" title="statement not covered" >return-1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn 0}</span>,t.isSupportLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >"当前微信版本过低，无法使用相关组件",</span>l=<span class="cstat-no" title="statement not covered" >"需要摄像头和录音功能的授权",</span>p=<span class="cstat-no" title="statement not covered" >wx.getSystemInfoSync().SDKVersion,</span>e=<span class="cstat-no" title="statement not covered" >{code:-1,msg:""};<span class="cstat-no" title="statement not covered" ></span>this.compareVersion(p,"1.7.0")&lt;0&amp;&amp;(e={code:10001,msg:n},t&amp;&amp;t(e)),wx.getSetting({success:<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >i.authSetting;<span class="cstat-no" title="statement not covered" ></span>n["scope.camera"]&amp;&amp;n["scope.record"]||(e={code:10002,msg:l}),t&amp;&amp;t(e)}</span>,fail:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i(t)}</span>})}</span>,t.isSupportQQLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >"当前微信版本过低，无法使用相关组件",</span>l=<span class="cstat-no" title="statement not covered" >"需要摄像头和录音功能的授权",</span>p=<span class="cstat-no" title="statement not covered" >qq.getSystemInfoSync().SDKVersion,</span>e=<span class="cstat-no" title="statement not covered" >{code:-1,msg:""};<span class="cstat-no" title="statement not covered" ></span>this.compareVersion(p,"1.7.0")&lt;0&amp;&amp;(e={code:10001,msg:n},t&amp;&amp;t(e)),qq.getSetting({success:<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >i.authSetting;<span class="cstat-no" title="statement not covered" ></span>n["scope.camera"]&amp;&amp;n["scope.record"]||(e={code:10002,msg:l}),t&amp;&amp;t(e)}</span>,fail:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i(t)}</span>})}</span>,t.supportVideoCodeType=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>new RTCPeerConnection(null).createOffer({offerToReceiveAudio:1,offerToReceiveVideo:1}).then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >if(i&amp;&amp;i.sdp){<span class="cstat-no" title="statement not covered" >n=!0;v</span>ar l=<span class="cstat-no" title="statement not covered" >i.sdp.split("\r\n"),</span>p=<span class="cstat-no" title="statement not covered" >l.some(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.startsWith("a=rtpmap:")&amp;&amp;t.indexOf("H264/")&gt;-1}</span>),</span>e=<span class="cstat-no" title="statement not covered" >l.some(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.startsWith("a=rtpmap:")&amp;&amp;t.indexOf("VP8/")&gt;-1}</span>),</span>v=<span class="cstat-no" title="statement not covered" >l.some(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.startsWith("a=rtpmap:")&amp;&amp;t.indexOf("VP9/")&gt;-1}</span>),</span>T=<span class="cstat-no" title="statement not covered" >l.some(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.startsWith("a=rtpmap:")&amp;&amp;t.indexOf("H264/")&gt;-1}</span>);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t({H264:p,VP8:e,VP9:v,H265:T})}</span>}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n=!0,clearTimeout(l),i&amp;&amp;i(t)}</span>);v</span>ar l=<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >0==n&amp;&amp;i(!1)}</span>,200)}</span>,t.inlineWorker=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(Worker){var i=<span class="cstat-no" title="statement not covered" >t.toString().trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1],</span>n=<span class="cstat-no" title="statement not covered" >URL.createObjectURL(new window.Blob([i],{type:"text/javascript"}));<span class="cstat-no" title="statement not covered" ></span>return new Worker(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>,t}();i.ClientUtil=l},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=function(){function t(t,i){this.audioBufferList=[],this.loop=!1,this.replace=!1,this.effectEndedCallBack=null,this.effectEndedListener=null,this.startTimes=0,this.startOffset=0,this.pauseTimes=0,this.resumeOffset=0,this.isMixAudio=!1,this.isMixingBuffer=!1,this.logger=t,this.ac=i}return t.prototype.preloadEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("amu.pe.0 start preload effect");v</span>ar l=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>l.open("GET",t,!0),l.responseType="arraybuffer",l.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(200==l.status||304==l.status){var t=<span class="cstat-no" title="statement not covered" >l.response;<span class="cstat-no" title="statement not covered" ></span>n.ac.decodeAudioData(t,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.logger.info("amu.pe.0 effect preload success"),i("",t)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i(t)}</span>)}</span>else{var p=<span class="cstat-no" title="statement not covered" >l.statusText;<span class="cstat-no" title="statement not covered" ></span>i(p)}</span>}</span>,l.send()}</span>,t.prototype.playEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>!0!==this.isMixAudio?this.audioBuffer?(this.startOffset=t||0,this.loop=i||!1,this.replace=n||!1,this.effectEndedCallBack=p,this.mixEffect(this.audioBuffer,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.buffSource.loop=!!i,t?e.buffSource.start(0,t/1e3):e.buffSource.start(0),e.startTimes=Date.now(),e.effectEndedListener=e.effectEndedHandler.bind(e),e.buffSource.addEventListener("ended",e.effectEndedListener),l&amp;&amp;l()}</span>)):this.logger.error("amu.pe.1 no audio buffer found"):this.logger.error("amu.pe.1 audio is mixing")}</span>,t.prototype.mixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>!0!==this.isMixAudio||0!=this.audioBufferList.length||0!=this.isMixingBuffer?this.ac.decodeAudioData(t,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.audioBufferList.push(t),1==n.audioBufferList.length&amp;&amp;n.playRealTimeEffect(n.audioBufferList[0]),n.isMixingBuffer=!0,i&amp;&amp;i()}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.logger.error("amu.mb.0 "+t),i&amp;&amp;i(t)}</span>):this.logger.error("amu.mb.0 audio is mixing")}</span>,t.prototype.stopMingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isMixingBuffer=!1,this.stopMixingAudio()}</span>,t.prototype.playRealTimeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.mixEffect(t,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.buffSource.start(0),i.buffSource.addEventListener("ended",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.audioBufferList.shift(),i.audioBufferList.length&gt;0&amp;&amp;i.isMixAudio&amp;&amp;i.playRealTimeEffect(i.audioBufferList[0])}</span>)}</span>)}</span>,t.prototype.pauseEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.audioBufferList.length&gt;0?this.logger.error("amu.pe.0 real time buffer can not be paused"):(this.stopMixingAudio(),this.resumeOffset=(this.pauseTimes-this.startTimes+this.startOffset)%(1e3*this.audioBuffer.duration))}</span>,t.prototype.resumeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.audioBufferList.length&gt;0?this.logger.error("amu.pe.0 real time buffer can not be resume"):(this.playEffect(this.resumeOffset,this.loop,this.replace,null,this.effectEndedCallBack),this.startOffset=this.resumeOffset)}</span>,t.prototype.mixEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.localStream?(this.gainNode=this.ac.createGain(),this.buffSource=this.ac.createBufferSource(),this.buffSource.buffer=t,this.buffSource.connect(this.gainNode),this.gainNode.connect(this.ac.destination),this.replaceTrack()&amp;&amp;i()):this.logger.error("amu.me.0 localStream can not be found")}</span>,t.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return this.replace=i||!1,this.isMixAudio?(this.logger.error("amu.sma.0 audio is mixing"),!1):this.localStream?(t.captureStream=t.captureStream||t.mozCaptureStream||t.webkitCaptureStream,this.gainNode=this.ac.createGain(),this.mixAudio=this.ac.createMediaStreamSource(t.captureStream()),this.mixAudio.connect(this.gainNode),this.replaceTrack()):(this.logger.error("amu.sma.0 localStream can not be found"),!1)}</span>,t.prototype.replaceTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.streamSource=this.ac.createMediaStreamSource(this.localStream),this.destination=this.ac.createMediaStreamDestination(),!this.replace&amp;&amp;this.streamSource.connect(this.destination),this.gainNode.connect(this.destination);v</span>ar t=<span class="cstat-no" title="statement not covered" >this.destination.stream.getAudioTracks()[0],</span>i=<span class="cstat-no" title="statement not covered" >this.peerConnection.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track.kind===t.kind}</span>);<span class="cstat-no" title="statement not covered" ></span>return i?(this.micTrack=this.localStream.getAudioTracks()[0],i.replaceTrack(t),this.localStream.removeTrack(this.micTrack),this.localStream.addTrack(t),this.isMixAudio=!0,!0):(this.logger.error("amu.rt.0 no sender"),!1)}</span>,t.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isMixAudio?this.localStream?(this.mixAudio?(this.mixAudio.disconnect(this.gainNode),this.mixAudio=null):this.buffSource&amp;&amp;(this.buffSource.removeEventListener("ended",this.effectEndedListener),this.buffSource.stop(),this.pauseTimes=Date.now(),this.buffSource.disconnect(this.gainNode),this.buffSource=null),this.gainNode.disconnect(this.destination),this.isMixAudio=!1,this.audioBufferList=[],!0):(this.logger.error("amu.sma.1 localStream can not be found"),!1):(this.logger.error("amu.sma.1 no mixing audio found"),!1)}</span>,t.prototype.setMixingAudioVolume=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!this.gainNode)<span class="cstat-no" title="statement not covered" >return this.logger.error("amu.sma.2 no mixing audio found"),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.gainNode.gain.value=t}</span>,t.prototype.effectEndedHandler=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.stopMixingAudio(),this.effectEndedCallBack&amp;&amp;this.effectEndedCallBack()}</span>,t}();i.audioMixUtil=l},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=function(){function <span class="fstat-no" title="function not covered" >t(</span>){}return t.zegoSdp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.split("\r\n"),</span>n=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.match(/a=rtpmap:(\d+)\s+((H264\/90000)|(opus\/48000\/2))/);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i[1]&amp;&amp;i[2]&amp;&amp;("H264/90000"===i[2]&amp;&amp;n.push(i[1]),"opus/48000/2"===i[2]&amp;&amp;l.push(i[1]))}</span>);v</span>ar p=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return i.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >!0,</span>e=<span class="cstat-no" title="statement not covered" >t.match(/((a=rtcp-fb:)|(a=rtpmap:)|(a=fmtp:))(\d+)/);<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;e[5]&amp;&amp;(n.concat(l).some(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t==e[5]}</span>)||(i=!1)),t.indexOf("m=video")&gt;-1){var v=<span class="cstat-no" title="statement not covered" >t.split(" ");<span class="cstat-no" title="statement not covered" ></span>t=[v[0],v[1],v[2]].concat(n).join(" ")}</span>else <span class="cstat-no" title="statement not covered" >if(t.indexOf("m=audio")&gt;-1){<span class="cstat-no" title="statement not covered" >v=t.split(" ");<span class="cstat-no" title="statement not covered" >t</span>=[v[0],v[1],v[2]].concat(l).join(" ")}<span class="cstat-no" title="statement not covered" ></span>i</span></span>&amp;&amp;p.push(t)}</span>),p.join("\r\n")}</span>,t.getSDPByVideDecodeType=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >{str:"",arr:[],obj:{H264:[],H265:[],VP8:[],VP9:[],OHTER:[]}};<span class="cstat-no" title="statement not covered" ></span>if(!t.includes("m=video"))<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >/m=video.+/.exec(t)[0];<span class="cstat-no" title="statement not covered" ></span>l=l.match(/[\s|\d]+/g)[1].replace(" ",""),n.str=l,n.arr=n.str.split(" "),n.arr.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var l=<span class="cstat-no" title="statement not covered" >new RegExp("a=rtpmap:"+i+".+").exec(t)[0];<span class="cstat-no" title="statement not covered" ></span>l.includes("H264")?n.obj.H264.push(i):l.includes("H265")?n.obj.H265.push(i):l.includes("VP8")?n.obj.VP8.push(i):l.includes("VP9")?n.obj.VP9.push(i):n.obj.OHTER.push(i)}</span>),n.obj.OHTER.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var l=<span class="cstat-no" title="statement not covered" >new RegExp("a=fmtp:"+i+".+apt=(\\d+)").exec(t),</span>p=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l[1];<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(n.obj.H264.includes(p)?n.obj.H264.push(i):n.obj.H265.includes(p)?n.obj.H265.push(i):n.obj.VP8.includes(p)?n.obj.VP8.push(i):n.obj.VP9.includes(p)&amp;&amp;n.obj.VP9.push(i))}</span>);v</span>ar p=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return"VP9"===i?p=n.obj.H265.concat(n.obj.H264,n.obj.VP8):"VP8"===i?p=n.obj.H265.concat(n.obj.H264,n.obj.VP9):"H264"===i?p=n.obj.H265.concat(n.obj.VP8,n.obj.VP9):"H265"===i&amp;&amp;(p=n.obj.VP8.concat(n.obj.H264,n.obj.VP9)),p.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var l=<span class="cstat-no" title="statement not covered" >n.arr.indexOf(i);<span class="cstat-no" title="statement not covered" ></span>n.arr.splice(l,1);v</span>ar p=<span class="cstat-no" title="statement not covered" >new RegExp("a=rtpmap:"+i+".+\\s\\n","g"),</span>e=<span class="cstat-no" title="statement not covered" >new RegExp("a=rtcp-fb:"+i+".+\\s\\n","g"),</span>v=<span class="cstat-no" title="statement not covered" >new RegExp("a=fmtp:"+i+".+\\s\\n","g");<span class="cstat-no" title="statement not covered" ></span>t=(t=(t=t.replace(p,"")).replace(e,"")).replace(v,"")}</span>),t=t.replace(l,n.arr.join(" "))}</span>,t}();i.sdpUtil=l},function(t,i,n){"use strict";var l,p=this&amp;&amp;this.__extends||(l=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.__proto__=i}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >for(var n in i)<span class="cstat-no" title="statement not covered" >i.hasOwnProperty(n)&amp;&amp;(t[n]=i[n])}</span></span>,</span>function(t,i){function n(){this.constructor=t}l(t,i),t.prototype=null===i?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(i):</span>(n.prototype=i.prototype,new n)}),e=this&amp;&amp;this.__assign||Object.assign||<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i,n=1,l=arguments.length;n&lt;l;n++)<span class="cstat-no" title="statement not covered" >for(var p in i=arguments[n])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(i,p)&amp;&amp;(t[p]=i[p]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>,</span>v=this&amp;&amp;this.__awaiter||<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >return new(n||(n=Promise))(<span class="fstat-no" title="function not covered" >fu</span>nction(p,e){function <span class="fstat-no" title="function not covered" >v(</span>t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >E(l.next(t))}</span>catch(t){<span class="cstat-no" title="statement not covered" >e(t)}</span>}</span>function <span class="fstat-no" title="function not covered" >T(</span>t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >E(l.throw(t))}</span>catch(t){<span class="cstat-no" title="statement not covered" >e(t)}</span>}</span>function <span class="fstat-no" title="function not covered" >E(</span>t){<span class="cstat-no" title="statement not covered" >t.done?p(t.value):new n(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >i(t.value)}</span>).then(v,T)}<span class="cstat-no" title="statement not covered" ></span>E((l=l.apply(t,i||[])).next())}</span>)}</span>,T=this&amp;&amp;this.__generator||<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n,l,p,e,v=<span class="cstat-no" title="statement not covered" >{label:0,sent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(1&amp;p[0])<span class="cstat-no" title="statement not covered" >throw p[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn p[1]}</span>,trys:[],ops:[]};<span class="cstat-no" title="statement not covered" ></span>return e={next:T(0),throw:T(1),return:T(2)},"function"==typeof Symbol&amp;&amp;(e[Symbol.iterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>),e;f</span>unction <span class="fstat-no" title="function not covered" >T(</span>e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(T){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >throw new TypeError("Generator is already executing.");<span class="cstat-no" title="statement not covered" >f</span></span>or(;v;)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(n=1,l&amp;&amp;(p=2&amp;e[0]?l.return:e[0]?l.throw||((p=l.return)&amp;&amp;p.call(l),0):l.next)&amp;&amp;!(p=p.call(l,e[1])).done)<span class="cstat-no" title="statement not covered" >return p;<span class="cstat-no" title="statement not covered" >s</span></span>witch(l=0,p&amp;&amp;(e=[2&amp;e[0],p.value]),e[0]){case 0:case 1:<span class="cstat-no" title="statement not covered" >p=e;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >return v.label++,{value:e[1],done:!1};c</span>ase 5:<span class="cstat-no" title="statement not covered" >v.label++,l=e[1],e=[0];<span class="cstat-no" title="statement not covered" >c</span>ontinue;c</span>ase 7:<span class="cstat-no" title="statement not covered" >e=v.ops.pop(),v.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue;d</span>efault:<span class="cstat-no" title="statement not covered" >if(!(p=(p=v.trys).length&gt;0&amp;&amp;p[p.length-1])&amp;&amp;(6===e[0]||2===e[0])){<span class="cstat-no" title="statement not covered" >v=0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(3===e[0]&amp;&amp;(!p||e[1]&gt;p[0]&amp;&amp;e[1]&lt;p[3])){<span class="cstat-no" title="statement not covered" >v.label=e[1];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(6===e[0]&amp;&amp;v.label&lt;p[1]){<span class="cstat-no" title="statement not covered" >v.label=p[1],p=e;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p&amp;&amp;v.label&lt;p[2]){<span class="cstat-no" title="statement not covered" >v.label=p[2],v.ops.push(e);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>p</span>[2]&amp;&amp;v.ops.pop(),v.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>e</span>=i.call(t,v)}</span>catch(t){<span class="cstat-no" title="statement not covered" >e=[6,t],l=0}</span>finally{<span class="cstat-no" title="statement not covered" >n=p=0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(5&amp;e[0])<span class="cstat-no" title="statement not covered" >throw e[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:e[0]?e[1]:void 0,done:!0}}</span>([e,T])}</span>}</span>};Object.defineProperty(i,"__esModule",{value:!0});var E=n(0),S=n(1),R=n(6),r=n(8),h=n(2),u=n(3),L=n(17),M=n(26),f=n(27),U=function(t){function i(){var i=this,n=new R.LoggerWeb,l=new M.StateCenter,p=new("undefined"!=typeof webkitAudioContext?<span class="branch-0 cbranch-no" title="branch not covered" >webkitAudioContext:</span>AudioContext),e=new r.ZegoStreamCenterWeb(n,l,p);return(i=t.call(this)||<span class="branch-1 cbranch-no" title="branch not covered" >this)</span>.ac=p,i.streamCenter=e,i.logger=n,i.stateCenter=l,i.audioMixing=new u.audioMixUtil(n,i.ac),i.init(),i.bindWindowListener(),i}return p(i,t),i.prototype.getSocket=function(t){return new WebSocket(t)},i.prototype.enableCamera=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.p.ec.0 call"),"boolean"!=typeof i?(this.logger.error("zc.p.ec.0 argument is not bool"),!1):this.streamCenter.enableCamera(t,i)}</span>,i.prototype.enableMicrophone=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.p.em.0 call"),"boolean"!=typeof i?(this.logger.error("zc.p.em.0 argument is not bool"),!1):this.streamCenter.enableMicrophone(t,i)}</span>,i.prototype.setLocalAudioOutput=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.p.slao call"),"string"!=typeof i?(console.error("audiooutput is not string"),!1):this.streamCenter.setStreamAudioOutput(t,i)}</span>,i.prototype.setPlayAudioOutput=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.p.spao call"),"string"!=typeof i?(console.error("audiooutput is not string"),!1):this.streamCenter.setPlayStreamAudioOutput(t,i)}</span>,i.prototype.setCustomSignalUrl=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zc.p.scs.0 call: "+t),!t||0==t.length)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.scs.0 param error"),!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>if(t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0!=t.indexOf("wss://")&amp;&amp;(i=!1)}</span>),!i)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.scs.0 url is not correct"),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.customUrl=t}</span>,i.prototype.setQualityMonitorCycle=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"number"==typeof t&amp;&amp;t&gt;=1e3&amp;&amp;this.streamCenter.setQualityMonitorCycle(t)}</span>,i.prototype.startPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zc.p.sps.0 call"),!t||""===t)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.0 param error"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!i)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.0 don't have remoteVideo"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.stateCenter.customUrl)<span class="cstat-no" title="statement not covered" >return this.streamCenter.setPlayStateStart(t,i,n,l)?this.streamCenter.startPlayingStream(t,this.stateCenter.customUrl):(this.logger.error("zc.p.sps.0 cannot start play"),!1);<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.0 not login"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=!1,v=0;v&lt;this.stateCenter.streamList.length;v++)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.streamList[v].stream_id===t){<span class="cstat-no" title="statement not covered" >e=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(0==e&amp;&amp;this.logger.info("zc.p.sps.0 cannot find stream"),this.stateCenter.pullLimited||(t=NaN+t),!this.streamCenter.setPlayStateStart(t,i,n,l))<span class="cstat-no" title="statement not covered" >return this.logger.info("zc.p.sps.0 cannot start play"),!1;v</span></span>ar T=<span class="cstat-no" title="statement not covered" >{stream_id:t,ptype:"pull",signals:this.streamCenter.getAllInUseUrl()};<span class="cstat-no" title="statement not covered" ></span>return this.socketCenter.registerRouter("webrtc_url",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.handleFetchWebRtcUrlRsp(t)}</span>),this.socketCenter.sendMessage("webrtc_url",T,void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >i==E.sdkErrorList.SEND_MSG_TIMEOUT?p.onPlayStateUpdate(E.ENUM_PLAY_STATE_UPDATE.error,t,S.playErrorList.DISPATCH_TIMEOUT):p.onPlayStateUpdate(E.ENUM_PLAY_STATE_UPDATE.error,t,S.playErrorList.DISPATCH_ERROR),p.streamCenter.stopPlayingStream(t)}</span>),!0}</span>,i.prototype.stopPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zc.p.sps.1.0 call"),!t||""===t)<span class="cstat-no" title="statement not covered" >return this.logger.info("zc.p.sps.1.0 param error"),!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.streamCenter.getTotalStreamId(t),</span>n=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[i];<span class="cstat-no" title="statement not covered" ></span>if(!n||0==n.serverUrls.length||!n.player.signal)<span class="cstat-no" title="statement not covered" >return n&amp;&amp;this.logger.error("zc.p.sps.1.0 stream can not be destroyed"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var l in this.streamCenter.stopPlayingStream(t),this.stateCenter.streamUrlMap)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.streamUrlMap[l]===t){<span class="cstat-no" title="statement not covered" >delete this.stateCenter.streamUrlMap[l];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this.logger.debug("zc.p.sps.1.0 call success"),!0}</span>,i.prototype.startPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zc.p.sp.0 call"),!t)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sp.0 no localVideo"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(i.audioBitRate){<span class="cstat-no" title="statement not covered" >if("number"!=typeof i.audioBitRate)<span class="cstat-no" title="statement not covered" >return void this.logger.error("zc.p.sp.0 audioBitRate must be number");<span class="cstat-no" title="statement not covered" >i</span></span>f(i.audioBitRate&lt;48e3)<span class="cstat-no" title="statement not covered" >return void this.logger.error("zc.p.sp.0 audioBitRate cannot less 48000");<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.audioBitRate=i.audioBitRate}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!!h.ClientUtil.checkPreviewParam(i,this.logger)&amp;&amp;this.streamCenter.startPreview(t,i,n,l)}</span>,i.prototype.stopPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.p.sp.1 call"),t?this.streamCenter.stopPreview(t):(this.logger.info("zc.p.sp.1 param error"),!1)}</span>,i.prototype.startPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zc.p.sps.1 call streamid: "+t),!t)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1 param error"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.streamCenter.checkPreview(i))<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1 need preview before publish"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(l||(l={}),l.audioBitRate=this.stateCenter.audioBitRate,this.stateCenter.customUrl&amp;&amp;0!=this.stateCenter.customUrl.length)<span class="cstat-no" title="statement not covered" >return this.stateCenter.publishStreamList[t]={state:E.ENUM_PUBLISH_STREAM_STATE.tryPublish,extra_info:n},this.streamCenter.setPublishStateStart(t,i,l)?this.streamCenter.startPublishingStream(t,this.stateCenter.customUrl):(this.logger.info("zc.p.sps.1 cannot start publish"),!1);<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1 not login"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.stateCenter.publishStreamList[t]={state:E.ENUM_PUBLISH_STREAM_STATE.tryPublish,extra_info:n},!this.streamCenter.setPublishStateStart(t,i,l))<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.p.sps.1 cannot start publish"),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.info("zc.p.sps.1 start publish");v</span>ar e=<span class="cstat-no" title="statement not covered" >{stream_id:t,ptype:"push",signals:this.streamCenter.getAllInUseUrl(),header_kvs:[{key:"grpc-metadata-push",value:l&amp;&amp;l.cdnUrl||""}]};<span class="cstat-no" title="statement not covered" ></span>return this.socketCenter.registerRouter("webrtc_url",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.handleFetchWebRtcUrlRsp(t)}</span>),this.socketCenter.sendMessage("webrtc_url",e,void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >i==E.sdkErrorList.SEND_MSG_TIMEOUT?p.onPublishStateUpdate(E.ENUM_PUBLISH_STATE_UPDATE.error,t,S.publishErrorList.DISPATCH_TIMEOUT):p.onPublishStateUpdate(E.ENUM_PUBLISH_STATE_UPDATE.error,t,S.publishErrorList.DISPATCH_ERROR),p.streamCenter.stopPublishingStream(t)}</span>),!0}</span>,i.prototype.stopPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zc.p.sps.1.1 call streamid: "+t),!t)<span class="cstat-no" title="statement not covered" >return this.logger.info("zc.p.sps.1.1 param error"),!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.streamCenter.getTotalStreamId(t),</span>n=<span class="cstat-no" title="statement not covered" >this.streamCenter.publisherList[i];<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;0!=n.serverUrls.length&amp;&amp;n.publisher.signal?(this.streamCenter.stopPublishingStream(t),this.stateCenter.publishStreamList[t]&amp;&amp;(this.stateCenter.publishStreamList[t].state&gt;=E.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;this.streamHandler.updateStreamInfo(t,E.ENUM_STREAM_SUB_CMD.liveEnd),delete this.stateCenter.publishStreamList[t]),!0):(n&amp;&amp;this.logger.error("zc.p.sps.1.1 stream can not be destroyed when dispatching"),!1)}</span>,i.prototype.preloadEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;"number"==typeof t&amp;&amp;i&amp;&amp;"string"==typeof i?this.stateCenter.audioEffectBuffer[t]?this.logger.error("zc.pe.0 audio buffer already exists"):this.audioMixing.preloadEffect(i,<span class="fstat-no" title="function not covered" >fu</span>nction(i,p){<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >return l.logger.error("zc.pe.0 effect preload fail "+i),void(n&amp;&amp;n(i));<span class="cstat-no" title="statement not covered" >p</span></span>&amp;&amp;(l.stateCenter.audioEffectBuffer[t]=p,n&amp;&amp;n())}</span>):this.logger.error("zc.pe.0 params error")}</span>,i.prototype.playEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(t.streamId&amp;&amp;"string"==typeof t.streamId&amp;&amp;t.effectId&amp;&amp;"number"==typeof t.effectId)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.audioEffectBuffer[t.effectId]){var l=<span class="cstat-no" title="statement not covered" >this.stateCenter.audioEffectBuffer[t.effectId],</span>p=<span class="cstat-no" title="statement not covered" >this.getPublisher(t.streamId);<span class="cstat-no" title="statement not covered" ></span>p?l?p.playEffect(t,l,i,n):this.logger.error("zc.pe.1 no audio buffer found"):this.logger.error("zc.pe.1 publisher doesn't exist")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zc,pe.1 audio buffer dosesn't exists");e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zc.pe.1 params error")}</span></span>,i.prototype.pauseEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"string"==typeof t){var i=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>i?i.pauseEffect():this.logger.error("zc.pe.2 publisher doesn't exist")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zc.pe.2 streamid format error")}</span></span>,i.prototype.resumeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"string"==typeof t){var i=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>i?i.resumeEffect():this.logger.error("zc.re.0 publisher doesn't exist")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zc.re.0 streamid format error")}</span></span>,i.prototype.unloadEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"number"==typeof t?(delete this.stateCenter.audioEffectBuffer[t],!0):(this.logger.error("zc.ue.0 params error"),!1)}</span>,i.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zc.sma.0 call"),t&amp;&amp;"string"==typeof t?i?Array.isArray(i)&amp;&amp;0!==i.length?this.streamCenter.startMixingAudio(t,i):i instanceof HTMLMediaElement?this.streamCenter.startMixingAudio(t,[i]):(this.logger.error("zc.sma.0 audio param type error"),!1):(this.logger.error("zc.sma.0 no audio"),!1):(this.logger.error("zc.sma.0 stream id type error"),!1)}</span>,i.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"string"==typeof t?Array.isArray(i)&amp;&amp;0!==i.length||void 0===i?this.streamCenter.stopMixingAudio(t,i):(this.logger.error("zc.sma.0 audio param type error"),!1):(this.logger.error("zc.sma.1 param streamID format error"),!1)}</span>,i.prototype.mixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>p?n instanceof ArrayBuffer?p.mixingBuffer(n,l):this.logger.error("zc.mb.0 array buffer not found"):this.logger.error("zc.mb.0 publisher doesn't exist")}</span>,i.prototype.stopMixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >if(!t||"string"!=typeof t)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.sma.1 param streamid format error"),!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>return n?n.stopMixingBuffer():(this.logger.error("zc.sma.1 publisher doesn't exist"),!1)}</span>,i.prototype.setMixingAudioVolume=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zc.sma.2 call"),!t||"string"!=typeof t||"number"!=typeof i||i&lt;0||i&gt;100)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.sma.2 param error"),!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>return n?n.audioMixing.setMixingAudioVolume(i/100):(this.logger.error("zc.sma.2 publisher doesn't exist"),!1)}</span>,i.prototype.getPublisher=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >null,</span>n=<span class="cstat-no" title="statement not covered" >this.streamCenter.getTotalStreamId(t);<span class="cstat-no" title="statement not covered" ></span>return this.streamCenter.publisherList[n]&amp;&amp;this.streamCenter.publisherList[n].publisher&amp;&amp;(i=this.streamCenter.publisherList[n].publisher),i}</span>,i.prototype.startScreenShotChrome=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!i.screenShotReady)<span class="cstat-no" title="statement not covered" >return this.logger.error('zc.b.ss Please install the extension:1. Go to chrome://extensions  2. Check: "Enable Developer mode   3. Click: "Load the unpacked extension... 4. Choose "extension" folder from the repository 5. Reload this page'),!1;<span class="cstat-no" title="statement not covered" >w</span></span>indow.postMessage({type:"SS_UI_REQUEST",text:"start"},"*"),h.ClientUtil.registerCallback("screenShare",{success:t},this.stateCenter.callbackList)}</span>,i.prototype.startScreenSharing=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>"getDisplayMedia"in navigator.mediaDevices?navigator.mediaDevices.getDisplayMedia({audio:i,video:{width:t.width||window.screen.width,height:t.height||window.screen.height,frameRate:t.frameRate||15,displaySurface:t.displaySurface||"minitor"}}).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.stateCenter.screenShotStreamList.push({stream:t,type:0}),t.getVideoTracks()[0].onended=<span class="fstat-no" title="function not covered" >fu</span>nction(){var i=<span class="cstat-no" title="statement not covered" >l.stateCenter.screenShotStreamList.findIndex(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.stream===t}</span>);<span class="cstat-no" title="statement not covered" ></span>i&gt;-1&amp;&amp;l.stateCenter.screenShotStreamList.splice(i,1),l.onScreenSharingEnded(t)}</span>,n(!0,t)}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.logger.error("zc.b.sss "+t),n(!1,null,t)}</span>):this.logger.error("zc.b.sss getDisplayMedia is not supported ")}</span>,i.prototype.startScreenShotFirFox=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >{video:{width:t.width||window.screen.width,height:t.height||window.screen.height,frameRate:t.frameRate||15},audio:n};<span class="cstat-no" title="statement not covered" ></span>e.video.mediaSource=i,navigator.mediaDevices.getUserMedia(e).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.stateCenter.screenShotStreamList.push({stream:t,type:0}),t.getVideoTracks()[0].onended=<span class="fstat-no" title="function not covered" >fu</span>nction(){var i=<span class="cstat-no" title="statement not covered" >p.stateCenter.screenShotStreamList.findIndex(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.stream===t}</span>);<span class="cstat-no" title="statement not covered" ></span>i&gt;-1&amp;&amp;p.stateCenter.screenShotStreamList.splice(i,1),p.onScreenSharingEnded(t)}</span>,l(!0,t)}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.logger.error("zc.b.ssf "+t),l(!1,null)}</span>)}</span>,i.prototype.stopScreenShot=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>void 0===t?n=this.stateCenter.screenShotStreamList.slice():n.push({stream:t,type:-1}),n.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >i.stateCenter.screenShotStreamList.findIndex(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.stream===t.stream}</span>);<span class="cstat-no" title="statement not covered" ></span>n&gt;-1&amp;&amp;(t.stream.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.stop()}</span>),1===i.stateCenter.screenShotStreamList[n].type&amp;&amp;window.postMessage({type:"SS_UI_CANCEL",text:"start"},"*"),i.stateCenter.screenShotStreamList.splice(n,1))}</span>)}</span>,i.prototype.switchDevice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>"audio"!==t&amp;&amp;"video"!==t||"string"!=typeof n?this.logger.error("zg.sd.0 param error"):this.enumDevices(<span class="fstat-no" title="function not covered" >fu</span>nction(v){var T=<span class="cstat-no" title="statement not covered" >v.cameras,</span>E=<span class="cstat-no" title="statement not covered" >v.microphones;<span class="cstat-no" title="statement not covered" ></span>T.find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.deviceId==n}</span>)||E.find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.deviceId==n}</span>)?e.streamCenter.switchDevice(t,i,n,l,p):e.logger.error("zg.sd.0 can not switch device")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return p&amp;&amp;p(t)}</span>)}</span>,i.prototype.WebrtcOnPublishStateUpdateHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.stateCenter.publishStreamList[i].state==E.ENUM_PUBLISH_STREAM_STATE.publishing&amp;&amp;this.onPublishStateUpdate(t,i,n)}</span>,i.prototype.setCDNInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.urls_flv=i.urls_flv,t.urls_hls=i.urls_m3u8,t.urls_https_flv=i.urls_https_flv,t.urls_https_hls=i.urls_https_m3u8,t.urls_rtmp=i.urls_rtmp}</span>,i.prototype.onScreenSharingEnded=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},i.prototype.loginBodyData=function(){return{id_name:this.stateCenter.idName,nick_name:this.stateCenter.nickName,role:this.stateCenter.role,token:this.stateCenter.token,version:E.PROTO_VERSION,room_name:this.stateCenter.roomid,user_state_flag:this.stateCenter.userStateUpdate?<span class="branch-0 cbranch-no" title="branch not covered" >1:</span>0,room_create_flag:this.stateCenter.roomCreateFlag,client_type:E.E_CLIENT_TYPE.ClientType_Webrtc,third_token:this.stateCenter.third_token}},i.prototype.screenStreamFrom=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >this,</span>p=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>p.audio={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:t}},p.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:t,maxWidth:window.screen.width,maxHeight:window.screen.height}},!i&amp;&amp;(p.audio=!1),navigator.mediaDevices.getUserMedia(p).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.stateCenter.screenShotStreamList.push({stream:t,type:1}),t.getVideoTracks()[0].onended=<span class="fstat-no" title="function not covered" >fu</span>nction(){var i=<span class="cstat-no" title="statement not covered" >l.stateCenter.screenShotStreamList.findIndex(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.stream===t}</span>);<span class="cstat-no" title="statement not covered" ></span>i&gt;-1&amp;&amp;l.stateCenter.screenShotStreamList.splice(i,1),l.onScreenSharingEnded(t)}</span>,n(!0,t)}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.logger.error("zc.b.ssf "+t),n(!1,null,t)}</span>)}</span>,i.prototype.filterStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >{},</span>l=<span class="cstat-no" title="statement not covered" >{},</span>p=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var v in this.stateCenter.streamList.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >i.stream_id==t&amp;&amp;(e=n)}</span>),this.stateCenter.streamList[e])<span class="cstat-no" title="statement not covered" >"urls_flv"!=v&amp;&amp;"urls_https_flv"!=v||(i[v]=this.stateCenter.streamList[e][v]),"urls_m3u8"!=v&amp;&amp;"urls_https_m3u8"!=v||(n[v]=this.stateCenter.streamList[e][v]),"urls_rtmp"==v&amp;&amp;(l[v]=this.stateCenter.streamList[e][v]);v</span></span>ar T=<span class="cstat-no" title="statement not covered" >window.location.protocol,</span>E=<span class="cstat-no" title="statement not covered" >window.navigator.userAgent;<span class="cstat-no" title="statement not covered" ></span>if(/Safari/.test(E)&amp;&amp;!/Chrome/.test(E))<span class="cstat-no" title="statement not covered" >for(var v in n)<span class="cstat-no" title="statement not covered" >n[v]&amp;&amp;n[v].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >-1!==t.indexOf(T)&amp;&amp;p.push(t)}</span>);e</span></span>lse <span class="cstat-no" title="statement not covered" >if("http:"==T)<span class="cstat-no" title="statement not covered" >for(var v in i)<span class="cstat-no" title="statement not covered" >i[v]&amp;&amp;i[v].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >-1===t.indexOf("http")&amp;&amp;-1===t.indexOf("https")||p.push(t)}</span>);e</span></span>lse <span class="cstat-no" title="statement not covered" >if("https:"==T)<span class="cstat-no" title="statement not covered" >for(var v in i)<span class="cstat-no" title="statement not covered" >i[v]&amp;&amp;i[v].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >-1!==t.indexOf(T)&amp;&amp;p.push(t)}</span>);e</span></span>lse <span class="cstat-no" title="statement not covered" >if("rtmp:"==T)<span class="cstat-no" title="statement not covered" >for(var v in l)<span class="cstat-no" title="statement not covered" >l[v]&amp;&amp;l[v].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >-1!==t.indexOf(T)&amp;&amp;p.push(t)}</span>);<span class="cstat-no" title="statement not covered" >r</span></span></span></span></span></span>eturn p.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return n.indexOf(t)==i}</span>)}</span>,i.prototype.voiceChange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"number"==typeof t?i&amp;&amp;"string"==typeof i?this.getPublisher(i).voiceChange(t):(this.logger.error("zc.vc.0 stream id error"),!1):(this.logger.error("zc.vc.0 mult error"),!1)}</span>,i.prototype.voiceBack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.getPublisher(t).voiceBack()}</span>,i.prototype.setPublishStreamConstraints=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.logger.info("zc.spsc.0 call"),"string"==typeof t&amp;&amp;""!=t?this.streamCenter.setPublishStreamConstraints(t,i,n,l):this.logger.error("zc.spsc.0 stream ID must be string and not empty")}</span>,i.prototype.setSoundLevelDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.logger.info("zc.ssd.0 call"),"boolean"==typeof t?i&amp;&amp;("number"!=typeof i||i&lt;100||i&gt;3e3)?this.logger.error("zc.ssd.0 soundLevel interval must be number which is between 100 and 3000"):this.streamCenter.setSoundLevelDelegate(t,i):this.logger.error("zc.ssd.0 param 1 must be boolean")}</span>,i.supportDetection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >navigator&amp;&amp;navigator.mediaDevices&amp;&amp;(this.screenShotReady||"getDisplayMedia"in navigator.mediaDevices)?h.ClientUtil.supportDetection(!0,t,i):h.ClientUtil.supportDetection(!1,t,i)}</span>,i.prototype.enumDevices=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.enumDevices(t,n)}</span>,i.enumDevices=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >void 0!==navigator.mediaDevices&amp;&amp;void 0!==navigator.mediaDevices.enumerateDevices?navigator.mediaDevices.enumerateDevices().then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >for(var n=[],l=[],p=[],e=0;e&lt;i.length;e++){var v=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>"audioinput"===v.kind&amp;&amp;n.push({label:v.label,deviceId:v.deviceId}),"audiooutput"===v.kind&amp;&amp;l.push({label:v.label,deviceId:v.deviceId}),"videoinput"===v.kind&amp;&amp;p.push({label:v.label,deviceId:v.deviceId})}<span class="cstat-no" title="statement not covered" ></span>t</span>&amp;&amp;t({microphones:n,speakers:l,cameras:p})}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i(t)}</span>):i&amp;&amp;i("browser don't support enumerate devices")}</span>,i.getAudioInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(!t.srcObject)<span class="cstat-no" title="statement not covered" >return console.error("srcObject is empty!"),!1;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >e({},n);<span class="cstat-no" title="statement not covered" ></span>return new f.MediaUtil(l).connectToSource(t.srcObject,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i(t)}</span>)}</span>,i.handleDataAvailable=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.data&amp;&amp;t.data.size&gt;0&amp;&amp;i.recordedBlobs.push(t.data)}</span>,i.startRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >return v(this,void 0,void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(){var p,e;<span class="cstat-no" title="statement not covered" >return T(this,<span class="fstat-no" title="function not covered" >fu</span>nction(v){<span class="cstat-no" title="statement not covered" >switch(v.label){case 0:<span class="cstat-no" title="statement not covered" >return i.recordedBlobs=[],e={mimeType:"video/webm;codecs=vp9"},MediaRecorder.isTypeSupported(e.mimeType)||(e={mimeType:"video/webm;codecs=vp8"},MediaRecorder.isTypeSupported(e.mimeType)||(e={mimeType:"video/webm"},MediaRecorder.isTypeSupported(e.mimeType)||(e={mimeType:""}))),n&amp;&amp;n.audio?(e={mimeType:"audio/webm"},MediaRecorder.isTypeSupported(e.mimeType)||(e={mimeType:""}),[4,navigator.mediaDevices.getUserMedia({audio:{deviceId:n.audioInput?n.audioInput:""}})]):[3,2];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return p=v.sent(),i.recordType="audio",[3,3];c</span>ase 2:<span class="cstat-no" title="statement not covered" >p=t.captureStream(),v.label=3;c</span>ase 3:<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i.mediaRecorder=new MediaRecorder(p,e)}</span>catch(t){<span class="cstat-no" title="statement not covered" >return console.error("Exception while creating MediaRecorder:",t),l&amp;&amp;l(t),[2]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.mediaRecorder.onstop=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >console.log("Recorder stopped: ",t),n&amp;&amp;n.audio&amp;&amp;p.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stop()}</span>)}</span>,i.mediaRecorder.ondataavailable=i.handleDataAvailable,i.mediaRecorder.start(10),l&amp;&amp;l(),[2]}</span>}</span>)}</span>)}</span>,i.stopRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.mediaRecorder?i.mediaRecorder.stop():console.warn("please invoke startRecord first")}</span>,i.resumeRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.mediaRecorder?i.mediaRecorder.resume():console.warn("please invoke startRecord first")}</span>,i.pauseRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.mediaRecorder?i.mediaRecorder.pause():console.warn("please invoke startRecord first")}</span>,i.saveRecord=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(i.mediaRecorder&amp;&amp;i.recordedBlobs){var n=<span class="cstat-no" title="statement not covered" >new Blob(i.recordedBlobs,{type:"video"===i.recordType?"video/webm":"audio/webm"}),</span>l=<span class="cstat-no" title="statement not covered" >window.URL.createObjectURL(n);<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof t&amp;&amp;""!==t){var p=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>p.style.display="none",p.href=l,p.download=t+".webm",document.body.appendChild(p),p.click(),setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >document.body.removeChild(p),window.URL.revokeObjectURL(l)}</span>,100)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l}<span class="cstat-no" title="statement not covered" ></span>c</span>onsole.warn("please invoke startRecord first")}</span>,i.resumeRecordAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.mediaRecorder?i.mediaRecorder.resume():console.warn("please invoke startRecordAudio first")}</span>,i.pauseRecordAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.mediaRecorder?i.mediaRecorder.pause():console.warn("please invoke startRecordAudio first")}</span>,i.getRecordAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(i.mediaRecorder&amp;&amp;i.recordedBlobs){var t=<span class="cstat-no" title="statement not covered" >new Blob(i.recordedBlobs);<span class="cstat-no" title="statement not covered" ></span>return window.URL.createObjectURL(t)}<span class="cstat-no" title="statement not covered" ></span>c</span>onsole.warn("please invoke startRecordAudio first")}</span>,i.takeSnapShot=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;0!==t.videoHeight){var n=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>n.width=t.videoWidth,n.height=t.videoHeight,n.getContext("2d").drawImage(t,0,0,n.width,n.height),i.src=n.toDataURL("image/jpeg")}</span>else <span class="cstat-no" title="statement not covered" >console.error("video can not empty")}</span></span>,i.saveSnapShot=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;0!==t.videoHeight){var n=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>n.width=t.videoWidth,n.height=t.videoHeight,n.getContext("2d").drawImage(t,0,0,n.width,n.height),n.toBlob(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >window.URL.createObjectURL(t),</span>l=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>l.style.display="none",l.href=n,l.download=i+".jpeg",document.body.appendChild(l),l.click(),setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >document.body.removeChild(l),window.URL.revokeObjectURL(n)}</span>,100)}</span>)}</span>else <span class="cstat-no" title="statement not covered" >console.error("video can not empty")}</span></span>,i.prototype.bindWindowListener=function(){var t=this,i=navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPhone/i)?<span class="branch-0 cbranch-no" title="branch not covered" >"pagehide":</span>"beforeunload";window.addEventListener(i,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >for(var n in window.event.cancelBubble=!0,t.streamCenter.publisherList)<span class="cstat-no" title="statement not covered" >t.stopPublishingStream(n);<span class="cstat-no" title="statement not covered" >f</span></span>or(var n in t.streamCenter.playerList)<span class="cstat-no" title="statement not covered" >t.stopPublishingStream(n);<span class="cstat-no" title="statement not covered" >c</span></span>onsole.log(t.streamCenter.playerList),console.log(t.streamCenter.publisherList),t.logout()}</span>),window.addEventListener("message",<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >i.data,</span>l=<span class="cstat-no" title="statement not covered" >n.type,</span>p=<span class="cstat-no" title="statement not covered" >n.streamId,</span>e=<span class="cstat-no" title="statement not covered" >n.canRequestAudioTrack;<span class="cstat-no" title="statement not covered" ></span>i.origin;<span class="cstat-no" title="statement not covered" >"</span>SS_DIALOG_SUCCESS"===l&amp;&amp;t.screenStreamFrom(p,e,h.ClientUtil.actionSuccessCallback("screenShare",t.stateCenter.callbackList)),"SS_DIALOG_CANCEL"===l&amp;&amp;(t.logger.error("zc.b.ss "+l),h.ClientUtil.actionSuccessCallback("screenShare",t.stateCenter.callbackList)(!1,null,l))}</span>)},i.screenShotReady=!1,i.recordType="video",i}(L.BaseCenter);i.ZegoClient=U,window.addEventListener("message",function(t){var i=t.data,n=i.type,l=(i.streamId,t.origin);l!==window.location.origin&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >console.warn("ScreenStream: you should discard foreign event from origin:",l),</span>"SS_PING"===n&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >U.screenShotReady=!0)</span>})},function(t,i,n){"use strict";var l,p=this&amp;&amp;this.__extends||(l=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.__proto__=i}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >for(var n in i)<span class="cstat-no" title="statement not covered" >i.hasOwnProperty(n)&amp;&amp;(t[n]=i[n])}</span></span>,</span>function(t,i){function n(){this.constructor=t}l(t,i),t.prototype=null===i?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(i):</span>(n.prototype=i.prototype,new n)});Object.defineProperty(i,"__esModule",{value:!0});var e=n(7),v=function(t){function i(){return null!==t&amp;&amp;t.apply(this,arguments)||this}return p(i,t),i.prototype.openWebSocketLogServer=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.url!=t){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.url=t,!t)<span class="cstat-no" title="statement not covered" >return;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(null!=this.websocket&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >2!=this.websocket.readyState&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >3!=this.websocket.readyState)<span class="cstat-no" title="statement not covered" ></span>return;t</span>his.stopWebSocketServer(),this.websocket=new WebSocket(t),this.websocket.onopen=function(t){},this.websocket.onclose=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >console.error("onclose   websocket error:",t)}</span>,this.websocket.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >console.error("open log websocket error:"+t)}</span>}},i.prototype.SendHttpsLog=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(0!=this.logCacheSend.length){var i=<span class="cstat-no" title="statement not covered" >this.logCacheSend.join("\n"),</span>n=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>n.onreadystatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(4==n.readyState)<span class="cstat-no" title="statement not covered" >if(200==n.status){<span class="cstat-no" title="statement not covered" >if(0==n.responseText.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>ry{var i=<span class="cstat-no" title="statement not covered" >JSON.parse(n.responseText).interval;<span class="cstat-no" title="statement not covered" ></span>"number"==typeof i&amp;&amp;t.logUploadInterval!==i&amp;&amp;(t.timeInterval=i,t.openHttpsLogServer(t.url))}</span>catch(t){<span class="cstat-no" title="statement not covered" >console.log("send result failed "+t)}</span>}</span>else <span class="cstat-no" title="statement not covered" >console.log("send failed "+n.status)}</span></span></span>,n.open("POST",this.url,!0),n.send(i),this.logCacheSend=[]}</span>}</span>,i.prototype.logReportParamList=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >new Date,</span>l=<span class="cstat-no" title="statement not covered" >n.getFullYear()+"/";<span class="cstat-no" title="statement not covered" ></span>return l+=(e.D[n.getMonth()+1]||n.getMonth()+1)+"/",l+=(e.D[n.getDate()]||n.getDate())+" ",l+=(e.D[n.getHours()]||n.getHours())+":",l+=(e.D[n.getMinutes()]||n.getMinutes())+":",l+=e.D[n.getSeconds()]||n.getSeconds(),l+="."+n.getTime()%1e3,i.time=l,i.level=t,i.console="rtc",i.appid=this.appid,i.roomid=this.roomid,i.userid=this.userid,i.id_name=this.userid,i.userName=this.userName,i.sessionid=this.sessionid,i.version=this.version,[JSON.stringify(i)]}</span>,i}(e.Logger);i.LoggerWeb=v},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0);i.D=["00","01","02","03","04","05","06","07","08","09"];var p=function(){function t(){this.logLevel=l.ENUM_LOG_LEVEL.info,this.logUploadTimer=null,this.logUploadInterval=1e4,this.logCache=[],this.logCacheSend=[],this.logCacheMax=100}return t.prototype.setLogLevel=function(t){this.logLevel&lt;l.ENUM_LOG_LEVEL.debug||this.logLevel&gt;l.ENUM_LOG_LEVEL.report?<span class="branch-0 cbranch-no" title="branch not covered" >this.logLevel=l.ENUM_LOG_LEVEL.disable:</span>this.logLevel=t},t.prototype.setRemoteLogLevel=function(t){this.logRemoteLevel&lt;l.ENUM_LOG_LEVEL.debug||this.logRemoteLevel&gt;l.ENUM_LOG_LEVEL.report?<span class="branch-0 cbranch-no" title="branch not covered" >this.logRemoteLevel=l.ENUM_LOG_LEVEL.disable:</span>this.logRemoteLevel=t},t.prototype.setSessionInfo=function(t,i,n,l,p,e){this.appid=t,this.roomid=i,this.sessionid=n,this.userid=l,this.userName=p,this.version=e},t.prototype.openLogServer=function(t){try{t.startsWith("wss:")?(this.logType=l.ENUM_REMOTE_TYPE.websocket,this.openWebSocketLogServer(t)):<span class="branch-1 cbranch-no" title="branch not covered" >t.startsWith("https:")?(this.logType=l.ENUM_REMOTE_TYPE.https,this.openHttpsLogServer(t)):this.logType=l.ENUM_REMOTE_TYPE.disable}</span>catch(t){<span class="cstat-no" title="statement not covered" >this.error(JSON.stringify(t))}</span>},t.prototype.stopLogServer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logType==l.ENUM_REMOTE_TYPE.websocket?this.stopWebSocketServer():this.logType==l.ENUM_REMOTE_TYPE.https&amp;&amp;(this.SendHttpsLog(),this.stopHttpsServer()),this.logType=l.ENUM_REMOTE_TYPE.disable}</span>,t.prototype.stopWebSocketServer=function(){this.websocket&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null)</span>},t.prototype.openHttpsLogServer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.url=t,t&amp;&amp;(this.stopHttpsServer(),this.logUploadTimer||(this.logUploadTimer=setInterval(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.SendHttpsLog()}</span>,this.logUploadInterval)))}</span>,t.prototype.stopHttpsServer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logUploadTimer&amp;&amp;(clearInterval(this.logUploadTimer),this.logUploadTimer=null)}</span>,t.prototype.report=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this.logReportParamList(l.ENUM_LOG_LEVEL.report,t);<span class="cstat-no" title="statement not covered" ></span>this.logLevel!==l.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=l.ENUM_LOG_LEVEL.report&amp;&amp;console.debug.apply(console,i),this.RemoteLog(l.ENUM_LOG_LEVEL.report,i,!0)}</span>,t.prototype.debug=function(){for(var t=[],i=0;i&lt;arguments.length;i++)t[i]=arguments[i];var n=this.logParamList(l.ENUM_LOG_LEVEL.debug,t.join(""));this.logLevel!==l.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=l.ENUM_LOG_LEVEL.debug&amp;&amp;console.debug.apply(console,n),this.log(l.ENUM_LOG_LEVEL.debug,n)},t.prototype.info=function(){for(var t=[],i=0;i&lt;arguments.length;i++)t[i]=arguments[i];var n=this.logParamList(l.ENUM_LOG_LEVEL.info,t.join(""));this.logLevel!==l.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=l.ENUM_LOG_LEVEL.info&amp;&amp;console.info.apply(console,n),this.log(l.ENUM_LOG_LEVEL.info,n)},t.prototype.warn=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=[],i=0;i&lt;arguments.length;i++)<span class="cstat-no" title="statement not covered" >t[i]=arguments[i];v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.logParamList(l.ENUM_LOG_LEVEL.warn,t.join(""));<span class="cstat-no" title="statement not covered" ></span>this.logLevel!==l.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=l.ENUM_LOG_LEVEL.warn&amp;&amp;console.warn.apply(console,n),this.log(l.ENUM_LOG_LEVEL.warn,n)}</span>,t.prototype.error=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=[],i=0;i&lt;arguments.length;i++)<span class="cstat-no" title="statement not covered" >t[i]=arguments[i];v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.logParamList(l.ENUM_LOG_LEVEL.error,t.join(""));<span class="cstat-no" title="statement not covered" ></span>this.logLevel!==l.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=l.ENUM_LOG_LEVEL.error&amp;&amp;console.error.apply(console,n),this.log(l.ENUM_LOG_LEVEL.error,n)}</span>,t.prototype.log=function(t,i){this.logRemoteLevel!==l.ENUM_LOG_LEVEL.disable&amp;&amp;this.logRemoteLevel&lt;=t&amp;&amp;this.RemoteLog(t,i)},t.prototype.RemoteLog=function(t,i,n){<span class="missing-if-branch" title="else path not taken" >E</span>if(void 0===n&amp;&amp;(n=!1),""!=this.url)if(this.logType==l.ENUM_REMOTE_TYPE.websocket)this.RemoteWebSocketLog(t,i);else <span class="missing-if-branch" title="if path not taken" >I</span>if(this.logType==l.ENUM_REMOTE_TYPE.https)<span class="cstat-no" title="statement not covered" >this.RemoteHttpsLog(t,i,n);e</span>lse <span class="missing-if-branch" title="else path not taken" >E</span>if(this.logLevel!==l.ENUM_LOG_LEVEL.disable&amp;&amp;this.logLevel&lt;=t)for(this.logCacheSend.push(i);this.logCacheSend.length&gt;this.logCacheMax;)<span class="cstat-no" title="statement not covered" >this.logCacheSend.shift()}</span>,t.prototype.RemoteWebSocketLog=function(t,i){<span class="missing-if-branch" title="if path not taken" >I</span>if("string"==typeof i&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >i.length&gt;4e3)<span class="cstat-no" title="statement not covered" ></span>console.info("log over maximum, ignore");e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if(null==this.websocket||2==this.websocket.readyState||3==this.websocket.readyState){var n=<span class="cstat-no" title="statement not covered" >this.url;<span class="cstat-no" title="statement not covered" ></span>this.url="",this.openLogServer(n),this.logCacheSend.length&lt;this.logCacheMax&amp;&amp;this.logCacheSend.push(i)}</span>else if(0==this.websocket.readyState)this.logCacheSend.length&lt;this.logCacheMax&amp;&amp;this.logCacheSend.push(i);else <span class="missing-if-branch" title="else path not taken" >E</span>if(1==this.websocket.readyState)if(this.logCacheSend.length&gt;0){for(var l="",p=0;p&lt;this.logCacheSend.length;p++)(l+this.logCacheSend[p]).length&gt;4e3&amp;&amp;(this.websocket.send(l),l=""),l=l+this.logCacheSend[p]+"\n";i=l+i,this.logCacheSend=[],this.websocket.send(i)}else this.websocket.send(i);else <span class="cstat-no" title="statement not covered" >console.warn("wrong socket state:"+this.websocket.readyState),this.logCacheSend.length&lt;this.logCacheMax&amp;&amp;this.logCacheSend.push(i)}</span>,t.prototype.RemoteHttpsLog=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logCacheSend.push(i),(this.logCacheSend.length&gt;=this.logCacheMax||!0===n)&amp;&amp;this.SendHttpsLog()}</span>,t.prototype.logParamList=function(t,n){var l=new Date,p=l.getFullYear()+"/";p+=(i.D[l.getMonth()+1]||<span class="branch-1 cbranch-no" title="branch not covered" >l.getMonth()+1)</span>+"/",p+=(i.D[l.getDate()]||l.getDate())+" ",p+=(i.D[l.getHours()]||l.getHours())+":",p+=(i.D[l.getMinutes()]||<span class="branch-1 cbranch-no" title="branch not covered" >l.getMinutes())</span>+":",p+=i.D[l.getSeconds()]||l.getSeconds(),p+="."+l.getTime()%1e3;var e=n.substr(0,n.indexOf(" "));0==e.length&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e=n)</span>;var v=n.substr(n.indexOf(" ")+1,4500);0==v.length&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >v="")</span>;var T={time:p,level:t,action:e,content:v,appid:this.appid,roomid:this.roomid,userid:this.userid,userName:this.userName,sessionid:this.sessionid};return[JSON.stringify(T)]},t}();i.Logger=p},function(t,i,n){"use strict";var l,p=this&amp;&amp;this.__extends||(l=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.__proto__=i}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >for(var n in i)<span class="cstat-no" title="statement not covered" >i.hasOwnProperty(n)&amp;&amp;(t[n]=i[n])}</span></span>,</span>function(t,i){function n(){this.constructor=t}l(t,i),t.prototype=null===i?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(i):</span>(n.prototype=i.prototype,new n)});Object.defineProperty(i,"__esModule",{value:!0});var e=n(9),v=n(10),T=n(11),E=n(1),S=n(0),R=n(14),r=n(15),h=function(t){function i(i,n,l){var p=t.call(this,i,n)||this;return p.testEnvironment=!1,p.heartbeatTimer=null,p.heartbeatInterval=1e4,p.chargeInfos={itemtype:"ChargeInfos",timestamp_begin:0,timestamp_end:0,timestamp_diff_flag:0,timestamp_diff:0,infos:[]},p.chargeInfosTimer=null,p.chargeInfosInterval=6e4,p.qualityTimerInterval=3e3,p.maxRetryCount=5,p.previewVideoList=[],p.signalList={},p.soundLevelDelegate=!1,p.soundLevelInterval=1e3,p.soundLevelTimer=null,p.tryCountConnectInterval=3e3,p.checkMessageTimeout=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in p.signalList)<span class="cstat-no" title="statement not covered" >p.signalList[t].signal&amp;&amp;p.signalList[t].signal.checkMessageTimeout()}</span></span>,p.getAllInUseUrl=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var i in p.signalList)<span class="cstat-no" title="statement not covered" >t.push(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,p.onDisconnectHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(p.logger.info("zsc.od.0 call"),p.signalList[t]){var i=<span class="cstat-no" title="statement not covered" >p.signalList[t];<span class="cstat-no" title="statement not covered" ></span>delete p.signalList[t];<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;i.publishConnectedList.length;n++){var l=<span class="cstat-no" title="statement not covered" >p.publisherList[i.publishConnectedList[n]];<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;l.publisher&amp;&amp;l.publisher.onDisconnect()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(n=0;n&lt;i.playConnectedList.length;n++){var e=<span class="cstat-no" title="statement not covered" >p.playerList[i.playConnectedList[n]];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.player&amp;&amp;e.player.onDisconnect()}<span class="cstat-no" title="statement not covered" ></span>p</span>.stopSignalHeartbeat(),p.stopChargeInfosUpload(),p.stopSoundLevel()}</span>}</span>,p.logger=i,p.stateCenter=n,p.dataReport=new e.ZegoDataReport(p.logger),p.ac=l,p}return p(i,t),i.prototype.onSignalDisconnected=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},i.prototype.setQualityMonitorCycle=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.qmc.0 timeInterval "+t),this.qualityTimerInterval=t}</span>,i.prototype.setSessionInfo=function(t,i,n,l){this.logger.debug("zsc.ssi.0 called"),this.appid=t,this.userid=i,this.token=n,this.testEnvironment=l},i.prototype.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onUpdateHeartBeartIntervalHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t!=this.heartbeatInterval&amp;&amp;(this.logger.debug("zsc.uhb.0 update "+t),this.heartbeatTimer&amp;&amp;(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null),this.heartbeatInterval=t,this.startSignalHeartbeat())}</span>,i.prototype.switchDevice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){var e,v,T,S,R,r,h=<span class="cstat-no" title="statement not covered" >this,</span>u=<span class="cstat-no" title="statement not covered" >null,</span>L=<span class="cstat-no" title="statement not covered" >/Safari/.test(navigator.userAgent)&amp;&amp;!/Chrome/.test(navigator.userAgent);<span class="cstat-no" title="statement not covered" ></span>if(e=this.checkPreview(i)){<span class="cstat-no" title="statement not covered" >delete(v=e.mediaStreamConfig).facingMode,"video"===t?(v.videoInput=n,S=i.srcObject.getVideoTracks()[0]):(v.audioInput=n,S=i.srcObject.getAudioTracks()[0]),!L&amp;&amp;S.stop();v</span>ar M=<span class="cstat-no" title="statement not covered" >e.getMediaStreamConstraints(v);<span class="cstat-no" title="statement not covered" ></span>navigator.mediaDevices.getUserMedia(M).then(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >for(var p in"video"===t?(R=n.getVideoTracks()[0],e.localStream.removeTrack(e.localStream.getVideoTracks()[0])):(R=n.getAudioTracks()[0],e.localStream.removeTrack(e.localStream.getAudioTracks()[0])),h.publisherList)<span class="cstat-no" title="statement not covered" >h.publisherList[p].localVideo===i&amp;&amp;(r=p);<span class="cstat-no" title="statement not covered" >r</span></span>&amp;&amp;(u=h.publisherList[r].publisher,(T=u.peerConnection.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track.kind===R.kind}</span>))?T.replaceTrack(R):h.logger.warn("zg.sd.0 no sender found, only swithcing device on localMediaElement")),e.localStream.addTrack(R),u.signal.sendStreamStatus(E.getSeq(),u.sessionId,e.localStream.getVideoTracks()[0].enabled?0:2,e.localStream.getAudioTracks()[0].enabled?0:2),l&amp;&amp;l()}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return p&amp;&amp;p(t)}</span>)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zg.sd.0 no preview found")}</span></span>,i.prototype.enableMicrophone=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this.checkPreview(t);<span class="cstat-no" title="statement not covered" ></span>return n?n.enableMicrophone(i,this):(this.logger.info("zsc.em.0 no preview"),!1)}</span>,i.prototype.enableCamera=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this.checkPreview(t);<span class="cstat-no" title="statement not covered" ></span>return n?n.enableCamera(i,this):(this.logger.error("zsc.ec.0 no preview"),!1)}</span>,i.prototype.startPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.sp.0 localVideo null"),!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.checkPreview(t);<span class="cstat-no" title="statement not covered" ></span>return e?(this.logger.warn("zsc.sp.0 localvideo already exist"),!0):(e=new v.ZegoPreview(this.logger),this.previewVideoList.push(e),e.startPreview(t,i,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >p.logger.debug("zsc.sp.0 call success"),n&amp;&amp;n()}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.previewVideoList=p.previewVideoList.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t!==e}</span>),l&amp;&amp;l(t)}</span>),!0)}</span>,i.prototype.stopPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return this.logger.warn("zsc.sp.0 localVideo null"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i in this.publisherList)<span class="cstat-no" title="statement not covered" >this.publisherList[i].localVideo===t&amp;&amp;(this.publisherList[i].localVideo=null);v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.checkPreview(t);<span class="cstat-no" title="statement not covered" ></span>return n?(n.previewSuc&amp;&amp;(n.stopPreview(),this.removePreview(n)),!0):(this.logger.warn("zsc.sp.0 no preview"),!1)}</span>,i.prototype.setPublishStateStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >this,</span>p=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t);<span class="cstat-no" title="statement not covered" ></span>if(this.publisherList[p])<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.pss.0 publisher already exist"),!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >new T.ZegoPublish(this.logger,null,this.dataReport,this.qualityTimerInterval,this);<span class="cstat-no" title="statement not covered" ></span>return e.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,p){var e=<span class="cstat-no" title="statement not covered" >l.publisherList[n];<span class="cstat-no" title="statement not covered" ></span>e?l.onPublishStateUpdate(i,e.streamId,p):l.logger.error("zsc.psuh.0 cannot find publish "+t)}</span>,e.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){var p=<span class="cstat-no" title="statement not covered" >l.publisherList[i];<span class="cstat-no" title="statement not covered" ></span>p?l.onPublishQualityUpdate(p.streamId,n):l.logger.error("zsc.psuh.0 cannot find publish "+t)}</span>,this.publisherList[p]={localVideo:i,publisher:e,serverUrls:[],retryCount:0,streamId:t,playOption:n,tryCountConnect:1,countConnectTimer:void 0},this.dataReport.eventStart(e.reportSeq,"GetSignalUrl"),!0}</span>,i.prototype.getTotalStreamId=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.testEnvironment&amp;&amp;-1==t.indexOf("zegotest-")){var i=<span class="cstat-no" title="statement not covered" >"zegotest-"+this.appid+"-"+t;<span class="cstat-no" title="statement not covered" ></span>return this.logger.info("zsc.gts.0 test streamid "+i),i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,i.prototype.getBackStreamId=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.testEnvironment&amp;&amp;t?t.replace("zegotest-"+this.appid+"-",""):t}</span>,i.prototype.startPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.sps.0 call");v</span>ar l=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t),</span>p=<span class="cstat-no" title="statement not covered" >this.publisherList[l];<span class="cstat-no" title="statement not covered" ></span>if(!p)<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.sps.0 publisher don't exist"),!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >p.publisher;<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.eventEndWithMsg(e.reportSeq,"GetSignalUrl",{urls:i}),!i||0===i.length)<span class="cstat-no" title="statement not covered" >return this.onPublishStateUpdate(E.ENUM_PUBLISH_STATE_UPDATE.error,t,E.publishErrorList.DISPATCH_ERROR),this.logger.info("zsc.sps.0 server don't have signal url"),!1;<span class="cstat-no" title="statement not covered" >p</span></span>.serverUrls=p.serverUrls.concat(i);v</span>ar v=<span class="cstat-no" title="statement not covered" >i.indexOf(this.server);<span class="cstat-no" title="statement not covered" ></span>return-1!==v&amp;&amp;(p.serverUrls.splice(v,1),p.serverUrls.unshift(this.server)),this.connectPublishServer(l)}</span>,i.prototype.updateWaitingList=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){<span class="cstat-no" title="statement not covered" >i?t.publishWaitingList.push({streamId:n,success:l,error:p}):t.playWaitingList.push({streamId:n,success:l,error:p})}</span>,i.prototype.publishStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this.publisherList[t].publisher;<span class="cstat-no" title="statement not covered" ></span>if(i){var n=<span class="cstat-no" title="statement not covered" >null,</span>l=<span class="cstat-no" title="statement not covered" >null,</span>p=<span class="cstat-no" title="statement not covered" >this.publisherList[t].playOption,</span>e=<span class="cstat-no" title="statement not covered" >this.checkPreview(this.publisherList[t].localVideo);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(n=e.localStream,l=e.videoInfo),n?(this.logger.debug("zsc.ps.0 call success"),i.startPublish(t,n,l,e.mediaStreamConfig,p)):this.logger.error("zsc.ps.0 no localStream found before publish")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zsc.ps.0 publisher don't exist")}</span></span>,i.prototype.connectPublishServer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >this.publisherList[t];<span class="cstat-no" title="statement not covered" ></span>return n?(this.dataReport.eventStart(n.publisher.reportSeq,"ConnectServer"),this.connetWithReuseSignalServerTimer(t,!0,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){var p=<span class="cstat-no" title="statement not covered" >i.publisherList[t];<span class="cstat-no" title="statement not covered" ></span>if(p){var e=<span class="cstat-no" title="statement not covered" >p.publisher;<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEndWithMsg(e.reportSeq,"ConnectServer",{result:0,server:l});v</span>ar v=<span class="cstat-no" title="statement not covered" >n.tokenInfo;<span class="cstat-no" title="statement not covered" ></span>i.logger.info("zsc.cps.0 update token success"),v&amp;&amp;v.report&amp;&amp;(e.qualityUpload=v.report,e.qualityUploadInterval=v.report_interval),e.signal=n.signal,p.retryCount=0,i.server=l,i.publishStream(t),i.getTokenSuccess()}</span>else <span class="cstat-no" title="statement not covered" >i.logger.info("zsc.cps.1 check publisher don't exist")}</span></span>else <span class="cstat-no" title="statement not covered" >i.logger.info("zsc.cps.0 after connect publisher don't exist")}</span></span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.logger.error("zsc.cps.0 "+t+" connect fail "+n);v</span>ar l=<span class="cstat-no" title="statement not covered" >i.publisherList[t];<span class="cstat-no" title="statement not covered" ></span>l?i.shouldRetry(l,n)?(i.logger.info("zsc.cps.1 retry connect"),l.serverUrls.splice(0,1),l.retryCount+=1,i.connectPublishServer(t)):i.onPublishStateUpdate(E.ENUM_PUBLISH_STATE_UPDATE.error,t,E.publishErrorList.DISPATCH_TIMEOUT):i.logger.info("zsc.cps.0 after connect publisher don't exist")}</span>),!0):(this.logger.error("zsc.cps.0 publisher don't exist"),!1)}</span>,i.prototype.shouldRetry=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return 0!=t.serverUrls.length&amp;&amp;(!(t.retryCount&gt;=this.maxRetryCount)&amp;&amp;3==i)}</span>,i.prototype.getTokenSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.gts.0 call")}</span>,i.prototype.stopPublishingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t),</span>n=<span class="cstat-no" title="statement not covered" >this.publisherList[i];<span class="cstat-no" title="statement not covered" ></span>n?(this.publisherList[i].countConnectTimer&amp;&amp;clearTimeout(this.publisherList[i].countConnectTimer),delete this.publisherList[i],n.publisher&amp;&amp;(n.publisher.stopPublish(),delete n.publisher),this.removeStreamFromSignal(!0,i),this.stopSignalHeartbeat(),this.stopChargeInfosUpload(),this.stopSoundLevel(),this.logger.debug("zsc.sps.0.1 call success")):this.logger.warn("zsc.sps.0.1 publisher don't exist")}</span>,i.prototype.setPlayStreamAudioOutput=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t);<span class="cstat-no" title="statement not covered" ></span>if(null!=i&amp;&amp;0!=i.length){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.psao.1 device "+i);v</span>ar l=<span class="cstat-no" title="statement not covered" >this.playerList[n];<span class="cstat-no" title="statement not covered" ></span>return l?l.player?l.player.setAudioDestination(i):(this.logger.info("zsc.psao.1 player don't exist"),!1):(this.logger.info("zsc.psao.1 play don't exist"),!1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>,i.prototype.setStreamAudioOutput=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return!(null==i||0==i.length||!t)&amp;&amp;(this.logger.debug("zsc.ssao.0 device "+i),t?"undefined"!==t.sinkId?(t.setSinkId(i).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.logger.info("zsc.ssao.0 success device: "+i)}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.logger.info("zsc.ssao.0 "+t.name)}</span>),!0):(this.logger.error("zsc.ssao.0 browser does not suppport"),!1):(this.logger.error("zsc.ssao.0 no localVideo"),!1))}</span>,i.prototype.connetWithReuseSignalServer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zsc.crss.0 begin "+n);v</span>ar v=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.signalList[n])<span class="cstat-no" title="statement not covered" >(v=this.signalList[n]).state==S.ENUM_SIGNAL_STATE.connected?(this.logger.info("zsc.crss.0 already connected "+n+" streamId: "+t),i?v.publishConnectedList.push(t):v.playConnectedList.push(t),l(t,v)):v.state==S.ENUM_SIGNAL_STATE.connecting&amp;&amp;(this.logger.debug("zsc.crss.0 signal is connecting "+n+" streamId: "+t),this.updateWaitingList(v,i,t,l,p));e</span>lse{<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.crss.0 new signal "+n+" streamId: "+t);v</span>ar T=<span class="cstat-no" title="statement not covered" >new R.ZegoSignal(this.logger,this.stateCenter);<span class="cstat-no" title="statement not covered" ></span>T.setSessionInfo(this.appid,this.userid),T.onUpdateHeartBeartInterval=this.onUpdateHeartBeartIntervalHandle,T.onDisconnect=this.onDisconnectHandle,this.signalList[n]={signal:T,state:S.ENUM_SIGNAL_STATE.connecting,publishWaitingList:[],playWaitingList:[],publishConnectedList:[],playConnectedList:[],tokenInfo:null,isTimeOut:!1},this.updateWaitingList(this.signalList[n],i,t,l,p),T.connectServer(this.token,n,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,l){<span class="cstat-no" title="statement not covered" >(v=e.signalList[n]).isTimeOut&amp;&amp;(e.logger.error("zsc.crss.0 connected "+i+" over time"),T.disconnectServer(),delete e.signalList[n]);v</span>ar p,E,R=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(0!=t){<span class="cstat-no" title="statement not covered" >for(e.logger.debug("zsc.crss.0 connect failed "+i),R=0;R&lt;v.publishWaitingList.length;R++)<span class="cstat-no" title="statement not covered" >(p=v.publishWaitingList[R]).error&amp;&amp;p.error(p.streamId,t);<span class="cstat-no" title="statement not covered" >f</span></span>or(R=0;R&lt;v.playWaitingList.length;R++)<span class="cstat-no" title="statement not covered" >(E=v.playWaitingList[R]).error&amp;&amp;E.error(E.streamId,t);<span class="cstat-no" title="statement not covered" >d</span></span>elete e.signalList[n]}</span>else{<span class="cstat-no" title="statement not covered" >for(e.logger.debug("zsc.crss.0 connected success "+i),v.state=S.ENUM_SIGNAL_STATE.connected,v.tokenInfo=l,R=0;R&lt;v.publishWaitingList.length;R++)<span class="cstat-no" title="statement not covered" >(p=v.publishWaitingList[R]).success&amp;&amp;p.success(p.streamId,v),v.publishConnectedList.push(p.streamId);<span class="cstat-no" title="statement not covered" >f</span></span>or(R=0;R&lt;v.playWaitingList.length;R++)<span class="cstat-no" title="statement not covered" >(E=v.playWaitingList[R]).success&amp;&amp;E.success(E.streamId,v),v.playConnectedList.push(E.streamId);<span class="cstat-no" title="statement not covered" >v</span></span>.publishWaitingList=[],v.playWaitingList=[],null==e.heartbeatTimer&amp;&amp;e.startSignalHeartbeat(),null==e.chargeInfosTimer&amp;&amp;e.startChargeInfosUpload(),null==e.soundLevelTimer&amp;&amp;e.soundLevelDelegate&amp;&amp;e.startSoundLevel()}</span>}</span>)}</span>}</span>,i.prototype.setPlayStateStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t);<span class="cstat-no" title="statement not covered" ></span>if(this.playerList[p])<span class="cstat-no" title="statement not covered" >return this.logger.warn("zsc.pss.1 player already exist"),!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >new r.ZegoPlayWeb(this.logger,null,this.dataReport,this.qualityTimerInterval,this);<span class="cstat-no" title="statement not covered" ></span>return e.onPlayStateUpdate=this.onPlayStateUpdate,e.onPlayQualityUpdate=this.onPlayQualityUpdate,e.onVideoSizeChanged=this.onVideoSizeChanged,e.onRemoteCameraStatusUpdate=this.onRemoteCameraStatusUpdate,e.onRemoteMicStatusUpdate=this.onRemoteMicStatusUpdate,this.playerList[p]={player:e,remoteVideo:i,audioOutput:n,signal:null,serverUrls:[],retryCount:0,playOption:l,tryCountConnect:1,countConnectTimer:void 0},this.dataReport.eventStart(e.reportSeq,"GetSignalUrl"),!0}</span>,i.prototype.startPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.sps.1 start play called");v</span>ar l=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t),</span>p=<span class="cstat-no" title="statement not covered" >this.playerList[l];<span class="cstat-no" title="statement not covered" ></span>if(!p)<span class="cstat-no" title="statement not covered" >return this.logger.error("zsc.sps.1 player don't exist"),!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >p.player;<span class="cstat-no" title="statement not covered" ></span>if(this.dataReport.eventEndWithMsg(e.reportSeq,"GetSignalUrl",{urls:i}),0==i.length)<span class="cstat-no" title="statement not covered" >return this.onPlayStateUpdate(E.ENUM_PLAY_STATE_UPDATE.error,t,E.playErrorList.DISPATCH_ERROR),this.logger.info("zsc.sps.1 server don't have signal url"),!1;<span class="cstat-no" title="statement not covered" >p</span></span>.serverUrls=p.serverUrls.concat(i);v</span>ar v=<span class="cstat-no" title="statement not covered" >i.indexOf(this.server);<span class="cstat-no" title="statement not covered" ></span>return-1!==v&amp;&amp;(p.serverUrls.splice(v,1),p.serverUrls.unshift(this.server)),this.connectPlayServer(l)}</span>,i.prototype.connectPlayServer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >this.playerList[t];<span class="cstat-no" title="statement not covered" ></span>return n?(this.dataReport.eventStart(n.player.reportSeq,"ConnectServer"),this.connetWithReuseSignalServerTimer(t,!1,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){var p=<span class="cstat-no" title="statement not covered" >i.playerList[t];<span class="cstat-no" title="statement not covered" ></span>if(p){var e=<span class="cstat-no" title="statement not covered" >p.player;<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEndWithMsg(e.reportSeq,"ConnectServer",{result:0,server:l});v</span>ar v=<span class="cstat-no" title="statement not covered" >n.tokenInfo;<span class="cstat-no" title="statement not covered" ></span>i.logger.info("zsc.cps.1 update token success"),v&amp;&amp;v.report&amp;&amp;(e.qualityUpload=v.report,e.qualityUploadInterval=v.report_interval),e.signal=n.signal,p.retryCount=0,i.server=l,i.playStream(t),i.getTokenSuccess()}</span>else <span class="cstat-no" title="statement not covered" >i.logger.error("zsc.cps.1 checkplayer don't exist")}</span></span>else <span class="cstat-no" title="statement not covered" >i.logger.error("zsc.cps.1 after connect player don't exist")}</span></span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){var l=<span class="cstat-no" title="statement not covered" >i.playerList[t];<span class="cstat-no" title="statement not covered" ></span>if(l)<span class="cstat-no" title="statement not covered" >if(i.shouldRetry(l,n)){<span class="cstat-no" title="statement not covered" >i.logger.info("zsc.cps.1 retry connect");<span class="cstat-no" title="statement not covered" >l</span>.serverUrls[0];<span class="cstat-no" title="statement not covered" >l</span>.serverUrls.splice(0,1),l.retryCount+=1,i.connectPlayServer(t)}</span>else <span class="cstat-no" title="statement not covered" >i.onPlayStateUpdate(E.ENUM_PLAY_STATE_UPDATE.error,t,E.playErrorList.TOKEN_ERROR);e</span></span>lse <span class="cstat-no" title="statement not covered" >i.logger.error("zsc.cps.1 after connect player don't exist")}</span></span>),!0):(this.logger.error("zsc.cps.1 player don't exist"),!1)}</span>,i.prototype.connetWithReuseSignalServerTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p,e,v,T,E=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;this.publisherList[t]){<span class="cstat-no" title="statement not covered" >if(v=(p=this.publisherList[t].serverUrls)[0==(T=(this.publisherList[t].tryCountConnect-1)%p.length)?p.length-1:T-1],1!==this.publisherList[t].tryCountConnect&amp;&amp;this.signalList[v]&amp;&amp;(this.signalList[v].isTimeOut=!0),this.publisherList[t].tryCountConnect&gt;3*p.length)<span class="cstat-no" title="statement not covered" >return void this.logger.error("zs.crsst.0 beyond max limit");<span class="cstat-no" title="statement not covered" >t</span></span>his.publisherList[t].countConnectTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >E.connetWithReuseSignalServerTimer(t,i,n,l)}</span>,this.tryCountConnectInterval),e=p[T],this.logger.info("zs.crsst.0 called "+this.publisherList[t].tryCountConnect+" "+e),this.connetWithReuseSignalServer(t,i,e,<span class="fstat-no" title="function not covered" >fu</span>nction(i,l){<span class="cstat-no" title="statement not covered" >clearTimeout(E.publisherList[t].countConnectTimer),E.publisherList[t].tryCountConnect=1,n(i,l,e)}</span>,this.publisherList[t].tryCountConnect===3*p.length?l:void 0),++this.publisherList[t].tryCountConnect}</span>else <span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;this.playerList[t]){<span class="cstat-no" title="statement not covered" >if(v=(p=this.playerList[t].serverUrls)[0==(T=(this.playerList[t].tryCountConnect-1)%p.length)?p.length-1:T-1],1!==this.playerList[t].tryCountConnect&amp;&amp;this.signalList[v]&amp;&amp;(this.signalList[v].isTimeOut=!0),this.playerList[t].tryCountConnect&gt;3*p.length)<span class="cstat-no" title="statement not covered" >return void this.logger.error("zs.crsst.0 beyond max limit");<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.info("zs.crsst.0 called "+this.playerList[t].tryCountConnect),this.playerList[t].countConnectTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >E.connetWithReuseSignalServerTimer(t,i,n,l)}</span>,this.tryCountConnectInterval),e=p[(this.playerList[t].tryCountConnect-1)%p.length],this.connetWithReuseSignalServer(t,i,e,<span class="fstat-no" title="function not covered" >fu</span>nction(i,l){<span class="cstat-no" title="statement not covered" >clearTimeout(E.playerList[t].countConnectTimer),E.playerList[t].tryCountConnect=1,n(i,l,e)}</span>,this.playerList[t].tryCountConnect===3*p.length?l:void 0),++this.playerList[t].tryCountConnect}</span>}</span></span>,i.prototype.playStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this.playerList[t].player;<span class="cstat-no" title="statement not covered" ></span>i?(this.logger.info("zsc.ps.1 call success"),i.startPlay(t,this.playerList[t].remoteVideo,this.playerList[t].audioOutput,this.playerList[t].playOption)):this.logger.warn("zsc.ps.1 player don't exist")}</span>,i.prototype.removeStreamFromSignal=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var l in this.signalList){var p=<span class="cstat-no" title="statement not covered" >this.signalList[l];<span class="cstat-no" title="statement not covered" ></span>if(t){<span class="cstat-no" title="statement not covered" >for(var e=0;e&lt;p.publishConnectedList.length;e++)<span class="cstat-no" title="statement not covered" >if(p.publishConnectedList[e]===i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.rsfs.0 found from publish"),p.publishConnectedList.splice(e,1);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >for(var v=0;v&lt;p.playConnectedList.length;v++)<span class="cstat-no" title="statement not covered" >if(p.playConnectedList[v]===i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.rsfs.0 found from play"),p.playConnectedList.splice(v,1);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>0</span></span></span>==p.publishConnectedList.length&amp;&amp;0==p.playConnectedList.length&amp;&amp;(p.signal.disconnectServer(),n.push(l))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var T=0;T&lt;n.length;T++)<span class="cstat-no" title="statement not covered" >delete this.signalList[n[T]]}</span></span>,i.prototype.stopSignalHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.ssh.1 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var i in this.signalList)<span class="cstat-no" title="statement not covered" >t+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.heartbeatTimer&amp;&amp;0==t&amp;&amp;(this.logger.info("zsc.ssh.1 stop"),clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null)}</span>,i.prototype.stopChargeInfosUpload=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.sciu.0 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var i in this.signalList)<span class="cstat-no" title="statement not covered" >t+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.chargeInfosTimer&amp;&amp;0==t&amp;&amp;(this.logger.info("zsc.sciu.0 stop"),clearTimeout(this.chargeInfosTimer),this.chargeInfosTimer=null)}</span>,i.prototype.getPublisher=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >null,</span>n=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t);<span class="cstat-no" title="statement not covered" ></span>return this.publisherList[n]&amp;&amp;this.publisherList[n].publisher&amp;&amp;(i=this.publisherList[n].publisher),i}</span>,i.prototype.stopPlayingStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this.getTotalStreamId(t),</span>n=<span class="cstat-no" title="statement not covered" >this.playerList[i];<span class="cstat-no" title="statement not covered" ></span>n?(this.playerList[i].countConnectTimer&amp;&amp;clearTimeout(this.playerList[i].countConnectTimer),delete this.playerList[i],n.player&amp;&amp;(n.player.stopPlay(),delete n.player),this.removeStreamFromSignal(!1,i),this.stopSignalHeartbeat(),this.stopChargeInfosUpload(),this.stopSoundLevel(),this.logger.debug("zsc.sps.1.1 call success")):this.logger.info("zsc.sps.1.1 player don't exist")}</span>,i.prototype.reset=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.publisherList)<span class="cstat-no" title="statement not covered" >this.publisherList[t].publisher&amp;&amp;this.publisherList[t].publisher.stopPublish();<span class="cstat-no" title="statement not covered" >f</span></span>or(var i in this.playerList)<span class="cstat-no" title="statement not covered" >this.playerList[i].player&amp;&amp;this.playerList[i].player.stopPlay();<span class="cstat-no" title="statement not covered" >f</span></span>or(var n in this.signalList)<span class="cstat-no" title="statement not covered" >this.signalList[n].signal&amp;&amp;this.signalList[n].signal.disconnectServer();<span class="cstat-no" title="statement not covered" >t</span></span>his.playerList={},this.publisherList={},this.signalList={},this.server="",this.heartbeatTimer&amp;&amp;(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null)}</span>,i.prototype.startSignalHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zsc.ssh.0 call"),this.heartbeatTimer&amp;&amp;(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null),this.heartbeatTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.checkSignalHeartbeat()}</span>,this.heartbeatInterval)}</span>,i.prototype.checkSignalHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.logger.debug("zsc.csh.0 call"),this.signalList)<span class="cstat-no" title="statement not covered" >this.signalList[t].signal&amp;&amp;this.signalList[t].signal.sendHeartbeat();<span class="cstat-no" title="statement not covered" >t</span></span>his.heartbeatTimer&amp;&amp;this.startSignalHeartbeat()}</span>,i.prototype.startChargeInfosUpload=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zsc.sciu.0 call"),this.chargeInfosTimer&amp;&amp;(clearTimeout(this.chargeInfosTimer),this.chargeInfosTimer=null),this.chargeInfosTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.checkChargeInfos()}</span>,this.chargeInfosInterval)}</span>,i.prototype.checkChargeInfos=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.cci.0 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >{is_publishing:0,play_max_audio_bitrate:0,play_stream_resolution_infos:[]};<span class="cstat-no" title="statement not covered" ></span>for(var i in this.chargeInfos.timestamp_begin=(new Date).getTime(),this.publisherList){<span class="cstat-no" title="statement not covered" >this.publisherList[i].publisher.state===S.ENUM_PUBLISH_STATE.publishing&amp;&amp;(t.is_publishing=1);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>.play_max_audio_bitrate=0;v</span>ar n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >l.playerList[i].remoteVideo,</span>p=<span class="cstat-no" title="statement not covered" >{video_width:n.videoWidth||0,video_height:n.videoHeight||0,count:1};<span class="cstat-no" title="statement not covered" ></span>if(!t.play_stream_resolution_infos.find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.video_width==p.video_width&amp;&amp;t.video_height==p.video_height&amp;&amp;(t.count++,!0)}</span>)&amp;&amp;t.play_stream_resolution_infos.push(p),0==p.video_width&amp;&amp;0==p.video_height){var e=<span class="cstat-no" title="statement not covered" >1e3*l.playerList[i].player.lastPlayStats.audioBitrate;<span class="cstat-no" title="statement not covered" ></span>e&gt;t.play_max_audio_bitrate&amp;&amp;(t.play_max_audio_bitrate=e)}</span>}</span>,</span>l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(var p in this.playerList)<span class="cstat-no" title="statement not covered" >n(p);<span class="cstat-no" title="statement not covered" >0</span></span>!==this.chargeInfos.timestamp_end?(this.chargeInfos.timestamp_diff=this.chargeInfos.timestamp_begin-this.chargeInfos.timestamp_end,this.chargeInfos.timestamp_diff_flag=1):(this.chargeInfos.timestamp_diff=0,this.chargeInfos.timestamp_diff_flag=0),this.chargeInfos.timestamp_end=(new Date).getTime(),this.chargeInfos.infos=[t],0!==t.play_stream_resolution_infos.length&amp;&amp;this.logger.report(this.chargeInfos),this.chargeInfosTimer&amp;&amp;this.startChargeInfosUpload()}</span>,i.prototype.startSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zsc.ssl.0 call"),this.soundLevelTimer&amp;&amp;(clearTimeout(this.soundLevelTimer),this.soundLevelTimer=null),this.soundLevelTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.checkSoundLevel()}</span>,this.soundLevelInterval)}</span>,i.prototype.checkSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zsc.csl.0 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var i in this.publisherList){var n=<span class="cstat-no" title="statement not covered" >this.publisherList[i].publisher;<span class="cstat-no" title="statement not covered" ></span>t.push({streamID:this.getBackStreamId(n.streamId),soundLevel:n.soundLevel,type:"push"})}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i in this.playerList){var l=<span class="cstat-no" title="statement not covered" >this.playerList[i].player;<span class="cstat-no" title="statement not covered" ></span>t.push({streamID:this.getBackStreamId(l.streamId),soundLevel:l.soundLevel,type:"pull"})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.soundLevelDelegate&amp;&amp;t.length&gt;0&amp;&amp;this.onSoundLevelUpdate(t),this.soundLevelDelegate&amp;&amp;this.startSoundLevel()}</span>,i.prototype.setSoundLevelDelegate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >for(var n in this.logger.info("zsc.ssd.0 call"),i&amp;&amp;(this.soundLevelInterval=i),this.soundLevelDelegate=t,this.publisherList){var l=<span class="cstat-no" title="statement not covered" >this.publisherList[n].publisher;<span class="cstat-no" title="statement not covered" ></span>t?l.startSoundLevel():l.stopSoundLevel()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var n in this.playerList){var p=<span class="cstat-no" title="statement not covered" >this.playerList[n].player;<span class="cstat-no" title="statement not covered" ></span>t?p.startSoundLevel():p.stopSoundLevel()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t){<span class="cstat-no" title="statement not covered" >this.logger.info("zsc.ssd.0 start getting sound");v</span>ar e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var v in this.signalList)<span class="cstat-no" title="statement not covered" >e+=1;<span class="cstat-no" title="statement not covered" >n</span></span>ull==this.soundLevelTimer&amp;&amp;e&gt;0&amp;&amp;this.startSoundLevel()}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zsc.ssd.0 stop getting sound"),this.soundLevelTimer&amp;&amp;clearTimeout(this.soundLevelTimer),this.soundLevelTimer=null,this.soundLevelInterval=1e3}</span></span>,i.prototype.stopSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var i in this.signalList)<span class="cstat-no" title="statement not covered" >t+=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.soundLevelTimer&amp;&amp;0==t&amp;&amp;(this.logger.info("zsc.ssl.0 stop"),clearTimeout(this.soundLevelTimer),this.soundLevelTimer=null,this.soundLevelInterval=1e3)}</span>,i.prototype.checkPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;this.previewVideoList.length;i++)<span class="cstat-no" title="statement not covered" >if(this.previewVideoList[i].localVideo===t)<span class="cstat-no" title="statement not covered" >return this.previewVideoList[i];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn null}</span>,i.prototype.removePreview=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;this.previewVideoList.length;i++)<span class="cstat-no" title="statement not covered" >if(this.previewVideoList[i]===t){<span class="cstat-no" title="statement not covered" >this.previewVideoList.splice(i,1);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>,i.prototype.onPlayerStreamUrlUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onVideoSizeChanged=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onSoundLevelUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},i.prototype.setPublishStreamConstraints=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t=this.getTotalStreamId(t);v</span>ar e=<span class="cstat-no" title="statement not covered" >this.publisherList[t],</span>v=<span class="cstat-no" title="statement not covered" >/Safari/.test(navigator.userAgent)&amp;&amp;!/Chrome/.test(navigator.userAgent);<span class="cstat-no" title="statement not covered" ></span>if(e){var T=<span class="cstat-no" title="statement not covered" >this.checkPreview(e.localVideo);<span class="cstat-no" title="statement not covered" ></span>if(T)<span class="cstat-no" title="statement not covered" >if(!i||0==Object.keys(i).length||i.width&lt;120||i.height&lt;120)<span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 constraints wrong");e</span>lse{<span class="cstat-no" title="statement not covered" >T.mediaStreamConfig.videoInput!==i.videoInput&amp;&amp;delete T.mediaStreamConfig.facingMode&amp;&amp;delete i.facingMode;v</span>ar E=<span class="cstat-no" title="statement not covered" >Object.assign(T.mediaStreamConfig,i);<span class="cstat-no" title="statement not covered" ></span>if(E.externalCapture||E.externalMediaStream)<span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 do not support external stream");e</span>lse{var S=<span class="cstat-no" title="statement not covered" >T.getMediaStreamConstraints(E),</span>R=<span class="cstat-no" title="statement not covered" >e.publisher.localStream;<span class="cstat-no" title="statement not covered" ></span>if(!e.publisher.peerConnection.getSenders||!e.publisher.peerConnection.getSenders()[0].replaceTrack)<span class="cstat-no" title="statement not covered" >return this.logger.error("zc.spsc.0 set publish constraints is not supported"),void(l&amp;&amp;l({code:1,msg:"not supported"}));<span class="cstat-no" title="statement not covered" >!</span></span>v&amp;&amp;R.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stop()}</span>),navigator.mediaDevices.getUserMedia(S).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >R.getTracks().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.kind===t.kind}</span>);<span class="cstat-no" title="statement not covered" ></span>e.publisher.peerConnection.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track.kind===t.kind}</span>).replaceTrack(t),R.removeTrack(i),R.addTrack(t),p.logger.info("zc.spsc.0 set constraints success")}</span>),n&amp;&amp;n()}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.logger.error("zc.spsc.0 fail reason ",t.name),l&amp;&amp;l({code:2,msg:t.name})}</span>)}</span>}</span>e</span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 preview no found")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zc.spsc.0 publisher not found")}</span></span>,i.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>return n?n.startMixingAudio(i):(this.logger.error("zc.sma.0 publisher doesn't exist"),!1)}</span>,i.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this.getPublisher(t);<span class="cstat-no" title="statement not covered" ></span>return n?n.stopMixingAudio(i):(this.logger.error("zc.sma.1 publisher doesn't exist"),!1)}</span>,i}(n(16).ZegoStreamCenter);i.ZegoStreamCenterWeb=h},function(t,i,n){"use strict";var l=this&amp;&amp;this.__assign||Object.assign||<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i,n=1,l=arguments.length;n&lt;l;n++)<span class="cstat-no" title="statement not covered" >for(var p in i=arguments[n])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(i,p)&amp;&amp;(t[p]=i[p]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>;</span>Object.defineProperty(i,"__esModule",{value:!0});var p=function(){function t(t){this.log=t,this.dataStatistics={},this.logger=t}return t.prototype.newReport=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.dataStatistics[t]={abs_time:Date.now(),time_consumed:0,error:0,events:[]}}</span>,t.prototype.addMsgExt=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.dataStatistics[t]?this.dataStatistics[t].msg_ext=i:console.warn(t+" not exist")}</span>,t.prototype.eventStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.dataStatistics[t]?null!=this.dataStatistics[t].events?this.dataStatistics[t].events.push({event:i,abs_time:Date.now(),time_consumed:0}):this.logger.warn("zd.es.0 no events"):this.logger.warn("zd.es.0 no seq match")}</span>,t.prototype.eventEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(this.dataStatistics[t]){var l=<span class="cstat-no" title="statement not covered" >this.dataStatistics[t].events;<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;0!==l.length){<span class="cstat-no" title="statement not covered" >for(var p=l.length-1;p&gt;=0;p--)<span class="cstat-no" title="statement not covered" >if(l[p].event==i&amp;&amp;l[p].time_consumed){<span class="cstat-no" title="statement not covered" >l[p].time_consumed=Date.now()-l[p].abs_time;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zd.ee.0 no events")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zd.ee.0 no seq match")}</span></span>,t.prototype.eventEndWithMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(this.dataStatistics[t]){var p=<span class="cstat-no" title="statement not covered" >this.dataStatistics[t].events;<span class="cstat-no" title="statement not covered" ></span>if(p){<span class="cstat-no" title="statement not covered" >for(var e=p.length-1;e&gt;=0;e--)<span class="cstat-no" title="statement not covered" >if(p[e].event==i&amp;&amp;p[e].time_consumed){<span class="cstat-no" title="statement not covered" >p[e].time_consumed=Date.now()-p[e].abs_time,null==p[e].msg_ext&amp;&amp;(p[e].msg_ext={}),p[e].msg_ext=l({},n);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.ee.0 no events")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.ee.0 no seq match")}</span></span>,t.prototype.addEventInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >if(this.dataStatistics[t]){var p=<span class="cstat-no" title="statement not covered" >this.dataStatistics[t].events;<span class="cstat-no" title="statement not covered" ></span>if(null!=p){<span class="cstat-no" title="statement not covered" >for(var e=p.length-1;e&gt;=0;e--)<span class="cstat-no" title="statement not covered" >if(p[e].event==i&amp;&amp;null!=p[e].time_consumed&amp;&amp;p[e].event==i&amp;&amp;null!=p[e].time_consumed){<span class="cstat-no" title="statement not covered" >null==p[e].msg_ext&amp;&amp;(p[e].msg_ext={}),p[e].msg_ext[n]=l;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.aei.0 no events")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zd.aei.0 no seq match")}</span></span>,t.prototype.addEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.dataStatistics[t]?this.dataStatistics[t].events&amp;&amp;(n?this.dataStatistics[t].events.push({event:i,abs_time:Date.now(),msg_ext:n}):this.dataStatistics[t].events.push({event:i,abs_time:Date.now()})):this.logger.warn("zd.ae.0 no seq match")}</span>,t.prototype.uploadReport=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this.dataStatistics[t];<span class="cstat-no" title="statement not covered" ></span>null!=n&amp;&amp;(n.itemtype=i,n.time_consumed=Date.now()-n.abs_time,this.logger.report(n),delete this.dataStatistics[t])}</span>,t}();i.ZegoDataReport=p},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(1),e=function(){function <span class="fstat-no" title="function not covered" >t(</span>t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.log=t,this.localVideo=null,this.localStream=null,this.previewSuc=!1,this.enableMicrophone=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if(!i.localStream)<span class="cstat-no" title="statement not covered" >return i.logger.error("zp.em.2 no localStream"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var l in i.localStream.getAudioTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >i.enabled=t}</span>),n.publisherList){var e=<span class="cstat-no" title="statement not covered" >n.publisherList[l].publisher;<span class="cstat-no" title="statement not covered" ></span>e.localStream==i.localStream&amp;&amp;e.signal.sendStreamStatus(p.getSeq(),e.sessionId,i.localStream&amp;&amp;i.localStream.getVideoTracks()[0]&amp;&amp;!0===i.localStream.getVideoTracks()[0].enabled?0:2,t?0:2)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.logger.debug("zp.em.2 call success"),!0}</span>,this.enableCamera=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if(!i.localStream)<span class="cstat-no" title="statement not covered" >return i.logger.error("zp.ec.2 no localStream"),!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var l in i.localStream.getVideoTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >i.enabled=t}</span>),n.publisherList){var e=<span class="cstat-no" title="statement not covered" >n.publisherList[l].publisher;<span class="cstat-no" title="statement not covered" ></span>e.localStream==i.localStream&amp;&amp;e.signal.sendStreamStatus(p.getSeq(),e.sessionId,t?0:2,i.localStream&amp;&amp;i.localStream.getAudioTracks()[0]&amp;&amp;1==i.localStream.getAudioTracks()[0].enabled?0:2)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.logger.debug("zp.ec.2 call success"),!0}</span>,this.setAudioDestination=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return i.localVideo?"undefined"!==i.localVideo.sinkId?(i.localVideo.setSinkId(t).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.sad.2 success device: "+t)}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.sad.2 "+t.name)}</span>),!0):(i.logger.error("zp.sad.2 browser does not suppport"),!1):(i.logger.error("zp.sad.2 no localVideo"),!1)}</span>,this.logger=t}</span>return t.prototype.getMediaStreamConstraints=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >{audio:null,video:null};<span class="cstat-no" title="statement not covered" ></span>if(i.audio=!1,i.video=!1,console.log("mediaStreamConfig",t),t.audio&amp;&amp;(void 0===t.audioInput&amp;&amp;void 0===t.noiseSuppression&amp;&amp;void 0===t.autoGainControl&amp;&amp;void 0===t.echoCancellation?(i.audio={},i.audio.noiseSuppression=!0,i.audio.autoGainControl=!0,i.audio.echoCancellation=!0):(i.audio={},void 0!==t.audioInput&amp;&amp;null!==t.audioInput&amp;&amp;(i.audio.deviceId=t.audioInput),void 0!==t.noiseSuppression&amp;&amp;(i.audio.noiseSuppression=t.noiseSuppression),void 0!==t.autoGainControl&amp;&amp;(i.audio.autoGainControl=t.autoGainControl),void 0!==t.echoCancellation&amp;&amp;(i.audio.echoCancellation=t.echoCancellation))),t.video){var n=<span class="cstat-no" title="statement not covered" >640,</span>p=<span class="cstat-no" title="statement not covered" >480,</span>e=<span class="cstat-no" title="statement not covered" >15,</span>v=<span class="cstat-no" title="statement not covered" >800;<span class="cstat-no" title="statement not covered" ></span>if(1===t.videoQuality?(n=l.ENUM_RESOLUTION_TYPE.LOW.width,p=l.ENUM_RESOLUTION_TYPE.LOW.height,e=l.ENUM_RESOLUTION_TYPE.LOW.frameRate,v=l.ENUM_RESOLUTION_TYPE.LOW.bitRate):2===t.videoQuality?(n=l.ENUM_RESOLUTION_TYPE.MEDIUM.width,p=l.ENUM_RESOLUTION_TYPE.MEDIUM.height,e=l.ENUM_RESOLUTION_TYPE.MEDIUM.frameRate,v=l.ENUM_RESOLUTION_TYPE.MEDIUM.bitRate):3===t.videoQuality?(n=l.ENUM_RESOLUTION_TYPE.HIGH.width,p=l.ENUM_RESOLUTION_TYPE.HIGH.height,e=l.ENUM_RESOLUTION_TYPE.HIGH.frameRate,v=l.ENUM_RESOLUTION_TYPE.HIGH.bitRate):4===t.videoQuality?(n=t.width,p=t.height,e=t.frameRate,v=t.maxBitRate||800):this.logger.info("zp.gmsc.2 user default"),!0===t.horizontal){var T=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>p=n,n=T}<span class="cstat-no" title="statement not covered" ></span>i</span>.video={width:n,height:p,frameRate:e,bitRate:v},null!=t.facingMode?i.video.facingMode=t.facingMode:null!=t.videoInput&amp;&amp;null!=t.videoInput&amp;&amp;(i.video.deviceId={exact:t.videoInput}),this.logger.info("zp.gmsc.2 width: "+n+" height: "+p+" rate: "+e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>,t.prototype.startPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zp.sv.2 called"),this.localVideo=t,this.mediaStreamConfig=i,void 0!==navigator.mediaDevices&amp;&amp;null!=navigator.mediaDevices.getUserMedia){<span class="cstat-no" title="statement not covered" >if(i.externalMediaStream instanceof MediaStream)<span class="cstat-no" title="statement not covered" >return this.logger.debug("zp.sv.2 use external media stream"),this.previewSuc=!0,this.localStream=i.externalMediaStream,this.videoInfo={width:i.width,height:i.height,frameRate:i.frameRate,minBitRate:i.minBitRate,maxBitRate:i.maxBitRate},void(n&amp;&amp;n());<span class="cstat-no" title="statement not covered" >i</span></span>f(i.externalCapture)<span class="cstat-no" title="statement not covered" >this.captureStream(t,i)?(this.previewSuc=!0,n&amp;&amp;n()):l&amp;&amp;l("external capture fail");e</span>lse{var e=<span class="cstat-no" title="statement not covered" >this.getMediaStreamConstraints(i);<span class="cstat-no" title="statement not covered" ></span>this.videoInfo=e.video,this.videoInfo&amp;&amp;(this.videoInfo.minBitRate=i.minBitRate||e.video.bitRate),this.videoInfo&amp;&amp;(this.videoInfo.maxBitRate=i.maxBitRate||e.video.bitRate),this.logger.info("zp.sv.2 ",JSON.stringify(e)),navigator.mediaDevices.getUserMedia(e).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(p.logger.info("zp.sv.2 success"),!p.localVideo)<span class="cstat-no" title="statement not covered" >return p.logger.info("zp.sv.2 no localVideo"),void(l&amp;&amp;l("no localVideo"));<span class="cstat-no" title="statement not covered" >p</span></span>.localVideo.srcObject=t,p.localStream=t,p.previewSuc=!0,n&amp;&amp;n()}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.logger.info("zp.sv.2 failed "+t.message),l&amp;&amp;l(t)}</span>)}</span>}</span>else <span class="cstat-no" title="statement not covered" >l&amp;&amp;l("browser don't support")}</span></span>,t.prototype.captureStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return this.logger.info("zp.cs.2 no local video"),!1;v</span></span>ar n,l;<span class="cstat-no" title="statement not covered" >if(t.captureStream)<span class="cstat-no" title="statement not covered" >n=t.captureStream(),this.logger.debug("zp.cs.2 captureStream");e</span>lse{<span class="cstat-no" title="statement not covered" >if(!t.mozCaptureStream)<span class="cstat-no" title="statement not covered" >return this.logger.info("zp.cs.2 don't support capture stream"),!1;<span class="cstat-no" title="statement not covered" >n</span></span>=t.mozCaptureStream(),this.logger.debug("zp.cs.2 mozCaptureStream")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0==n.getTracks().length?(this.logger.error("zp.cs.2 external capture tracks no found"),!1):(this.localStream=n,this.videoInfo={width:t.videoWidth,height:t.videoHeight,frameRate:i.frameRate||15,minBitRate:800,maxBitRate:800},"number"==typeof i.bitRate?(l&lt;48&amp;&amp;(l=48),l&gt;1e4&amp;&amp;(l=1e4),this.videoInfo.minBitRate=this.videoInfo.maxBitRate=i.bitRate):i.bitRate&amp;&amp;i.bitRate.minBitRate&amp;&amp;i.bitRate.maxBitRate&amp;&amp;"number"==typeof i.bitRate.minBitRate&amp;&amp;"number"==typeof i.bitRate.maxBitRate&amp;&amp;i.bitRate.minBitRate&lt;=i.bitRate.maxBitRate&amp;&amp;(this.videoInfo.minBitRate=i.bitRate.minBitRate&lt;48?48:i.bitRate.minBitRate,this.videoInfo.maxBitRate=i.bitRate.maxBitRate&gt;1e4?1e4:i.bitRate.maxBitRate),this.logger.debug("zp.cs.2 called success"),!0)}</span>,t.prototype.stopPreview=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.sv.2.1 called"),this.localStream){var t=<span class="cstat-no" title="statement not covered" >this.localStream.getTracks();<span class="cstat-no" title="statement not covered" ></span>t.reverse(),t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.stop()}</span>),this.localStream=null,this.localVideo.srcObject=null,this.localVideo=null,this.videoInfo=null}</span>}</span>,t}();i.ZegoPreview=e},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(1),e=n(12),v=n(3),T=n(4),E=n(13),S=function(){function <span class="fstat-no" title="function not covered" >t(</span>t,i,n,e,T){<span class="cstat-no" title="statement not covered" >this.state=l.ENUM_PUBLISH_STATE.stop,this.sessionId=0,this.waitingICETimeInterval=5e3,this.waitingAnswerTimeInterval=5e3,this.candidateInfo=[],this.waitingICETimer=null,this.waitingAnswerTimer=null,this.qualityTimer=null,this.publishQualityList=[],this.maxQualityListCount=10,this.lastPublishStats={},this.reportSeq=p.getSeq(),this.qualityUpload=!1,this.qualityUploadInterval=3e4,this.qualityUploadLastTime=0,this.qualitySeq=0,this.maxRetryCount=3,this.currentRetryCount=0,this.retryState=l.ENUM_RETRY_STATE.didNotStart,this.waitingServerTimerInterval=3e3,this.waitingServerTimer=null,this.videoInfo={width:0,height:0,frameRate:0,minBitRate:0,maxBitRate:0},this.mediaStreamConfig=null,this.offerSeq=0,this.audioMixList=[],this.arrayBufferMap={},this.qualityCount=0,this.closeSessionSignal=!1,this.audioBitRate=48e3,this.localSdpRevert=!1,this.videoDecodeType="H264",this.stateNego=l.ENUM_PUBLISH_STATE_NEGO.stop,this.negoInterval=25e3,this.negoTryCount=1,this.negoTryMaxCount=2,this.publishEvent=!1,this.nextSignalTryCount=1,this.waittingConnectedTimer=null,this.waittingConnectedInerval=15e3,this.tryingNexitSignal=!1,this.soundLevel=0,this.script=null,this.mic=null,this.logger=t,this.signal=i,this.dataReport=n,this.streamCenter=T,this.ac=this.streamCenter.ac,this.qualityTimeInterval=e,this.audioMixing=new v.audioMixUtil(t,this.ac),n.newReport(this.reportSeq)}</span>return t.prototype.publishStateUpdateError=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.logger.error("zp.psu.0 call "+JSON.stringify(t)),!i&amp;&amp;(this.state===l.ENUM_PUBLISH_STATE.stop||this.negoTryCount&lt;this.negoTryMaxCount&amp;&amp;this.stateNego&lt;l.ENUM_PUBLISH_STATE_NEGO.iceConnected)||(0!=this.sessionId&amp;&amp;this.shouldSendCloseSession(t)&amp;&amp;(this.signal.sendCloseSession(p.getSeq(),this.sessionId,1),this.closeSessionSignal=!0),this.state=l.ENUM_PUBLISH_STATE.stop,this.onPublishStateUpdate(p.ENUM_PUBLISH_STATE_UPDATE.error,this.streamId,t),this.resetPublish())}</span>,t.prototype.resetPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.rp.0 call"),this.streamId=null,this.state=l.ENUM_PUBLISH_STATE.stop,this.publishEvent=!1,null==this.peerConnection&amp;&amp;null==this.peerConnection||(this.peerConnection.close(),this.peerConnection=null),null!=this.waitingAnswerTimer&amp;&amp;(clearTimeout(this.waitingAnswerTimer),this.waitingAnswerTimer=null),null!=this.waitingICETimer&amp;&amp;(clearTimeout(this.waitingICETimer),this.waitingICETimer=null),null!=this.negoTimer&amp;&amp;(clearTimeout(this.negoTimer),this.negoTimer=null),null!=this.waittingConnectedTimer&amp;&amp;(clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null),this.clearPublishQualityTimer(),this.signal&amp;&amp;(this.signal.unregisterPushCallback("CandidateInfoPush",this.sessionId),this.signal.unregisterPushCallback("MediaDescPush",this.sessionId),this.signal.unregisterPushCallback("CloseSessionPush",this.sessionId)),this.sessionSeq=0,this.offerSeq=0,this.candidateInfo=[],this.publishQualityList=[],this.qualityUploadLastTime=0,this.currentRetryCount=0,this.retryState=l.ENUM_RETRY_STATE.didNotStart,this.clearTryPublishTimer()}</span>,t.prototype.clearTryPublishTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.waitingServerTimer&amp;&amp;(clearTimeout(this.waitingServerTimer),this.waitingServerTimer=null)}</span>,t.prototype.clearPublishQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.qualityTimer&amp;&amp;(clearInterval(this.qualityTimer),this.qualityTimer=null),this.lastPublishStats={},this.qualityCount=0}</span>,t.prototype.shouldSendCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.state!=l.ENUM_PUBLISH_STATE.stop&amp;&amp;this.state!=l.ENUM_PUBLISH_STATE.waitingSessionRsp}</span>,t.prototype.startPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,e,v){var T=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sp.0 called"),this.signal&amp;&amp;this.signal.negoInterval&amp;&amp;(this.negoInterval=this.signal.negoInterval),this.signal&amp;&amp;this.signal.negoTryCount&amp;&amp;(this.negoTryCount=this.signal.negoTryCount),this.signal&amp;&amp;this.signal.negoTryMaxCount&amp;&amp;(this.negoTryMaxCount=this.signal.negoTryMaxCount),t?(this.streamId=t,this.localStream=i,this.mediaStreamConfig=e,this.playOption=v||{},navigator.userAgent.toLowerCase().indexOf("firefox")&gt;-1&amp;&amp;(e.externalCapture||e.externalMediaStream)&amp;&amp;(this.localStream.onaddtrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >T.logger.info("zp.sp.0 Track added");v</span>ar t=<span class="cstat-no" title="statement not covered" >T.localStream.getVideoTracks(),</span>i=<span class="cstat-no" title="statement not covered" >T.localStream.getAudioTracks();<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;1)<span class="cstat-no" title="statement not covered" >T.peerConnection.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track.kind===t[1].kind}</span>).replaceTrack(t[1]),T.localStream.removeTrack(t[0]);e</span>lse <span class="cstat-no" title="statement not covered" >if(i.length&gt;1){<span class="cstat-no" title="statement not covered" >T.peerConnection.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track.kind===i[1].kind}</span>).replaceTrack(i[1]),T.localStream.removeTrack(i[0])}</span>}</span></span>),n&amp;&amp;(this.videoInfo=n),v&amp;&amp;v.audioBitRate&amp;&amp;(this.audioBitRate=v.audioBitRate),v&amp;&amp;v.videoDecodeType&amp;&amp;(this.videoDecodeType=v.videoDecodeType),this.sessionSeq=p.getSeq(),this.dataReport.eventStart(this.reportSeq,"CreateSession"),this.signal.createSession(this.sessionSeq,0,0,t,v&amp;&amp;v.streamParams,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >T.dataReport.eventEndWithMsg(T.reportSeq,"CreateSession",{sessionId:n.session_id}),T.logger.info("zp.sp.0 sessionId:"+n.session_id),T.sessionSeq==t?0!==n.result?(T.logger.error("zp.sp.0 create session failed "+n.result),T.publishStateUpdateError(p.publishErrorList.CREATE_SESSION_ERROR)):(T.sessionId=n.session_id,T.logger.debug("zp.sp.0 create session success "+T.sessionId),T.onCreatePublishSessionSuccess(n)):T.logger.error("zp.sp.0 seq is not match.")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >T.dataReport.eventEndWithMsg(T.reportSeq,"CreateSession",{error:t}),T.publishStateUpdateError(p.publishErrorList.SEND_SESSION_TIMEOUT)}</span>),this.state=l.ENUM_PUBLISH_STATE.waitingSessionRsp,this.logger.info("zp.sp.0 called success"),this.stateNego=l.ENUM_PUBLISH_STATE_NEGO.start,this.negoTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >T.stateNego!==l.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;T.negoTryCount&lt;T.negoTryMaxCount?(T.signal.sendCloseSession(p.getSeq(),T.sessionId,1),T.resetPublish(),T.startPublish(t,i,n,e,v),++T.negoTryCount):T.stateNego!==l.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;T.negoTryCount===T.negoTryMaxCount&amp;&amp;(T.logger.error("zp.sp.0 waiting timeout"),T.publishStateUpdateError(p.publishErrorList.SERVER_NEGO_TIMEOUT))}</span>,this.negoInterval)):this.logger.error("zp.sp.0 streamId is null")}</span>,t.prototype.onCreatePublishSessionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.0 called");v</span>ar n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.turn_server&amp;&amp;n.push(t.turn_server),t.stun_server&amp;&amp;n.push(t.stun_server);v</span>ar l=<span class="cstat-no" title="statement not covered" >{iceTransportPolicy:"relay",iceServers:[{urls:n,username:t.turn_username,credential:t.turn_auth_key}]};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.0 username: "+t.turn_username),this.logger.info("zp.ops.0 credential: "+t.turn_auth_key),this.peerConnection=new RTCPeerConnection(l),this.peerConnection.onicecandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.onIceCandidate(t)}</span>,this.peerConnection.onsignalingstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.onConnectionStateChange(t)}</span>,this.peerConnection.oniceconnectionstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.onIceConnectionStateChange(t)}</span>;v</span>ar e=<span class="cstat-no" title="statement not covered" >[],</span>v=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>this.localStream&amp;&amp;(this.localStream.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.peerConnection.addTrack(t,i.localStream)}</span>),e=this.localStream.getVideoTracks(),v=this.localStream.getAudioTracks(),console.warn("getConstraints",v&amp;&amp;v[0]&amp;&amp;v[0].getConstraints&amp;&amp;v[0].getConstraints()),e.length&gt;0&amp;&amp;this.logger.info("zp.ops.0 video device: "+e[0].label),v.length&gt;0&amp;&amp;this.logger.info("zp.ops.0 audio device: "+v[0].label));v</span>ar T=<span class="cstat-no" title="statement not covered" >{offerToReceiveAudio:v.length&gt;0?1:0,offerToReceiveVideo:e.length&gt;0?1:0};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.0 createOffer: "+JSON.stringify(T)),this.dataReport.eventStart(this.reportSeq,"CreateOffer"),this.peerConnection.createOffer(T).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEnd(i.reportSeq,"CreateOffer"),i.onCreateOfferSuccess(t)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEndWithMsg(i.reportSeq,"CreateOffer",{error:t.toString()}),i.logger.error("zp.ops.0 create offer error "+t.toString()),i.publishStateUpdateError(p.publishErrorList.CREATE_OFFER_ERROR,!0)}</span>),this.signal.registerPushCallback("CandidateInfoPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvCandidateInfo(t,n,l)}</span>),this.signal.registerPushCallback("CloseSessionPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvCloseSession(t,n,l)}</span>),this.signal.registerPushCallback("MediaDescPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvMediaDescription(t,n,l)}</span>),this.signal.registerPushCallback("SessionResetPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvResetSession(t,n,l)}</span>),this.signal.registerPushCallback("PublishEventPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvPublishEvent(t,n,l)}</span>),this.logger.debug("zp.ops.0 call success")}</span>,t.prototype.onCreateOfferSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>0!=this.videoInfo.maxBitRate&amp;&amp;(t.sdp=this.updateBandwidthRestriction(t.sdp,this.videoInfo.maxBitRate)),t.sdp=t.sdp.replace(/sendrecv/g,"sendonly"),t.sdp=t.sdp.replace(/useinbandfec=\d+/,"maxaveragebitrate="+this.audioBitRate),/m=video[\s\S]*m=audio/.test(t.sdp)&amp;&amp;(this.localSdpRevert=!0),t.sdp=T.sdpUtil.getSDPByVideDecodeType(t.sdp,this.videoDecodeType),this.logger.info("zp.oco.0 localSdp1 "+t.sdp.substr(0,t.sdp.length/2)),this.logger.info("zp.oco.0 localSdp2 "+t.sdp.substr(t.sdp.length/2)),this.dataReport.eventStart(this.reportSeq,"SetLocalDescription"),this.peerConnection.setLocalDescription(t).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEnd(i.reportSeq,"SetLocalDescription"),i.onSetLocalDescriptionSuccess(t)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEndWithMsg(i.reportSeq,"SetLocalDescription",{error:t.toString()}),i.logger.error("zp.oco.0 error "+t.toString()),i.publishStateUpdateError(p.publishErrorList.SET_LOCAL_DESC_ERROR,!0)}</span>)}</span>,t.prototype.updateBandwidthRestriction=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >"AS";<span class="cstat-no" title="statement not covered" ></span>return"firefox"===e.browserDetails.browser&amp;&amp;(i=1e3*(i&gt;&gt;&gt;0),n="TIAS"),t=-1===t.indexOf("b="+n+":")?(t=t.replace(/c=IN (.*)\r\n/g,"c=IN $1\r\nb="+n+":"+i+"\r\n")).replace("b="+n+":"+i+"\r\n",""):(t=t.replace(new RegExp("b="+n+":.*\r\n","g"),"b="+n+":"+i+"\r\n")).replace("b="+n+":"+i+"\r\n","")}</span>,t.prototype.onSetLocalDescriptionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.osd.0 success");v</span>ar n=<span class="cstat-no" title="statement not covered" >{sdp:t.sdp,width:this.videoInfo.width,height:this.videoInfo.height,frameRate:this.videoInfo.frameRate,video_min_kpbs:this.videoInfo.minBitRate,video_max_kpbs:this.videoInfo.maxBitRate,audio_kpbs:48,keyframe_intv:2};<span class="cstat-no" title="statement not covered" ></span>this.offerSeq=p.getSeq(),this.dataReport.eventStart(this.reportSeq,"SendMediaDesc"),this.signal.sendMediaDesc(this.offerSeq,this.sessionId,0,n,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,e){<span class="cstat-no" title="statement not covered" >i.offerSeq==t&amp;&amp;i.sessionId==n?(i.logger.info("zp.osd.0 send success"),i.dataReport.eventEnd(i.reportSeq,"SendMediaDesc"),i.waitingAnswerTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.state==l.ENUM_PUBLISH_STATE.waitingServerAnswer&amp;&amp;(i.logger.error("zp.osd.0 waiting timeout"),i.publishStateUpdateError(p.publishErrorList.SERVER_MEDIA_DESC_TIMEOUT))}</span>,i.waitingAnswerTimeInterval),i.logger.info("zp.osd.0 send success stateNego:waiterAnswer"),i.stateNego=l.ENUM_PUBLISH_STATE_NEGO.waiterAnswer,i.state=l.ENUM_PUBLISH_STATE.waitingServerAnswer):i.logger.error("zp.osd.0 seq or sessionId is not equal")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEndWithMsg(i.reportSeq,"SendMediaDesc",{error:t}),i.publishStateUpdateError(p.publishErrorList.SEND_MEDIA_DESC_TIMEOUT)}</span>),this.state=l.ENUM_PUBLISH_STATE.waitingOffserRsp,this.logger.debug("zp.osd.0 call success")}</span>,t.prototype.onRecvMediaDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ormd.0 received"),this.state==l.ENUM_PUBLISH_STATE.waitingServerAnswer?(this.stateNego=l.ENUM_PUBLISH_STATE_NEGO.waitingCandidate,this.logger.info("zp.orm.0 received stateNego:waitingCandidate"),null!=this.waitingAnswerTimer&amp;&amp;(clearTimeout(this.waitingAnswerTimer),this.waitingAnswerTimer=null),this.dataReport.addEvent(this.reportSeq,"RecvMediaDesc"),this.signal.sendMediaDescAck(t,this.sessionId,0),1==n.type?this.onGetRemoteOfferSucceses(n.sdp):this.publishStateUpdateError(p.publishErrorList.SERVER_MEDIA_DESC_ERROR)):this.logger.info("zp.ormd.0 current state "+this.state+" not allowed")}</span>,t.prototype.onGetRemoteOfferSucceses=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(48e3!==this.audioBitRate&amp;&amp;(t=t.replace(/maxaveragebitrate=(\d+)/,"maxaveragebitrate="+this.audioBitRate)),this.localSdpRevert){var n=<span class="cstat-no" title="statement not covered" >[/[\s\S]*m=audio/.exec(t)[0].replace("m=audio",""),/m=video[\s\S]*/.exec(t)[0],/m=audio[\s\S]*m=video/.exec(t)[0].replace("m=video","")],</span>e=<span class="cstat-no" title="statement not covered" >n[0],</span>v=<span class="cstat-no" title="statement not covered" >n[1],</span>T=<span class="cstat-no" title="statement not covered" >n[2],</span>E=<span class="cstat-no" title="statement not covered" >/a=group:BUNDLE\s+(\w+)\s+(\w+)/.exec(e);<span class="cstat-no" title="statement not covered" ></span>t=(e=e.replace(/a=group:BUNDLE\s+(\w+)\s+(\w+)/,"a=group:BUNDLE "+E[2]+" "+E[1]))+v+T}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.info("zp.oro.0 remoteSdp:",t);v</span>ar S=<span class="cstat-no" title="statement not covered" >{type:"answer",sdp:t,toJSON:<span class="fstat-no" title="function not covered" >fu</span>nction(){}};<span class="cstat-no" title="statement not covered" ></span>this.dataReport.eventStart(this.reportSeq,"SetRemoteDescription"),this.peerConnection.setRemoteDescription(new RTCSessionDescription(S)).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.oro.0 set success"),i.dataReport.eventEnd(i.reportSeq,"SetRemoteDescription")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.logger.error("zp.oro.0 failed: "+t.toString()),i.dataReport.eventEndWithMsg(i.reportSeq,"SetRemoteDescription",{error:t.toString()}),i.publishStateUpdateError(p.publishErrorList.SET_REMOTE_DESC_ERROR)}</span>),this.state=l.ENUM_PUBLISH_STATE.waitingServerICE,this.waitingICETimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.state==l.ENUM_PUBLISH_STATE.waitingServerICE&amp;&amp;(i.logger.error("zp.orod.0 waiting server timeout"),i.publishStateUpdateError(p.publishErrorList.SERVER_CANDIDATE_TIMEOUT))}</span>,this.waitingICETimeInterval),this.logger.debug("zp.oro.0 call success")}</span>,t.prototype.onIceConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.state!=l.ENUM_PUBLISH_STATE.stop&amp;&amp;null!=this.peerConnection&amp;&amp;(this.logger.info("zp.oics.0 stateChanged "+this.peerConnection.iceConnectionState),"connected"===this.peerConnection.iceConnectionState?(this.logger.info("zp.oics.0 connected state "+this.state),this.dataReport.eventEnd(this.reportSeq,"IceConnected"),this.stateNego=l.ENUM_PUBLISH_STATE_NEGO.iceConnected,this.waittingConnectedTimer&amp;&amp;clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null,this.logger.info("zp.oisc.0  stateNego:iceConnected"),this.negoTryCount=1,this.nextSignalTryCount=1,this.negoTimer&amp;&amp;(clearTimeout(this.negoTimer),this.negoTimer=null),this.publishEvent&amp;&amp;this.publishSuccess()):"closed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(this.reportSeq,"IceClosed"),this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState)):"failed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(this.reportSeq,"IceFailed"),this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState)):"disconnected"===this.peerConnection.iceConnectionState&amp;&amp;(this.dataReport.addEvent(this.reportSeq,"IceDisconnected"),this.waittingConnectedTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!i.tryingNexitSignal&amp;&amp;i.tryNextSignal(p.publishErrorList.MEDIA_CONNECTION_DISCONNECTED)}</span>,this.waittingConnectedInerval)))}</span>,t.prototype.onIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oic.0 candidate"+t.candidate),t.candidate)<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oic.0 candidate"+t.candidate.candidate),this.state&lt;l.ENUM_PUBLISH_STATE.connecting||this.state==l.ENUM_PUBLISH_STATE.stop)<span class="cstat-no" title="statement not covered" >this.candidateInfo.push({candidate:t.candidate.candidate,sdpMid:t.candidate.sdpMid,sdpMLineIndex:t.candidate.sdpMLineIndex});e</span>lse{var i=<span class="cstat-no" title="statement not covered" >{candidate:t.candidate.candidate,sdpMid:t.candidate.sdpMid,sdpMLineIndex:t.candidate.sdpMLineIndex};<span class="cstat-no" title="statement not covered" ></span>this.sendCandidateInfo([i])}</span>}</span></span>,t.prototype.sendCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sci.0 called"),!(t=t.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.candidate.indexOf("relay")&gt;0}</span>))||t.length&lt;1?this.logger.info("zp.sci.0 cancelled"):(this.dataReport.eventStart(this.reportSeq,"SendIceCandidate"),this.stateNego!==l.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;(this.stateNego=l.ENUM_PUBLISH_STATE_NEGO.sendCandidate),this.logger.info("zp.sci.0  stateNego:sendCandidate"),this.signal.sendCandidateInfo(p.getSeq(),this.sessionId,t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.sci.0 send success"),i.dataReport.eventEnd(i.reportSeq,"SendIceCandidate")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.logger.error("zp.sci.0 failed to send: "+t.toString()),i.dataReport.eventEndWithMsg(i.reportSeq,"SendIceCandidate",{error:t}),i.publishStateUpdateError(p.publishErrorList.SEND_CANDIDATE_TIMEOUT)}</span>))}</span>,t.prototype.onConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ocs.0 called "+t.target.signalingState)}</span>,t.prototype.onRecvCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.oci.0 received "+JSON.stringify(n.infos)),this.state==l.ENUM_PUBLISH_STATE.waitingServerICE){<span class="cstat-no" title="statement not covered" >null!=this.waitingICETimer&amp;&amp;(clearTimeout(this.waitingICETimer),this.waitingICETimer=null),this.dataReport.addEvent(this.reportSeq,"RecvIceCandidate"),this.signal.sendCandidateInfoAck(t,this.sessionId,0),this.sendCandidateInfo(this.candidateInfo),this.candidateInfo=[];<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;n.infos.length;v++){var T=<span class="cstat-no" title="statement not covered" >{sdpMid:n.infos[v].sdpMid,sdpMLineIndex:n.infos[v].sdpMLineIndex,candidate:n.infos[v].candidate};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zp.orci.0 candidate "+T.candidate),this.peerConnection.addIceCandidate(new RTCIceCandidate(T)).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.logger.debug("zp.oci.0 add success")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.error("zp.oci.0 add error "+t.toString()),e.publishStateUpdateError(p.publishErrorList.SERVER_CANDIDATE_ERROR)}</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.state=l.ENUM_PUBLISH_STATE.connecting,this.dataReport.eventStart(this.reportSeq,"IceConnected")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.oci.0 current state "+this.state+" not allowed")}</span></span>,t.prototype.onRecvCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.0 reason: "+n.reason),this.dataReport.addEvent(this.reportSeq,"RecvCloseSession"),this.signal.sendCloseSessionAck(t,this.sessionId,0);v</span>ar l=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(p.publishErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>l.msg+=n.reason,this.negoTimer&amp;&amp;clearTimeout(this.negoTimer);v</span>ar e=<span class="cstat-no" title="statement not covered" >1*n.reason,</span>v=<span class="cstat-no" title="statement not covered" >n.err_info&amp;&amp;JSON.parse(n.err_info).action?JSON.parse(n.err_info).action:null;<span class="cstat-no" title="statement not covered" ></span>if("number"==typeof e&amp;&amp;[26].includes(e)&amp;&amp;this.negoTryCount&lt;this.negoTryMaxCount||5==v){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.0 retry: "+this.streamId);v</span>ar T=<span class="cstat-no" title="statement not covered" >this.streamId,</span>E=<span class="cstat-no" title="statement not covered" >this.localStream,</span>S=<span class="cstat-no" title="statement not covered" >this.videoInfo,</span>R=<span class="cstat-no" title="statement not covered" >this.mediaStreamConfig,</span>r=<span class="cstat-no" title="statement not covered" >this.playOption;<span class="cstat-no" title="statement not covered" ></span>this.signal.sendCloseSession(p.getSeq(),this.sessionId,1),this.resetPublish(),this.startPublish(T,E,S,R,r),++this.negoTryCount}</span>else<span class="cstat-no" title="statement not covered" >[4,8,10,11,12,14,27].includes(e)||2==v?!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(l):this.publishStateUpdateError(l,!0)}</span></span>,t.prototype.onRecvResetSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.orrs.0 received "),i==this.sessionId){<span class="cstat-no" title="statement not covered" >this.dataReport.addEvent(this.reportSeq,"RecvResetSession"),this.signal.sendCloseSessionAck(t,this.sessionId,0);v</span>ar l=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(p.publishErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>this.negoTimer&amp;&amp;clearTimeout(this.negoTimer),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(l)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zp.orrs.0 cannot find session")}</span></span>,t.prototype.onRecvPublishEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orpe.0 received"),this.publishEvent=!0,this.stateNego===l.ENUM_PUBLISH_STATE_NEGO.iceConnected&amp;&amp;0==n.event&amp;&amp;this.publishSuccess()}</span>,t.prototype.shouldRetryPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.retryState==l.ENUM_RETRY_STATE.didNotStart&amp;&amp;this.state!=l.ENUM_PUBLISH_STATE.publishing?(this.logger.info("zp.srp.0.0 connection didn't success"),!1):this.retryState==l.ENUM_RETRY_STATE.retrying?(this.logger.info("zp.srp.0.0 already retrying"),!1):this.currentRetryCount&gt;this.maxRetryCount?(this.logger.info("zp.srp.0.0 beyond max"),!1):(this.logger.info("zp.srp.1.0 call success"),!0)}</span>,t.prototype.startRetryPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.srp.0 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >this.streamId;<span class="cstat-no" title="statement not covered" ></span>t?(this.resetPublish(),this.tryStartPublish(t)):this.logger.info("zp.srp.0 no streamid")}</span>,t.prototype.tryStartPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.tsp.0 call"),this.clearTryPublishTimer(),this.streamId=t,this.currentRetryCount&gt;this.maxRetryCount)<span class="cstat-no" title="statement not covered" >return this.logger.info("zp.tsp.0 beyond max limit"),void this.publishStateUpdateError(p.publishErrorList.WEBSOCKET_ERROR);<span class="cstat-no" title="statement not covered" >t</span></span>his.retryState=l.ENUM_RETRY_STATE.retrying,this.currentRetryCount+=1,this.signal.isServerConnected()?(this.logger.info("zp.tsp.0 signal connected"),this.startPublish(t,this.localStream,this.videoInfo,this.mediaStreamConfig,this.playOption)):(this.logger.debug("zp.tsp.0 signal server not connected"),this.waitingAnswerTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.tryStartPublish(t),console.warn(new Date)}</span>,this.waitingAnswerTimeInterval))}</span>,t.prototype.checkPublishConnectionFailedState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>"failed"==t?i=p.publishErrorList.MEDIA_CONNECTION_FAILED:"closed"==t&amp;&amp;(i=p.publishErrorList.MEDIA_CONNECTION_CLOSED),null!=i&amp;&amp;(this.state!=l.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.retryState==l.ENUM_PUBLISH_STATE.didNotStart?(this.logger.info("zp.oics.0  state "+this.state+" retryState "+this.retryState+" connectionState "+t),this.publishStateUpdateError(i)):this.shouldRetryPublish()?(this.onPublishStateUpdate(p.ENUM_PUBLISH_STATE_UPDATE.retry,this.streamId),this.startRetryPublish()):this.publishStateUpdateError(i))}</span>,t.prototype.setPublishQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>null==this.qualityTimer&amp;&amp;(this.logger.info("zp.spq.0 called"),this.clearPublishQualityTimer(),this.qualityTimer=setInterval(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.peerConnection&amp;&amp;t.peerConnection.getStats(null).then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.getPublishStats(i)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.logger.info("zp.spq.0 getStats error "+i.toString())}</span>)}</span>,this.qualityTimeInterval),this.lastPublishStats={time:0,audioBytesSent:0,videoBytesSent:0,framesEncoded:0,framesSent:0},this.qualitySeq=p.getSeq(),this.qualityCount=0,this.dataReport.newReport(this.qualitySeq))}</span>,t.prototype.getPublishStats=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(t){var n=<span class="cstat-no" title="statement not covered" >{audioCodeType:"opus",audioBitrate:0,videoBitrate:0,videoFPS:0,nackCount:0,pliCount:0,frameHeight:0,frameWidth:0,videoTransferFPS:0,totalRoundTripTime:0,currentRoundTripTime:0},</span>l=<span class="cstat-no" title="statement not covered" >this.lastPublishStats.time;<span class="cstat-no" title="statement not covered" ></span>t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >("outbound-rtp"==t.type||"ssrc"==t.type&amp;&amp;null!=t.bytesSent)&amp;&amp;"audio"==t.mediaType?(0!=l&amp;&amp;(n.audioBitrate=8*(t.bytesSent-i.lastPublishStats.audioBytesSent)/(t.timestamp-l)),n.audioBitrate&lt;0&amp;&amp;(n.audioBitrate=0),i.lastPublishStats.audioBytesSent=t.bytesSent,i.lastPublishStats.time=t.timestamp):("outbound-rtp"==t.type||"ssrc"==t.type&amp;&amp;null!=t.bytesSent)&amp;&amp;"video"==t.mediaType?(0!=l&amp;&amp;(n.videoBitrate=8*(t.bytesSent-i.lastPublishStats.videoBytesSent)/(t.timestamp-l),n.videoFPS=1e3*(t.framesEncoded-i.lastPublishStats.framesEncoded)/(t.timestamp-l)),n.videoBitrate&lt;0&amp;&amp;(n.videoBitrate=0),n.videoFPS&lt;0&amp;&amp;(n.videoFPS=0),n.nackCount=t.nackCount,n.pliCount=t.pliCount,i.lastPublishStats.videoBytesSent=t.bytesSent,i.lastPublishStats.framesEncoded=t.framesEncoded,i.lastPublishStats.time=t.timestamp):"track"==t.type&amp;&amp;("video"==t.kind||t.id.indexOf("video")&gt;=0)||t.frameWidth?(n.frameHeight=t.frameHeight,n.frameWidth=t.frameWidth,0!=l&amp;&amp;(n.videoTransferFPS=1e3*(t.framesSent-i.lastPublishStats.framesSent)/(t.timestamp-l)),n.videoTransferFPS&lt;0&amp;&amp;(n.videoTransferFPS=0),i.lastPublishStats.framesSent=t.framesSent):"candidate-pair"==t.type&amp;&amp;(null!=t.totalRoundTripTime&amp;&amp;(n.totalRoundTripTime=t.totalRoundTripTime),null!=t.currentRoundTripTime&amp;&amp;(n.currentRoundTripTime=t.currentRoundTripTime))}</span>),this.uploadPublishQuality(n),0!=l&amp;&amp;this.onPublishQualityUpdate(this.streamId,n)}</span>}</span>,t.prototype.uploadPublishQuality=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.qualityUpload){var n=<span class="cstat-no" title="statement not covered" >Date.parse(new Date+"");<span class="cstat-no" title="statement not covered" ></span>(0==this.qualityUploadLastTime||n-this.qualityUploadLastTime&gt;=this.qualityUploadInterval)&amp;&amp;(t.stream_type="publish",t.stream_id=this.streamId,t.timeStamp=n/1e3,this.logger.info("zp.upq.0 upload"+JSON.stringify(t)),this.signal.QualityReport(p.getSeq(),this.sessionId,t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >void 0!==l.report&amp;&amp;(i.qualityUpload=l.report,i.qualityUploadInterval=l.report_interval_ms)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.upq.0 upload failed "+t)}</span>),this.qualityUploadLastTime=n)}</span>}</span>,t.prototype.stopPublish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.sp.0.1 called"),Object.keys(this.streamCenter.publisherList).length=1)<span class="cstat-no" title="statement not covered" >for(var t in this.streamCenter.playerList){var i=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[t].player;<span class="cstat-no" title="statement not covered" ></span>i.state==l.ENUM_PLAY_STATE.playing&amp;&amp;i.broadcasterStatus==l.ENUM_BROADCASTER_STATUS.start&amp;&amp;(this.signal&amp;&amp;this.signal.sendBroadcasterStatus(p.getSeq(),i.sessionId,0),i.broadcasterStatus=l.ENUM_BROADCASTER_STATUS.stop)}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.sessionId&amp;&amp;!this.closeSessionSignal&amp;&amp;this.signal.sendCloseSession(p.getSeq(),this.sessionId,0),this.dataReport.eventEndWithMsg(this.reportSeq,"PublishState",{state:this.state+""}),this.dataReport.addEvent(this.reportSeq,"StopPublish"),this.dataReport.addMsgExt(this.reportSeq,{stream:this.streamId,sessionId:this.sessionId}),this.dataReport.uploadReport(this.reportSeq,"RTCPublishStream"),this.resetPublish()}</span>,t.prototype.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t.prototype.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.od.0 call"),this.logger.info("zp.od.0 websocket disconnect"),this.dataReport.addEvent(this.reportSeq,"OnDisconnect"),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(p.publishErrorList.WEBSOCKET_ERROR)}</span>,t.prototype.playEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.audioMixing.localStream=this.localStream,this.audioMixing.peerConnection=this.peerConnection,this.audioMixing.audioBuffer=i,this.audioMixing.playEffect(t.playTime,t.loop,t.replace,n,l)}</span>,t.prototype.pauseEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.audioMixing.pauseEffect()}</span>,t.prototype.resumeEffect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.audioMixing.resumeEffect()}</span>,t.prototype.stopMixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.audioMixing.stopMingBuffer()}</span>,t.prototype.mixingBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.audioMixing.localStream=this.localStream,this.audioMixing.peerConnection=this.peerConnection,this.audioMixing.mixingBuffer(t,i)}</span>,t.prototype.voiceChange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >null,</span>n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.pitchEffect||(this.pitchEffect=new E.pitchUtil(this.ac),i=this.ac.createMediaStreamSource(this.localStream),n=this.ac.createMediaStreamDestination(),i.connect(this.pitchEffect.input),this.pitchEffect.output.connect(n)),this.pitchEffect.setPitchOffset(t),!this.micTrack){var l=<span class="cstat-no" title="statement not covered" >n.stream.getAudioTracks()[0],</span>p=<span class="cstat-no" title="statement not covered" >this.peerConnection.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track.kind===l.kind}</span>);<span class="cstat-no" title="statement not covered" ></span>if(!p)<span class="cstat-no" title="statement not covered" >return this.logger.error("zp.vc.0 no sender"),!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.micTrack=this.localStream.getAudioTracks()[0],p.replaceTrack(l),this.localStream.removeTrack(this.micTrack),this.localStream.addTrack(l)}</span>}</span>,t.prototype.voiceBack=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.micTrack?(this.peerConnection.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track.kind===t.micTrack.kind}</span>).replaceTrack(this.micTrack),this.localStream.removeTrack(this.localStream.getAudioTracks()[0]),this.localStream.addTrack(this.micTrack),this.micTrack=null,this.pitchEffect=null):this.logger.error("zp.vb.0 mo mickTrack found")}</span>,t.prototype.publishSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.state!=l.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.onPublishStateUpdate(p.ENUM_PUBLISH_STATE_UPDATE.start,this.streamId),this.state=l.ENUM_PUBLISH_STATE.publishing,this.tryingNexitSignal=!1,this.retryState!=l.ENUM_RETRY_STATE.didNotStart&amp;&amp;(this.retryState=l.ENUM_RETRY_STATE.finished,this.currentRetryCount=0),this.dataReport.eventStart(this.reportSeq,"PublishState"),this.streamCenter.playerList){var i=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[t].player;<span class="cstat-no" title="statement not covered" ></span>i.state==l.ENUM_PLAY_STATE.playing&amp;&amp;i.broadcasterStatus==l.ENUM_BROADCASTER_STATUS.stop&amp;&amp;(this.signal&amp;&amp;this.signal.sendBroadcasterStatus(p.getSeq(),i.sessionId,1),i.broadcasterStatus=l.ENUM_BROADCASTER_STATUS.start)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.setPublishQualityTimer();v</span>ar n=<span class="cstat-no" title="statement not covered" >2,</span>e=<span class="cstat-no" title="statement not covered" >2;<span class="cstat-no" title="statement not covered" ></span>0!==this.localStream.getVideoTracks().length&amp;&amp;1==this.localStream.getVideoTracks()[0].enabled&amp;&amp;(n=0),0!==this.localStream.getAudioTracks().length&amp;&amp;1==this.localStream.getAudioTracks()[0].enabled&amp;&amp;(e=0),this.signal.sendStreamStatus(p.getSeq(),this.sessionId,n,e),this.streamCenter.soundLevelDelegate&amp;&amp;this.startSoundLevel()}</span>,t.prototype.tryNextSignal=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.tryingNexitSignal=!0;v</span>ar i=<span class="cstat-no" title="statement not covered" >this.streamId,</span>n=<span class="cstat-no" title="statement not covered" >this.signal.server,</span>e=<span class="cstat-no" title="statement not covered" >this.streamCenter.publisherList[i],</span>v=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.serverUrls&amp;&amp;(v=e.serverUrls),this.nextSignalTryCount&gt;3*v.length?(this.logger.error("zp.tns.0 try max limit"),this.publishStateUpdateError(t)):(v.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return i&lt;=v.indexOf(n)&amp;&amp;v.push(t)}</span>),v.splice(0,v.indexOf(n)+1),this.logger.info("zp.tns.0 try next signal "+i),this.signal&amp;&amp;this.signal.state==l.ENUM_CONNECT_STATE.connected&amp;&amp;this.signal.sendCloseSession(p.getSeq(),this.sessionId,1),this.signal&amp;&amp;this.signal.removeSession(this.sessionId),this.resetPublish(),this.streamCenter.connectPublishServer(i),this.nextSignalTryCount++)}</span>,t.prototype.startSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.ssl.0 call streamID: "+this.streamId),this.localStream&amp;&amp;0!=this.localStream.getAudioTracks().length){<span class="cstat-no" title="statement not covered" >this.script&amp;&amp;this.script.disconnect()&amp;&amp;(this.script=null),this.mic&amp;&amp;this.mic.disconnect()&amp;&amp;(this.mic=null);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.mic=this.ac.createMediaStreamSource(this.localStream),this.script=this.ac.createScriptProcessor(4096,1,1),this.mic.connect(this.script),this.script.connect(this.ac.destination),this.script.onaudioprocess=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >for(var n=i.inputBuffer.getChannelData(0),l=0,p=0;p&lt;n.length;p++)<span class="cstat-no" title="statement not covered" >l&lt;n[p]&amp;&amp;(l=n[p]);<span class="cstat-no" title="statement not covered" >t</span></span>.soundLevel=100*l}</span>,this.ac.resume()}</span>catch(t){<span class="cstat-no" title="statement not covered" >this.logger.error("zp.ssl.0 get sound level failed "+t)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.0 local stream no found")}</span></span>,t.prototype.stopSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.0.1 call streamID: "+this.streamId),this.script&amp;&amp;this.script.disconnect(),this.mic&amp;&amp;this.mic.disconnect(),this.script=null,this.mic=null}</span>,t.prototype.startMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this.logger.info("zp.sma.0 call"),t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(i.audioMixList.find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.media==t}</span>))<span class="cstat-no" title="statement not covered" >i.logger.info("zp.sma.0 mix audio already exist");e</span>lse{var n=<span class="cstat-no" title="statement not covered" >new v.audioMixUtil(i.logger,i.ac);<span class="cstat-no" title="statement not covered" ></span>n.localStream=i.localStream,n.peerConnection=i.peerConnection,i.audioMixList.push({audioMix:n,media:t}),n.startMixingAudio(t)}</span>}</span>),!0}</span>,t.prototype.stopMixingAudio=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this.logger.info("zp.sma.0.0 call"),t?t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;i.audioMixList.length;n++)<span class="cstat-no" title="statement not covered" >if(i.audioMixList[n].media==t){<span class="cstat-no" title="statement not covered" >i.audioMixList[n].audioMix.stopMixingAudio()&amp;&amp;i.audioMixList.splice(n--,1);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>):(this.audioMixList.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.audioMix.stopMixingAudio()}</span>),this.audioMixList=[],this.audioMixing.isMixAudio&amp;&amp;this.audioMixing.stopMixingAudio()),!0}</span>,t}();i.ZegoPublish=S},function(t,i,n){var l;t.exports=function t(i,n,p){function e(T,E){if(!n[T]){<span class="missing-if-branch" title="if path not taken" >I</span>if(!i[T]){var S=<span class="cstat-no" title="statement not covered" >"function"==typeof l&amp;&amp;l;<span class="cstat-no" title="statement not covered" ></span>if(!E&amp;&amp;S)<span class="cstat-no" title="statement not covered" >return l(T,!0);<span class="cstat-no" title="statement not covered" >i</span></span>f(v)<span class="cstat-no" title="statement not covered" >return v(T,!0);v</span></span>ar R=<span class="cstat-no" title="statement not covered" >new Error("Cannot find module '"+T+"'");<span class="cstat-no" title="statement not covered" ></span>throw R.code="MODULE_NOT_FOUND",R}</span>var r=n[T]={exports:{}};i[T][0].call(r.exports,function(t){var n=i[T][1][t];return e(n||<span class="branch-1 cbranch-no" title="branch not covered" >t)</span>},r,r.exports,t,i,n,p)}return n[T].exports}for(var v="function"==typeof l&amp;&amp;l,T=0;T&lt;p.length;T++)e(p[T]);return e}({1:[function(t,i,n){"use strict";var l=t("./adapter_factory.js"),p=(0,l.adapterFactory)({window:window});i.exports=p},{"./adapter_factory.js":2}],2:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.adapterFactory=function(){var t=(arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:<span class="branch-1 cbranch-no" title="branch not covered" >{})</span>.window,i=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>{shimChrome:!0,shimFirefox:!0,shimEdge:!0,shimSafari:!0},n=p.log,l=p.detectBrowser(t),e={browserDetails:l,commonShim:L,extractVersion:p.extractVersion,disableLog:p.disableLog,disableWarnings:p.disableWarnings};switch(l.browser){case"chrome":<span class="missing-if-branch" title="if path not taken" >I</span>if(!v||!v.shimPeerConnection||!i.shimChrome)<span class="cstat-no" title="statement not covered" >return n("Chrome shim is not included in this adapter release."),e;n</span>("adapter.js shimming chrome."),e.browserShim=v,v.shimGetUserMedia(t),v.shimMediaStream(t),v.shimPeerConnection(t),v.shimOnTrack(t),v.shimAddTrackRemoveTrack(t),v.shimGetSendersWithDtmf(t),v.shimGetStats(t),v.shimSenderReceiverGetStats(t),v.fixNegotiationNeeded(t),L.shimRTCIceCandidate(t),L.shimConnectionState(t),L.shimMaxMessageSize(t),L.shimSendThrowTypeError(t),L.removeAllowExtmapMixed(t);break;<span class="branch-1 cbranch-no" title="branch not covered" >case"firefox":<span class="cstat-no" title="statement not covered" >if(!R||!R.shimPeerConnection||!i.shimFirefox)<span class="cstat-no" title="statement not covered" >return n("Firefox shim is not included in this adapter release."),e;<span class="cstat-no" title="statement not covered" >n</span></span>("adapter.js shimming firefox."),e.browserShim=R,R.shimGetUserMedia(t),R.shimPeerConnection(t),R.shimOnTrack(t),R.shimRemoveStream(t),R.shimSenderGetStats(t),R.shimReceiverGetStats(t),R.shimRTCDataChannel(t),L.shimRTCIceCandidate(t),L.shimConnectionState(t),L.shimMaxMessageSize(t),L.shimSendThrowTypeError(t);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-2 cbranch-no" title="branch not covered" >c</span></span>ase"edge":<span class="cstat-no" title="statement not covered" >if(!E||!E.shimPeerConnection||!i.shimEdge)<span class="cstat-no" title="statement not covered" >return n("MS edge shim is not included in this adapter release."),e;<span class="cstat-no" title="statement not covered" >n</span></span>("adapter.js shimming edge."),e.browserShim=E,E.shimGetUserMedia(t),E.shimGetDisplayMedia(t),E.shimPeerConnection(t),E.shimReplaceTrack(t),L.shimMaxMessageSize(t),L.shimSendThrowTypeError(t);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-3 cbranch-no" title="branch not covered" >c</span></span>ase"safari":<span class="cstat-no" title="statement not covered" >if(!h||!i.shimSafari)<span class="cstat-no" title="statement not covered" >return n("Safari shim is not included in this adapter release."),e;<span class="cstat-no" title="statement not covered" >n</span></span>("adapter.js shimming safari."),e.browserShim=h,h.shimRTCIceServerUrls(t),h.shimCreateOfferLegacy(t),h.shimCallbacksAPI(t),h.shimLocalStreamsAPI(t),h.shimRemoteStreamsAPI(t),h.shimTrackEventTransceiver(t),h.shimGetUserMedia(t),L.shimRTCIceCandidate(t),L.shimMaxMessageSize(t),L.shimSendThrowTypeError(t),L.removeAllowExtmapMixed(t);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-4 cbranch-no" title="branch not covered" >d</span></span>efault:<span class="cstat-no" title="statement not covered" >n("Unsupported browser!")}</span></span>return e};var l=t("./utils"),p=M(l),e=t("./chrome/chrome_shim"),v=M(e),T=t("./edge/edge_shim"),E=M(T),S=t("./firefox/firefox_shim"),R=M(S),r=t("./safari/safari_shim"),h=M(r),u=t("./common_shim"),L=M(u);function M(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>},{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.shimGetDisplayMedia=n.shimGetUserMedia=void 0;var l="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(t){return typeof t}:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>,</span>p=t("./getusermedia");Object.defineProperty(n,"shimGetUserMedia",{enumerable:!0,get:function(){return p.shimGetUserMedia}});var e=t("./getdisplaymedia");Object.defineProperty(n,"shimGetDisplayMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.shimGetDisplayMedia}</span>}),n.shimMediaStream=function(t){t.MediaStream=t.MediaStream||<span class="branch-1 cbranch-no" title="branch not covered" >t.webkitMediaStream}</span>,n.shimOnTrack=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"!==(void 0===t?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>l(t))||!t.RTCPeerConnection||"ontrack"in t.RTCPeerConnection.prototype)T.wrapPeerConnectionEvent(t,"track",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.transceiver||Object.defineProperty(t,"transceiver",{value:{receiver:t.receiver}}),t}</span>);else{<span class="cstat-no" title="statement not covered" >Object.defineProperty(t.RTCPeerConnection.prototype,"ontrack",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._ontrack}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._ontrack&amp;&amp;this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=t)}</span>,enumerable:!0,configurable:!0});v</span>ar i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._ontrackpoly||(this._ontrackpoly=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >i.stream.addEventListener("addtrack",<span class="fstat-no" title="function not covered" >fu</span>nction(l){var p=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>p=t.RTCPeerConnection.prototype.getReceivers?n.getReceivers().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track&amp;&amp;t.track.id===l.track.id}</span>):{track:l.track};v</span>ar e=<span class="cstat-no" title="statement not covered" >new Event("track");<span class="cstat-no" title="statement not covered" ></span>e.track=l.track,e.receiver=p,e.transceiver={receiver:p},e.streams=[i.stream],n.dispatchEvent(e)}</span>),i.stream.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(l){var p=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>p=t.RTCPeerConnection.prototype.getReceivers?n.getReceivers().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track&amp;&amp;t.track.id===l.id}</span>):{track:l};v</span>ar e=<span class="cstat-no" title="statement not covered" >new Event("track");<span class="cstat-no" title="statement not covered" ></span>e.track=l,e.receiver=p,e.transceiver={receiver:p},e.streams=[i.stream],n.dispatchEvent(e)}</span>)}</span>,this.addEventListener("addstream",this._ontrackpoly)),i.apply(this,arguments)}</span>}</span>},n.shimGetSendersWithDtmf=function(t){<span class="missing-if-branch" title="if path not taken" >I</span>if("object"===(void 0===t?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>l(t))&amp;&amp;t.RTCPeerConnection&amp;&amp;!("getSenders"in t.RTCPeerConnection.prototype)&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >"createDTMFSender"in t.RTCPeerConnection.prototype)</span>{var i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return{track:i,get dtmf(){<span class="cstat-no" title="statement not covered" >return void 0===this._dtmf&amp;&amp;("audio"===i.kind?this._dtmf=t.createDTMFSender(i):this._dtmf=null),this._dtmf}</span>,_pc:t}}</span>;<span class="cstat-no" title="statement not covered" ></span>if(!t.RTCPeerConnection.prototype.getSenders){<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._senders=this._senders||[],this._senders.slice()}</span>;v</span>ar n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t,l){var p=<span class="cstat-no" title="statement not covered" >n.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return p||(p=i(this,t),this._senders.push(p)),p}</span>;v</span>ar p=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.removeTrack;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.apply(this,arguments);v</span>ar i=<span class="cstat-no" title="statement not covered" >this._senders.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>-1!==i&amp;&amp;this._senders.splice(i,1)}</span>}</span>v</span>ar e=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.addStream;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._senders=this._senders||[],e.apply(this,[t]),t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n._senders.push(i(n,t))}</span>)}</span>;v</span>ar v=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.removeStream;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._senders=this._senders||[],v.apply(this,[t]),t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >i._senders.find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track===t}</span>);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;i._senders.splice(i._senders.indexOf(n),1)}</span>)}</span>}</span>else <span class="missing-if-branch" title="if path not taken" >I</span>if("object"===(void 0===t?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>l(t))&amp;&amp;t.RTCPeerConnection&amp;&amp;"getSenders"in t.RTCPeerConnection.prototype&amp;&amp;"createDTMFSender"in t.RTCPeerConnection.prototype&amp;&amp;t.RTCRtpSender&amp;&amp;!("dtmf"in t.RTCRtpSender.prototype)){var T=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getSenders;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >T.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return i.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i._pc=t}</span>),i}</span>,Object.defineProperty(t.RTCRtpSender.prototype,"dtmf",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return void 0===this._dtmf&amp;&amp;("audio"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}</span>})}</span>},n.shimGetStats=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t.RTCPeerConnection){var i=t.RTCPeerConnection.prototype.getStats;t.RTCPeerConnection.prototype.getStats=function(t,n,l){var p=this,e=arguments;<span class="missing-if-branch" title="if path not taken" >I</span>if(arguments.length&gt;0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >"function"==typeof t)<span class="cstat-no" title="statement not covered" ></span>return i.apply(this,arguments);<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(0===i.length&amp;&amp;(0===arguments.length||<span class="branch-2 cbranch-no" title="branch not covered" >"function"!=typeof arguments[0])</span>)return i.apply(this,[]);var v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >t.result();<span class="cstat-no" title="statement not covered" ></span>return n.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >{id:t.id,timestamp:t.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[t.type]||t.type};<span class="cstat-no" title="statement not covered" ></span>t.names().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >n[i]=t.stat(i)}</span>),i[n.id]=n}</span>),i}</span>,</span>T=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Map(Object.keys(t).map(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return[i,t[i]]}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>return arguments.length&gt;=2?i.apply(this,[<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e[1](T(v(t)))}</span>,arguments[0]]):new Promise(<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.apply(p,[<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t(T(v(i)))}</span>,n])}</span>).then(n,l)}</span>}},n.shimSenderReceiverGetStats=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"===(void 0===t?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>l(t))&amp;&amp;t.RTCPeerConnection&amp;&amp;t.RTCRtpSender&amp;&amp;t.RTCRtpReceiver){<span class="missing-if-branch" title="if path not taken" >I</span>if(!("getStats"in t.RTCRtpSender.prototype)){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getSenders;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(t.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >i.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return n.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i._pc=t}</span>),n}</span>);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(t.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >n.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return t._pc=this,t}</span>),t.RTCRtpSender.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._pc.getStats().then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return T.filterStats(i,t.track,!0)}</span>)}</span>}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(!("getStats"in t.RTCRtpReceiver.prototype)){var p=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getReceivers;<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(t.RTCPeerConnection.prototype.getReceivers=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >p.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return i.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i._pc=t}</span>),i}</span>),T.wrapPeerConnectionEvent(t,"track",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.receiver._pc=t.srcElement,t}</span>),t.RTCRtpReceiver.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._pc.getStats().then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return T.filterStats(i,t.track,!1)}</span>)}</span>}<span class="missing-if-branch" title="else path not taken" >E</span></span>if("getStats"in t.RTCRtpSender.prototype&amp;&amp;"getStats"in t.RTCRtpReceiver.prototype){var e=t.RTCPeerConnection.prototype.getStats;t.RTCPeerConnection.prototype.getStats=function(){<span class="missing-if-branch" title="if path not taken" >I</span>if(arguments.length&gt;0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >arguments[0]instanceof t.MediaStreamTrack)</span>{var i=<span class="cstat-no" title="statement not covered" >arguments[0],</span>n=<span class="cstat-no" title="statement not covered" >void 0,</span>l=<span class="cstat-no" title="statement not covered" >void 0,</span>p=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>return this.getSenders().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.track===i&amp;&amp;(n?p=!0:n=t)}</span>),this.getReceivers().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===i&amp;&amp;(l?p=!0:l=t),t.track===i}</span>),p||n&amp;&amp;l?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):n?n.getStats():l?l.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}</span>return e.apply(this,arguments)}}}},n.shimAddTrackRemoveTrackWithNative=E,n.shimAddTrackRemoveTrack=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t.RTCPeerConnection){var i=T.detectBrowser(t);<span class="missing-if-branch" title="else path not taken" >E</span>if(t.RTCPeerConnection.prototype.addTrack&amp;&amp;i.version&gt;=65)return E(t);var n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getLocalStreams;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.apply(this);<span class="cstat-no" title="statement not covered" ></span>return this._reverseStreams=this._reverseStreams||{},i.map(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return t._reverseStreams[i.id]}</span>)}</span>;v</span>ar l=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.addStream;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},i.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >n.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track===t}</span>);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >throw new DOMException("Track already exists.","InvalidAccessError")}</span></span>),!this._reverseStreams[i.id]){var p=<span class="cstat-no" title="statement not covered" >new t.MediaStream(i.getTracks());<span class="cstat-no" title="statement not covered" ></span>this._streams[i.id]=p,this._reverseStreams[p.id]=i,i=p}<span class="cstat-no" title="statement not covered" ></span>l</span>.apply(this,[i])}</span>;v</span>ar p=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.removeStream;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},p.apply(this,[this._streams[t.id]||t]),delete this._reverseStreams[this._streams[t.id]?this._streams[t.id].id:t.id],delete this._streams[t.id]}</span>,t.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){var l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if("closed"===this.signalingState)<span class="cstat-no" title="statement not covered" >throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");v</span></span>ar p=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments,1);<span class="cstat-no" title="statement not covered" ></span>if(1!==p.length||!p[0].getTracks().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t===i}</span>))<span class="cstat-no" title="statement not covered" >throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===i}</span>);<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >throw new DOMException("Track already exists.","InvalidAccessError");<span class="cstat-no" title="statement not covered" >t</span></span>his._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};v</span>ar v=<span class="cstat-no" title="statement not covered" >this._streams[n.id];<span class="cstat-no" title="statement not covered" ></span>if(v)<span class="cstat-no" title="statement not covered" >v.addTrack(i),Promise.resolve().then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l.dispatchEvent(new Event("negotiationneeded"))}</span>);e</span>lse{var T=<span class="cstat-no" title="statement not covered" >new t.MediaStream([i]);<span class="cstat-no" title="statement not covered" ></span>this._streams[n.id]=T,this._reverseStreams[T.id]=n,this.addStream(T)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===i}</span>)}</span>,["createOffer","createAnswer"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype[i];<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype[i]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >arguments,</span>l=<span class="cstat-no" title="statement not covered" >arguments.length&amp;&amp;"function"==typeof arguments[0];<span class="cstat-no" title="statement not covered" ></span>return l?n.apply(this,[<span class="fstat-no" title="function not covered" >fu</span>nction(n){var l=<span class="cstat-no" title="statement not covered" >S(t,n);<span class="cstat-no" title="statement not covered" ></span>i[0].apply(null,[l])}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i[1]&amp;&amp;i[1].apply(null,t)}</span>,arguments[2]]):n.apply(this,arguments).then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return S(t,i)}</span>)}</span>}</span>);v</span>ar e=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.setLocalDescription;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.setLocalDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments.length&amp;&amp;arguments[0].type?(arguments[0]=(t=this,i=arguments[0],n=i.sdp,Object.keys(t._reverseStreams||[]).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var l=<span class="cstat-no" title="statement not covered" >t._reverseStreams[i],</span>p=<span class="cstat-no" title="statement not covered" >t._streams[l.id];<span class="cstat-no" title="statement not covered" ></span>n=n.replace(new RegExp(l.id,"g"),p.id)}</span>),new RTCSessionDescription({type:i.type,sdp:n})),e.apply(this,arguments)):e.apply(this,arguments);v</span>ar t,i,n};v</span>ar v=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(t.RTCPeerConnection.prototype,"localDescription");<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t.RTCPeerConnection.prototype,"localDescription",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >v.get.apply(this);<span class="cstat-no" title="statement not covered" ></span>return""===t.type?t:S(this,t)}</span>}),t.RTCPeerConnection.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if("closed"===this.signalingState)<span class="cstat-no" title="statement not covered" >throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");<span class="cstat-no" title="statement not covered" >i</span></span>f(!t._pc)<span class="cstat-no" title="statement not covered" >throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t._pc===this;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new DOMException("Sender was not created by this connection.","InvalidAccessError");<span class="cstat-no" title="statement not covered" >t</span></span>his._streams=this._streams||{};v</span>ar l=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>Object.keys(this._streams).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){var p=<span class="cstat-no" title="statement not covered" >i._streams[n].getTracks().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return t.track===i}</span>);<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(l=i._streams[n])}</span>),l&amp;&amp;(1===l.getTracks().length?this.removeStream(this._reverseStreams[l.id]):l.removeTrack(t.track),this.dispatchEvent(new Event("negotiationneeded")))}</span>}</span>function <span class="fstat-no" title="function not covered" >S(</span>t,i){var n=<span class="cstat-no" title="statement not covered" >i.sdp;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t._reverseStreams||[]).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var l=<span class="cstat-no" title="statement not covered" >t._reverseStreams[i],</span>p=<span class="cstat-no" title="statement not covered" >t._streams[l.id];<span class="cstat-no" title="statement not covered" ></span>n=n.replace(new RegExp(p.id,"g"),l.id)}</span>),new RTCSessionDescription({type:i.type,sdp:n})}</span>},n.shimPeerConnection=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(!t.RTCPeerConnection&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t.webkitRTCPeerConnection&amp;</span>&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >t.RTCPeerConnection=t.webkitRTCPeerConnection)</span>,t.RTCPeerConnection){["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(i){var n=t.RTCPeerConnection.prototype[i];t.RTCPeerConnection.prototype[i]=function(){return arguments[0]=new("addIceCandidate"===i?t.RTCIceCandidate:t.RTCSessionDescription)(arguments[0]),n.apply(this,arguments)}});var i=t.RTCPeerConnection.prototype.addIceCandidate;t.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?i.apply(this,arguments):(<span class="branch-1 cbranch-no" title="branch not covered" >arguments[1]&amp;&amp;arguments[1].apply(null),Promise.resolve())</span>}}},n.fixNegotiationNeeded=function(t){T.wrapPeerConnectionEvent(t,"negotiationneeded",<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.target;<span class="cstat-no" title="statement not covered" ></span>if("stable"===i.signalingState)<span class="cstat-no" title="statement not covered" >return t}</span></span>)};var v=t("../utils.js"),T=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(v);function E(t){t.RTCPeerConnection.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return t._shimmedLocalStreams[i][0]}</span>)}</span>;var i=t.RTCPeerConnection.prototype.addTrack;t.RTCPeerConnection.prototype.addTrack=function(t,n){<span class="missing-if-branch" title="if path not taken" >I</span>if(!n)<span class="cstat-no" title="statement not covered" >return i.apply(this,arguments);t</span>his._shimmedLocalStreams=this._shimmedLocalStreams||<span class="branch-1 cbranch-no" title="branch not covered" >{};</span>var l=i.apply(this,arguments);return this._shimmedLocalStreams[n.id]?-1===this._shimmedLocalStreams[n.id].indexOf(l)&amp;&amp;this._shimmedLocalStreams[n.id].push(l):this._shimmedLocalStreams[n.id]=[n,l],l};var n=t.RTCPeerConnection.prototype.addStream;t.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._shimmedLocalStreams=this._shimmedLocalStreams||{},t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >i.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track===t}</span>);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >throw new DOMException("Track already exists.","InvalidAccessError")}</span></span>);v</span>ar l=<span class="cstat-no" title="statement not covered" >this.getSenders();<span class="cstat-no" title="statement not covered" ></span>n.apply(this,arguments);v</span>ar p=<span class="cstat-no" title="statement not covered" >this.getSenders().filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return-1===l.indexOf(t)}</span>);<span class="cstat-no" title="statement not covered" ></span>this._shimmedLocalStreams[t.id]=[t].concat(p)}</span>;var l=t.RTCPeerConnection.prototype.removeStream;t.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[t.id],l.apply(this,arguments)}</span>;var p=t.RTCPeerConnection.prototype.removeTrack;t.RTCPeerConnection.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._shimmedLocalStreams=this._shimmedLocalStreams||{},t&amp;&amp;Object.keys(this._shimmedLocalStreams).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){var l=<span class="cstat-no" title="statement not covered" >i._shimmedLocalStreams[n].indexOf(t);<span class="cstat-no" title="statement not covered" ></span>-1!==l&amp;&amp;i._shimmedLocalStreams[n].splice(l,1),1===i._shimmedLocalStreams[n].length&amp;&amp;delete i._shimmedLocalStreams[n]}</span>),p.apply(this,arguments)}</span>}},{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.shimGetDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.navigator.mediaDevices&amp;&amp;"getDisplayMedia"in t.navigator.mediaDevices||t.navigator.mediaDevices&amp;&amp;("function"==typeof i?t.navigator.mediaDevices.getDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return i(n).then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var l=<span class="cstat-no" title="statement not covered" >n.video&amp;&amp;n.video.width,</span>p=<span class="cstat-no" title="statement not covered" >n.video&amp;&amp;n.video.height,</span>e=<span class="cstat-no" title="statement not covered" >n.video&amp;&amp;n.video.frameRate;<span class="cstat-no" title="statement not covered" ></span>return n.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:i,maxFrameRate:e||3}},l&amp;&amp;(n.video.mandatory.maxWidth=l),p&amp;&amp;(n.video.mandatory.maxHeight=p),t.navigator.mediaDevices.getUserMedia(n)}</span>)}</span>:console.error("shimGetDisplayMedia: getSourceId argument is not a function"))}</span>},{}],5:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return typeof t}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>;</span>n.shimGetUserMedia=function(t){var i=t&amp;&amp;t.navigator;<span class="missing-if-branch" title="else path not taken" >E</span>if(i.mediaDevices){var n=e.detectBrowser(t),p=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("object"!==(void 0===t?"undefined":l(t))||t.mandatory||t.optional)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >if("require"!==n&amp;&amp;"advanced"!==n&amp;&amp;"mediaSource"!==n){var p=<span class="cstat-no" title="statement not covered" >"object"===l(t[n])?t[n]:{ideal:t[n]};<span class="cstat-no" title="statement not covered" ></span>void 0!==p.exact&amp;&amp;"number"==typeof p.exact&amp;&amp;(p.min=p.max=p.exact);v</span>ar e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t?t+i.charAt(0).toUpperCase()+i.slice(1):"deviceId"===i?"sourceId":i}</span>;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==p.ideal){<span class="cstat-no" title="statement not covered" >i.optional=i.optional||[];v</span>ar v=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>"number"==typeof p.ideal?(v[e("min",n)]=p.ideal,i.optional.push(v),(v={})[e("max",n)]=p.ideal,i.optional.push(v)):(v[e("",n)]=p.ideal,i.optional.push(v))}<span class="cstat-no" title="statement not covered" ></span>v</span>oid 0!==p.exact&amp;&amp;"number"!=typeof p.exact?(i.mandatory=i.mandatory||{},i.mandatory[e("",n)]=p.exact):["min","max"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >void 0!==p[t]&amp;&amp;(i.mandatory=i.mandatory||{},i.mandatory[e(t,n)]=p[t])}</span>)}</span>}</span>),t.advanced&amp;&amp;(i.optional=(i.optional||[]).concat(t.advanced)),i}</span>,T=function(t,e){<span class="missing-if-branch" title="else path not taken" >E</span>if(n.version&gt;=61)return e(t);<span class="cstat-no" title="statement not covered" >if((t=JSON.parse(JSON.stringify(t)))&amp;&amp;"object"===l(t.audio)){var T=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >i in t&amp;&amp;!(n in t)&amp;&amp;(t[n]=t[i],delete t[i])}</span>;<span class="cstat-no" title="statement not covered" ></span>t=JSON.parse(JSON.stringify(t)),T(t.audio,"autoGainControl","googAutoGainControl"),T(t.audio,"noiseSuppression","googNoiseSuppression"),t.audio=p(t.audio)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t&amp;&amp;"object"===l(t.video)){var E=<span class="cstat-no" title="statement not covered" >t.video.facingMode;<span class="cstat-no" title="statement not covered" ></span>E=E&amp;&amp;("object"===(void 0===E?"undefined":l(E))?E:{ideal:E});v</span>ar S=<span class="cstat-no" title="statement not covered" >n.version&lt;66;<span class="cstat-no" title="statement not covered" ></span>if(E&amp;&amp;("user"===E.exact||"environment"===E.exact||"user"===E.ideal||"environment"===E.ideal)&amp;&amp;(!i.mediaDevices.getSupportedConstraints||!i.mediaDevices.getSupportedConstraints().facingMode||S)){<span class="cstat-no" title="statement not covered" >delete t.video.facingMode;v</span>ar R=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if("environment"===E.exact||"environment"===E.ideal?R=["back","rear"]:"user"!==E.exact&amp;&amp;"user"!==E.ideal||(R=["front"]),R)<span class="cstat-no" title="statement not covered" >return i.mediaDevices.enumerateDevices().then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >(i=i.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"videoinput"===t.kind}</span>)).find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return R.some(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return t.label.toLowerCase().includes(i)}</span>)}</span>);<span class="cstat-no" title="statement not covered" ></span>return!n&amp;&amp;i.length&amp;&amp;R.includes("back")&amp;&amp;(n=i[i.length-1]),n&amp;&amp;(t.video.deviceId=E.exact?{exact:n.deviceId}:{ideal:n.deviceId}),t.video=p(t.video),v("chrome: "+JSON.stringify(t)),e(t)}</span>)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>.video=p(t.video)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn v("chrome: "+JSON.stringify(t)),e(t)}</span>,E=function(t){return n.version&gt;=64?t:<span class="branch-1 cbranch-no" title="branch not covered" >{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[t.name]||t.name,message:t.message,constraint:t.constraint||t.constraintName,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.name+(this.message&amp;&amp;": ")+this.message}</span>}}</span>;<span class="missing-if-branch" title="else path not taken" >E</span>if(i.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >T(t,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.webkitGetUserMedia(t,n,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l&amp;&amp;l(E(t))}</span>)}</span>)}</span>.bind(i),i.mediaDevices.getUserMedia){var S=i.mediaDevices.getUserMedia.bind(i.mediaDevices);i.mediaDevices.getUserMedia=function(t){return T(t,function(t){return S(t).then(function(i){<span class="missing-if-branch" title="if path not taken" >I</span>if(t.audio&amp;&amp;!i.getAudioTracks().length||t.video&amp;&amp;!i.getVideoTracks().length)<span class="cstat-no" title="statement not covered" >throw i.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.stop()}</span>),new DOMException("","NotFoundError");r</span>eturn i},function(t){return Promise.reject(E(t))})})}}}};var p=t("../utils.js"),e=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(p),v=e.log},{"../utils.js":15}],6:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return typeof t}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>;</span>n.shimRTCIceCandidate=function(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(t.RTCIceCandidate&amp;&amp;!(t.RTCIceCandidate&amp;&amp;"foundation"in t.RTCIceCandidate.prototype)){var i=<span class="cstat-no" title="statement not covered" >t.RTCIceCandidate;<span class="cstat-no" title="statement not covered" ></span>t.RTCIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===t?"undefined":l(t))&amp;&amp;t.candidate&amp;&amp;0===t.candidate.indexOf("a=")&amp;&amp;((t=JSON.parse(JSON.stringify(t))).candidate=t.candidate.substr(2)),t.candidate&amp;&amp;t.candidate.length){var n=<span class="cstat-no" title="statement not covered" >new i(t),</span>p=<span class="cstat-no" title="statement not covered" >v.default.parseCandidate(t.candidate),</span>e=<span class="cstat-no" title="statement not covered" >Object.assign(n,p);<span class="cstat-no" title="statement not covered" ></span>return e.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{candidate:e.candidate,sdpMid:e.sdpMid,sdpMLineIndex:e.sdpMLineIndex,usernameFragment:e.usernameFragment}}</span>,e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new i(t)}</span>,t.RTCIceCandidate.prototype=i.prototype,E.wrapPeerConnectionEvent(t,"icecandidate",<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.candidate&amp;&amp;Object.defineProperty(i,"candidate",{value:new t.RTCIceCandidate(i.candidate),writable:"false"}),i}</span>)}</span>},n.shimMaxMessageSize=function(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(!t.RTCSctpTransport&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t.RTCPeerConnection)</span>{var i=<span class="cstat-no" title="statement not covered" >E.detectBrowser(t);<span class="cstat-no" title="statement not covered" ></span>"sctp"in t.RTCPeerConnection.prototype||Object.defineProperty(t.RTCPeerConnection.prototype,"sctp",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return void 0===this._sctp?null:this._sctp}</span>});v</span>ar n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this._sctp=null,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t||!t.sdp)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >v.default.splitSections(t.sdp);<span class="cstat-no" title="statement not covered" ></span>return i.shift(),i.some(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >v.default.parseMLine(t);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;"application"===i.kind&amp;&amp;-1!==i.protocol.indexOf("SCTP")}</span>)}</span>(arguments[0])){var t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);<span class="cstat-no" title="statement not covered" ></span>if(null===i||i.length&lt;2)<span class="cstat-no" title="statement not covered" >return-1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >parseInt(i[1],10);<span class="cstat-no" title="statement not covered" ></span>return n!=n?-1:n}</span>(arguments[0]),</span>l=(<span class="cstat-no" title="statement not covered" >E=t,S=65536,"firefox"===i.browser&amp;&amp;(S=i.version&lt;57?-1===E?16384:2147483637:i.version&lt;60?57===i.version?65535:65536:2147483637),S)</span>,p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,n){var l=<span class="cstat-no" title="statement not covered" >65536;<span class="cstat-no" title="statement not covered" ></span>"firefox"===i.browser&amp;&amp;57===i.version&amp;&amp;(l=65535);v</span>ar p=<span class="cstat-no" title="statement not covered" >v.default.matchPrefix(t.sdp,"a=max-message-size:");<span class="cstat-no" title="statement not covered" ></span>return p.length&gt;0?l=parseInt(p[0].substr(19),10):"firefox"===i.browser&amp;&amp;-1!==n&amp;&amp;(l=2147483637),l}</span>(arguments[0],t),</span>e=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>e=0===l&amp;&amp;0===p?Number.POSITIVE_INFINITY:0===l||0===p?Math.max(l,p):Math.min(l,p);v</span>ar T=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(T,"maxMessageSize",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e}</span>}),this._sctp=T}</span>v</span>ar E,S;<span class="cstat-no" title="statement not covered" >return n.apply(this,arguments)}</span>}</span>},n.shimSendThrowTypeError=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t.RTCPeerConnection&amp;&amp;"createDataChannel"in t.RTCPeerConnection.prototype){var i=t.RTCPeerConnection.prototype.createDataChannel;t.RTCPeerConnection.prototype.createDataChannel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >i.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return n(t,this),t}</span>,E.wrapPeerConnectionEvent(t,"datachannel",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n(t.channel,t.target),t}</span>)}function <span class="fstat-no" title="function not covered" >n(</span>t,i){var n=<span class="cstat-no" title="statement not covered" >t.send;<span class="cstat-no" title="statement not covered" ></span>t.send=<span class="fstat-no" title="function not covered" >fu</span>nction(){var l=<span class="cstat-no" title="statement not covered" >arguments[0],</span>p=<span class="cstat-no" title="statement not covered" >l.length||l.size||l.byteLength;<span class="cstat-no" title="statement not covered" ></span>if("open"===t.readyState&amp;&amp;i.sctp&amp;&amp;p&gt;i.sctp.maxMessageSize)<span class="cstat-no" title="statement not covered" >throw new TypeError("Message too large (can send a maximum of "+i.sctp.maxMessageSize+" bytes)");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.apply(t,arguments)}</span>}</span>},n.shimConnectionState=function(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(t.RTCPeerConnection&amp;&amp;!("connectionState"in t.RTCPeerConnection.prototype)){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(i,"connectionState",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState}</span>,enumerable:!0,configurable:!0}),Object.defineProperty(i,"onconnectionstatechange",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._onconnectionstatechange||null}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._onconnectionstatechange&amp;&amp;(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),t&amp;&amp;this.addEventListener("connectionstatechange",this._onconnectionstatechange=t)}</span>,enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>i[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._connectionstatechangepoly||(this._connectionstatechangepoly=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.target;<span class="cstat-no" title="statement not covered" ></span>if(i._lastConnectionState!==i.connectionState){<span class="cstat-no" title="statement not covered" >i._lastConnectionState=i.connectionState;v</span>ar n=<span class="cstat-no" title="statement not covered" >new Event("connectionstatechange",t);<span class="cstat-no" title="statement not covered" ></span>i.dispatchEvent(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),n.apply(this,arguments)}</span>}</span>)}</span>},n.removeAllowExtmapMixed=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t.RTCPeerConnection){var i=E.detectBrowser(t);<span class="missing-if-branch" title="if path not taken" >I</span>if(!("chrome"===i.browser&amp;&amp;i.version&gt;=71)){var n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t.sdp&amp;&amp;-1!==t.sdp.indexOf("\na=extmap-allow-mixed")&amp;&amp;(t.sdp=t.sdp.split("\n").filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"a=extmap-allow-mixed"!==t.trim()}</span>).join("\n")),n.apply(this,arguments)}</span>}</span>}};var p,e=t("sdp"),v=(p=e)&amp;&amp;p.__esModule?<span class="branch-0 cbranch-no" title="branch not covered" >p:</span>{default:p},T=t("./utils"),E=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(T)},{"./utils":15,sdp:17}],7:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.shimGetDisplayMedia=n.shimGetUserMedia=void 0;var l=t("./getusermedia");Object.defineProperty(n,"shimGetUserMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return l.shimGetUserMedia}</span>});var p=t("./getdisplaymedia");Object.defineProperty(n,"shimGetDisplayMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return p.shimGetDisplayMedia}</span>}),n.shimPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >T.detectBrowser(t);<span class="cstat-no" title="statement not covered" ></span>if(t.RTCIceGatherer&amp;&amp;(t.RTCIceCandidate||(t.RTCIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>),t.RTCSessionDescription||(t.RTCSessionDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>),i.version&lt;15025)){var n=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(t.MediaStreamTrack.prototype,"enabled");<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t.MediaStreamTrack.prototype,"enabled",{set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.set.call(this,t);v</span>ar i=<span class="cstat-no" title="statement not covered" >new Event("enabled");<span class="cstat-no" title="statement not covered" ></span>i.enabled=t,this.dispatchEvent(i)}</span>})}<span class="cstat-no" title="statement not covered" ></span>!</span>t.RTCRtpSender||"dtmf"in t.RTCRtpSender.prototype||Object.defineProperty(t.RTCRtpSender.prototype,"dtmf",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return void 0===this._dtmf&amp;&amp;("audio"===this.track.kind?this._dtmf=new t.RTCDtmfSender(this):"video"===this.track.kind&amp;&amp;(this._dtmf=null)),this._dtmf}</span>}),t.RTCDtmfSender&amp;&amp;!t.RTCDTMFSender&amp;&amp;(t.RTCDTMFSender=t.RTCDtmfSender);v</span>ar l=<span class="cstat-no" title="statement not covered" >(0,R.default)(t,i.version);<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t.iceServers&amp;&amp;(t.iceServers=(0,E.filterIceServers)(t.iceServers,i.version),T.log("ICE servers after filtering:",t.iceServers)),new l(t)}</span>,t.RTCPeerConnection.prototype=l.prototype}</span>,n.shimReplaceTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >!t.RTCRtpSender||"replaceTrack"in t.RTCRtpSender.prototype||(t.RTCRtpSender.prototype.replaceTrack=t.RTCRtpSender.prototype.setTrack)}</span>;var e,v=t("../utils"),T=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(v),E=t("./filtericeservers"),S=t("rtcpeerconnection-shim"),R=(e=S)&amp;&amp;e.__esModule?<span class="branch-0 cbranch-no" title="branch not covered" >e:</span>{default:e}},{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.filterIceServers=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return(t=JSON.parse(JSON.stringify(t))).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;(t.urls||t.url)){var i=<span class="cstat-no" title="statement not covered" >t.urls||t.url;<span class="cstat-no" title="statement not covered" ></span>t.url&amp;&amp;!t.urls&amp;&amp;p.deprecated("RTCIceServer.url","RTCIceServer.urls");v</span>ar l=<span class="cstat-no" title="statement not covered" >"string"==typeof i;<span class="cstat-no" title="statement not covered" ></span>return l&amp;&amp;(i=[i]),i=i.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(0===t.indexOf("stun:"))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >t.startsWith("turn")&amp;&amp;!t.startsWith("turn:[")&amp;&amp;t.includes("transport=udp");<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;!n?(n=!0,!0):i&amp;&amp;!n}</span>),delete t.url,t.urls=l?i[0]:i,!!i.length}</span>}</span>)}</span>;var l=t("../utils"),p=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(l)},{"../utils":15}],9:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.shimGetDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"getDisplayMedia"in t.navigator&amp;&amp;t.navigator.mediaDevices&amp;&amp;(t.navigator.mediaDevices&amp;&amp;"getDisplayMedia"in t.navigator.mediaDevices||(t.navigator.mediaDevices.getDisplayMedia=t.navigator.getDisplayMedia.bind(t.navigator)))}</span>},{}],10:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.shimGetUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.navigator,</span>n=<span class="cstat-no" title="statement not covered" >i.mediaDevices.getUserMedia.bind(i.mediaDevices);<span class="cstat-no" title="statement not covered" ></span>i.mediaDevices.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n(t).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Promise.reject(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{name:{PermissionDeniedError:"NotAllowedError"}[t.name]||t.name,message:t.message,constraint:t.constraint,toString:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.name}</span>}}</span>(t))}</span>)}</span>}</span>},{}],11:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.shimGetDisplayMedia=n.shimGetUserMedia=void 0;var l="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return typeof t}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>,</span>p=t("./getusermedia");Object.defineProperty(n,"shimGetUserMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return p.shimGetUserMedia}</span>});var e=t("./getdisplaymedia");Object.defineProperty(n,"shimGetDisplayMedia",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.shimGetDisplayMedia}</span>}),n.shimOnTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"object"===(void 0===t?"undefined":l(t))&amp;&amp;t.RTCTrackEvent&amp;&amp;"receiver"in t.RTCTrackEvent.prototype&amp;&amp;!("transceiver"in t.RTCTrackEvent.prototype)&amp;&amp;Object.defineProperty(t.RTCTrackEvent.prototype,"transceiver",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{receiver:this.receiver}}</span>})}</span>,n.shimPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >T.detectBrowser(t);<span class="cstat-no" title="statement not covered" ></span>if("object"===(void 0===t?"undefined":l(t))&amp;&amp;(t.RTCPeerConnection||t.mozRTCPeerConnection)){<span class="cstat-no" title="statement not covered" >!t.RTCPeerConnection&amp;&amp;t.mozRTCPeerConnection&amp;&amp;(t.RTCPeerConnection=t.mozRTCPeerConnection),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype[i];<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype[i]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments[0]=new("addIceCandidate"===i?t.RTCIceCandidate:t.RTCSessionDescription)(arguments[0]),n.apply(this,arguments)}</span>}</span>);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.addIceCandidate;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.addIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return arguments[0]?n.apply(this,arguments):(arguments[1]&amp;&amp;arguments[1].apply(null),Promise.resolve())}</span>;v</span>ar p=<span class="cstat-no" title="statement not covered" >{inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},</span>e=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getStats;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >return e.apply(this,[t||null]).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(i.version&lt;53&amp;&amp;!n)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.type=p[t.type]||t.type}</span>)}</span>catch(i){<span class="cstat-no" title="statement not covered" >if("TypeError"!==i.name)<span class="cstat-no" title="statement not covered" >throw i;<span class="cstat-no" title="statement not covered" >t</span></span>.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.set(n,Object.assign({},i,{type:p[i.type]||i.type}))}</span>)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t}</span>).then(n,l)}</span>}</span>}</span>,n.shimSenderGetStats=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===t?"undefined":l(t))&amp;&amp;t.RTCPeerConnection&amp;&amp;t.RTCRtpSender&amp;&amp;!(t.RTCRtpSender&amp;&amp;"getStats"in t.RTCRtpSender.prototype)){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getSenders;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(t.RTCPeerConnection.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >i.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return n.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i._pc=t}</span>),n}</span>);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(t.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >n.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return t._pc=this,t}</span>),t.RTCRtpSender.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}</span>}</span>}</span>,n.shimReceiverGetStats=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===t?"undefined":l(t))&amp;&amp;t.RTCPeerConnection&amp;&amp;t.RTCRtpSender&amp;&amp;!(t.RTCRtpSender&amp;&amp;"getStats"in t.RTCRtpReceiver.prototype)){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.getReceivers;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(t.RTCPeerConnection.prototype.getReceivers=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >i.apply(this,[]);<span class="cstat-no" title="statement not covered" ></span>return n.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i._pc=t}</span>),n}</span>),T.wrapPeerConnectionEvent(t,"track",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.receiver._pc=t.srcElement,t}</span>),t.RTCRtpReceiver.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._pc.getStats(this.track)}</span>}</span>}</span>,n.shimRemoveStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >!t.RTCPeerConnection||"removeStream"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>T.deprecated("removeStream","removeTrack"),this.getSenders().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >n.track&amp;&amp;t.getTracks().includes(n.track)&amp;&amp;i.removeTrack(n)}</span>)}</span>)}</span>,n.shimRTCDataChannel=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.DataChannel&amp;&amp;!t.RTCDataChannel&amp;&amp;(t.RTCDataChannel=t.DataChannel)}</span>;var v=t("../utils"),T=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(v)},{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.shimGetDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.navigator.mediaDevices&amp;&amp;"getDisplayMedia"in t.navigator.mediaDevices||t.navigator.mediaDevices&amp;&amp;(t.navigator.mediaDevices.getDisplayMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >if(!n||!n.video){var l=<span class="cstat-no" title="statement not covered" >new DOMException("getDisplayMedia without video constraints is undefined");<span class="cstat-no" title="statement not covered" ></span>return l.name="NotFoundError",l.code=8,Promise.reject(l)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0===n.video?n.video={mediaSource:i}:n.video.mediaSource=i,t.navigator.mediaDevices.getUserMedia(n)}</span>)}</span>},{}],13:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return typeof t}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>;</span>n.shimGetUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >e.detectBrowser(t),</span>n=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.navigator,</span>p=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.MediaStreamTrack;<span class="cstat-no" title="statement not covered" ></span>if(n.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,l){<span class="cstat-no" title="statement not covered" >e.deprecated("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),n.mediaDevices.getUserMedia(t).then(i,l)}</span>,!(i.version&gt;55&amp;&amp;"autoGainControl"in n.mediaDevices.getSupportedConstraints())){var v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >i in t&amp;&amp;!(n in t)&amp;&amp;(t[n]=t[i],delete t[i])}</span>,</span>T=<span class="cstat-no" title="statement not covered" >n.mediaDevices.getUserMedia.bind(n.mediaDevices);<span class="cstat-no" title="statement not covered" ></span>if(n.mediaDevices.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"object"===(void 0===t?"undefined":l(t))&amp;&amp;"object"===l(t.audio)&amp;&amp;(t=JSON.parse(JSON.stringify(t)),v(t.audio,"autoGainControl","mozAutoGainControl"),v(t.audio,"noiseSuppression","mozNoiseSuppression")),T(t)}</span>,p&amp;&amp;p.prototype.getSettings){var E=<span class="cstat-no" title="statement not covered" >p.prototype.getSettings;<span class="cstat-no" title="statement not covered" ></span>p.prototype.getSettings=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >E.apply(this,arguments);<span class="cstat-no" title="statement not covered" ></span>return v(t,"mozAutoGainControl","autoGainControl"),v(t,"mozNoiseSuppression","noiseSuppression"),t}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p&amp;&amp;p.prototype.applyConstraints){var S=<span class="cstat-no" title="statement not covered" >p.prototype.applyConstraints;<span class="cstat-no" title="statement not covered" ></span>p.prototype.applyConstraints=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"audio"===this.kind&amp;&amp;"object"===(void 0===t?"undefined":l(t))&amp;&amp;(t=JSON.parse(JSON.stringify(t)),v(t,"autoGainControl","mozAutoGainControl"),v(t,"noiseSuppression","mozNoiseSuppression")),S.apply(this,[t])}</span>}</span>}</span>}</span>;var p=t("../utils"),e=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(p)},{"../utils":15}],14:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return typeof t}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>;</span>n.shimLocalStreamsAPI=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===t?"undefined":l(t))&amp;&amp;t.RTCPeerConnection){<span class="cstat-no" title="statement not covered" >if("getLocalStreams"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._localStreams||(this._localStreams=[]),this._localStreams}</span>),!("addStream"in t.RTCPeerConnection.prototype)){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.addTrack;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._localStreams||(this._localStreams=[]),this._localStreams.includes(t)||this._localStreams.push(t),t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(l){<span class="cstat-no" title="statement not covered" >return i.call(n,l,t)}</span>)}</span>,t.RTCPeerConnection.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return n&amp;&amp;(this._localStreams?this._localStreams.includes(n)||this._localStreams.push(n):this._localStreams=[n]),i.call(this,t,n)}</span>}<span class="cstat-no" title="statement not covered" ></span>"</span>removeStream"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._localStreams||(this._localStreams=[]);v</span>ar n=<span class="cstat-no" title="statement not covered" >this._localStreams.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>if(-1!==n){<span class="cstat-no" title="statement not covered" >this._localStreams.splice(n,1);v</span>ar l=<span class="cstat-no" title="statement not covered" >t.getTracks();<span class="cstat-no" title="statement not covered" ></span>this.getSenders().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.includes(t.track)&amp;&amp;i.removeTrack(t)}</span>)}</span>}</span>)}</span>}</span>,n.shimRemoteStreamsAPI=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===t?"undefined":l(t))&amp;&amp;t.RTCPeerConnection&amp;&amp;("getRemoteStreams"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.getRemoteStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._remoteStreams?this._remoteStreams:[]}</span>),!("onaddstream"in t.RTCPeerConnection.prototype))){<span class="cstat-no" title="statement not covered" >Object.defineProperty(t.RTCPeerConnection.prototype,"onaddstream",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._onaddstream}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._onaddstream&amp;&amp;(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=t),this.addEventListener("track",this._onaddstreampoly=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.streams.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(i._remoteStreams||(i._remoteStreams=[]),!i._remoteStreams.includes(t)){<span class="cstat-no" title="statement not covered" >i._remoteStreams.push(t);v</span>ar n=<span class="cstat-no" title="statement not covered" >new Event("addstream");<span class="cstat-no" title="statement not covered" ></span>n.stream=t,i.dispatchEvent(n)}</span>}</span>)}</span>)}</span>});v</span>ar i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.setRemoteDescription;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >i.streams.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >if(t._remoteStreams||(t._remoteStreams=[]),!(t._remoteStreams.indexOf(i)&gt;=0)){<span class="cstat-no" title="statement not covered" >t._remoteStreams.push(i);v</span>ar n=<span class="cstat-no" title="statement not covered" >new Event("addstream");<span class="cstat-no" title="statement not covered" ></span>n.stream=i,t.dispatchEvent(n)}</span>}</span>)}</span>),i.apply(t,arguments)}</span>}</span>}</span>,n.shimCallbacksAPI=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("object"===(void 0===t?"undefined":l(t))&amp;&amp;t.RTCPeerConnection){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype,</span>n=<span class="cstat-no" title="statement not covered" >i.createOffer,</span>p=<span class="cstat-no" title="statement not covered" >i.createAnswer,</span>e=<span class="cstat-no" title="statement not covered" >i.setLocalDescription,</span>v=<span class="cstat-no" title="statement not covered" >i.setRemoteDescription,</span>T=<span class="cstat-no" title="statement not covered" >i.addIceCandidate;<span class="cstat-no" title="statement not covered" ></span>i.createOffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var l=<span class="cstat-no" title="statement not covered" >arguments.length&gt;=2?arguments[2]:arguments[0],</span>p=<span class="cstat-no" title="statement not covered" >n.apply(this,[l]);<span class="cstat-no" title="statement not covered" ></span>return i?(p.then(t,i),Promise.resolve()):p}</span>,i.createAnswer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;=2?arguments[2]:arguments[0],</span>l=<span class="cstat-no" title="statement not covered" >p.apply(this,[n]);<span class="cstat-no" title="statement not covered" ></span>return i?(l.then(t,i),Promise.resolve()):l}</span>;v</span>ar E=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >e.apply(this,[t]);<span class="cstat-no" title="statement not covered" ></span>return n?(l.then(i,n),Promise.resolve()):l}</span>;<span class="cstat-no" title="statement not covered" ></span>i.setLocalDescription=E,E=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >v.apply(this,[t]);<span class="cstat-no" title="statement not covered" ></span>return n?(l.then(i,n),Promise.resolve()):l}</span>,i.setRemoteDescription=E,E=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >T.apply(this,[t]);<span class="cstat-no" title="statement not covered" ></span>return n?(l.then(i,n),Promise.resolve()):l}</span>,i.addIceCandidate=E}</span>}</span>,n.shimGetUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.navigator;<span class="cstat-no" title="statement not covered" ></span>if(i.mediaDevices&amp;&amp;i.mediaDevices.getUserMedia){var n=<span class="cstat-no" title="statement not covered" >i.mediaDevices,</span>l=<span class="cstat-no" title="statement not covered" >n.getUserMedia.bind(n);<span class="cstat-no" title="statement not covered" ></span>i.mediaDevices.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return l(v(t))}</span>}<span class="cstat-no" title="statement not covered" ></span>!</span>i.getUserMedia&amp;&amp;i.mediaDevices&amp;&amp;i.mediaDevices.getUserMedia&amp;&amp;(i.getUserMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.mediaDevices.getUserMedia(t).then(n,l)}</span>.bind(i))}</span>,n.shimConstraints=v,n.shimRTCIceServerUrls=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;t.iceServers){<span class="cstat-no" title="statement not covered" >for(var l=[],p=0;p&lt;t.iceServers.length;p++){var v=<span class="cstat-no" title="statement not covered" >t.iceServers[p];<span class="cstat-no" title="statement not covered" ></span>!v.hasOwnProperty("urls")&amp;&amp;v.hasOwnProperty("url")?(e.deprecated("RTCIceServer.url","RTCIceServer.urls"),(v=JSON.parse(JSON.stringify(v))).urls=v.url,delete v.url,l.push(v)):l.push(t.iceServers[p])}<span class="cstat-no" title="statement not covered" ></span>t</span>.iceServers=l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new i(t,n)}</span>,t.RTCPeerConnection.prototype=i.prototype,"generateCertificate"in t.RTCPeerConnection&amp;&amp;Object.defineProperty(t.RTCPeerConnection,"generateCertificate",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.generateCertificate}</span>})}</span>,n.shimTrackEventTransceiver=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"object"===(void 0===t?"undefined":l(t))&amp;&amp;t.RTCPeerConnection&amp;&amp;"receiver"in t.RTCTrackEvent.prototype&amp;&amp;!t.RTCTransceiver&amp;&amp;Object.defineProperty(t.RTCTrackEvent.prototype,"transceiver",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{receiver:this.receiver}}</span>})}</span>,n.shimCreateOfferLegacy=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.RTCPeerConnection.prototype.createOffer;<span class="cstat-no" title="statement not covered" ></span>t.RTCPeerConnection.prototype.createOffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >void 0!==t.offerToReceiveAudio&amp;&amp;(t.offerToReceiveAudio=!!t.offerToReceiveAudio);v</span>ar n=<span class="cstat-no" title="statement not covered" >this.getTransceivers().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"audio"===t.receiver.track.kind}</span>);<span class="cstat-no" title="statement not covered" ></span>!1===t.offerToReceiveAudio&amp;&amp;n?"sendrecv"===n.direction?n.setDirection?n.setDirection("sendonly"):n.direction="sendonly":"recvonly"===n.direction&amp;&amp;(n.setDirection?n.setDirection("inactive"):n.direction="inactive"):!0!==t.offerToReceiveAudio||n||this.addTransceiver("audio"),void 0!==t.offerToReceiveVideo&amp;&amp;(t.offerToReceiveVideo=!!t.offerToReceiveVideo);v</span>ar l=<span class="cstat-no" title="statement not covered" >this.getTransceivers().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"video"===t.receiver.track.kind}</span>);<span class="cstat-no" title="statement not covered" ></span>!1===t.offerToReceiveVideo&amp;&amp;l?"sendrecv"===l.direction?l.setDirection?l.setDirection("sendonly"):l.direction="sendonly":"recvonly"===l.direction&amp;&amp;(l.setDirection?l.setDirection("inactive"):l.direction="inactive"):!0!==t.offerToReceiveVideo||l||this.addTransceiver("video")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.apply(this,arguments)}</span>}</span>;var p=t("../utils"),e=function(t){<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;t.__esModule)return t;var i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(i[n]=t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i.default=t,i}</span>(p);function <span class="fstat-no" title="function not covered" >v(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;void 0!==t.video?Object.assign({},t,{video:e.compactObject(t.video)}):t}</span>},{"../utils":15}],15:[function(t,i,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(t){return typeof t}:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"function"==typeof Symbol&amp;&amp;t.constructor===Symbol&amp;&amp;t!==Symbol.prototype?"symbol":typeof t}</span>;</span>n.extractVersion=v,n.wrapPeerConnectionEvent=function(t,i,n){<span class="missing-if-branch" title="else path not taken" >E</span>if(t.RTCPeerConnection){var l=t.RTCPeerConnection.prototype,p=l.addEventListener;l.addEventListener=<span class="fstat-no" title="function not covered" >fu</span>nction(t,l){<span class="cstat-no" title="statement not covered" >if(t!==i)<span class="cstat-no" title="statement not covered" >return p.apply(this,arguments);v</span></span>ar e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >n(t);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;l(i)}</span>;<span class="cstat-no" title="statement not covered" ></span>return this._eventMap=this._eventMap||{},this._eventMap[l]=e,p.apply(this,[t,e])}</span>;var e=l.removeEventListener;l.removeEventListener=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if(t!==i||!this._eventMap||!this._eventMap[n])<span class="cstat-no" title="statement not covered" >return e.apply(this,arguments);v</span></span>ar l=<span class="cstat-no" title="statement not covered" >this._eventMap[n];<span class="cstat-no" title="statement not covered" ></span>return delete this._eventMap[n],e.apply(this,[t,l])}</span>,Object.defineProperty(l,"on"+i,{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this["_on"+i]}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this["_on"+i]&amp;&amp;(this.removeEventListener(i,this["_on"+i]),delete this["_on"+i]),t&amp;&amp;this.addEventListener(i,this["_on"+i]=t)}</span>,enumerable:!0,configurable:!0})}},n.disableLog=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"boolean"!=typeof t?new Error("Argument type: "+(void 0===t?"undefined":l(t))+". Please use a boolean."):(p=t,t?"adapter.js logging disabled":"adapter.js logging enabled")}</span>,n.disableWarnings=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"boolean"!=typeof t?new Error("Argument type: "+(void 0===t?"undefined":l(t))+". Please use a boolean."):(e=!t,"adapter.js deprecation warnings "+(t?"disabled":"enabled"))}</span>,n.log=function(){<span class="missing-if-branch" title="else path not taken" >E</span>if("object"===("undefined"==typeof window?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>l(window))){<span class="missing-if-branch" title="else path not taken" >E</span>if(p)return;<span class="cstat-no" title="statement not covered" >"undefined"!=typeof console&amp;&amp;"function"==typeof console.log&amp;&amp;console.log.apply(console,arguments)}</span>},n.deprecated=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >e&amp;&amp;console.warn(t+" is deprecated, please use "+i+" instead.")}</span>,n.detectBrowser=function(t){var i=t.navigator,n={browser:null,version:null};<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===t||!t.navigator)<span class="cstat-no" title="statement not covered" >return n.browser="Not a browser.",n;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i.mozGetUserMedia)<span class="cstat-no" title="statement not covered" >n.browser="firefox",n.version=v(i.userAgent,/Firefox\/(\d+)\./,1);e</span>lse <span class="missing-if-branch" title="else path not taken" >E</span>if(i.webkitGetUserMedia||<span class="branch-1 cbranch-no" title="branch not covered" >!1===t.isSecureContext&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >t.webkitRTCPeerConnection&amp;</span>&amp;<span class="branch-3 cbranch-no" title="branch not covered" >!t.RTCIceGatherer)</span>n.browser="chrome",n.version=v(i.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else <span class="cstat-no" title="statement not covered" >if(i.mediaDevices&amp;&amp;i.userAgent.match(/Edge\/(\d+).(\d+)$/))<span class="cstat-no" title="statement not covered" >n.browser="edge",n.version=v(i.userAgent,/Edge\/(\d+).(\d+)$/,2);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!t.RTCPeerConnection||!i.userAgent.match(/AppleWebKit\/(\d+)\./))<span class="cstat-no" title="statement not covered" >return n.browser="Not a supported browser.",n;<span class="cstat-no" title="statement not covered" >n</span></span>.browser="safari",n.version=v(i.userAgent,/AppleWebKit\/(\d+)\./,1)}</span>r</span>eturn n},n.compactObject=function <span class="fstat-no" title="function not covered" >t(</span>i){<span class="cstat-no" title="statement not covered" >return"object"!==(void 0===i?"undefined":l(i))?i:Object.keys(i).reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(n,p){var e=<span class="cstat-no" title="statement not covered" >"object"===l(i[p]),</span>v=<span class="cstat-no" title="statement not covered" >e?t(i[p]):i[p],</span>T=<span class="cstat-no" title="statement not covered" >e&amp;&amp;!Object.keys(v).length;<span class="cstat-no" title="statement not covered" ></span>return void 0===v||T?n:Object.assign(n,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return i in t?Object.defineProperty(t,i,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[i]=n,t}</span>({},p,v))}</span>,{})}</span>,n.walkStats=T,n.filterStats=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >n?"outbound-rtp":"inbound-rtp",</span>p=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>if(null===i)<span class="cstat-no" title="statement not covered" >return p;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"track"===t.type&amp;&amp;t.trackIdentifier===i.id&amp;&amp;e.push(t)}</span>),e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >n.type===l&amp;&amp;n.trackId===i.id&amp;&amp;T(t,n,p)}</span>)}</span>),p}</span>;var p=!0,e=!0;function v(t,i,n){var l=t.match(i);return l&amp;&amp;l.length&gt;=n&amp;&amp;parseInt(l[n],10)}function <span class="fstat-no" title="function not covered" >T(</span>t,i,n){<span class="cstat-no" title="statement not covered" >i&amp;&amp;!n.has(i.id)&amp;&amp;(n.set(i.id,i),Object.keys(i).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(l){<span class="cstat-no" title="statement not covered" >l.endsWith("Id")?T(t,t.get(i[l]),n):l.endsWith("Ids")&amp;&amp;i[l].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >T(t,t.get(i),n)}</span>)}</span>))}</span>},{}],16:[function(t,i,n){"use strict";var l=t("sdp");function <span class="fstat-no" title="function not covered" >p(</span>t,i,n,p,e){var v=<span class="cstat-no" title="statement not covered" >l.writeRtpDescription(t.kind,i);<span class="cstat-no" title="statement not covered" ></span>if(v+=l.writeIceParameters(t.iceGatherer.getLocalParameters()),v+=l.writeDtlsParameters(t.dtlsTransport.getLocalParameters(),"offer"===n?"actpass":e||"active"),v+="a=mid:"+t.mid+"\r\n",t.rtpSender&amp;&amp;t.rtpReceiver?v+="a=sendrecv\r\n":t.rtpSender?v+="a=sendonly\r\n":t.rtpReceiver?v+="a=recvonly\r\n":v+="a=inactive\r\n",t.rtpSender){var T=<span class="cstat-no" title="statement not covered" >t.rtpSender._initialTrackId||t.rtpSender.track.id;<span class="cstat-no" title="statement not covered" ></span>t.rtpSender._initialTrackId=T;v</span>ar E=<span class="cstat-no" title="statement not covered" >"msid:"+(p?p.id:"-")+" "+T+"\r\n";<span class="cstat-no" title="statement not covered" ></span>v+="a="+E,v+="a=ssrc:"+t.sendEncodingParameters[0].ssrc+" "+E,t.sendEncodingParameters[0].rtx&amp;&amp;(v+="a=ssrc:"+t.sendEncodingParameters[0].rtx.ssrc+" "+E,v+="a=ssrc-group:FID "+t.sendEncodingParameters[0].ssrc+" "+t.sendEncodingParameters[0].rtx.ssrc+"\r\n")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn v+="a=ssrc:"+t.sendEncodingParameters[0].ssrc+" cname:"+l.localCName+"\r\n",t.rtpSender&amp;&amp;t.sendEncodingParameters[0].rtx&amp;&amp;(v+="a=ssrc:"+t.sendEncodingParameters[0].rtx.ssrc+" cname:"+l.localCName+"\r\n"),v}</span>function <span class="fstat-no" title="function not covered" >e(</span>t,i){var n=<span class="cstat-no" title="statement not covered" >{codecs:[],headerExtensions:[],fecMechanisms:[]},</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t=parseInt(t,10);<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >if(i[n].payloadType===t||i[n].preferredPayloadType===t)<span class="cstat-no" title="statement not covered" >return i[n]}</span></span></span>,</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p){var e=<span class="cstat-no" title="statement not covered" >l(t.parameters.apt,n),</span>v=<span class="cstat-no" title="statement not covered" >l(i.parameters.apt,p);<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;v&amp;&amp;e.name.toLowerCase()===v.name.toLowerCase()}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.codecs.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(l){<span class="cstat-no" title="statement not covered" >for(var e=0;e&lt;i.codecs.length;e++){var v=<span class="cstat-no" title="statement not covered" >i.codecs[e];<span class="cstat-no" title="statement not covered" ></span>if(l.name.toLowerCase()===v.name.toLowerCase()&amp;&amp;l.clockRate===v.clockRate){<span class="cstat-no" title="statement not covered" >if("rtx"===l.name.toLowerCase()&amp;&amp;l.parameters&amp;&amp;v.parameters.apt&amp;&amp;!p(l,v,t.codecs,i.codecs))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >(</span></span>v=JSON.parse(JSON.stringify(v))).numChannels=Math.min(l.numChannels,v.numChannels),n.codecs.push(v),v.rtcpFeedback=v.rtcpFeedback.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;l.rtcpFeedback.length;i++)<span class="cstat-no" title="statement not covered" >if(l.rtcpFeedback[i].type===t.type&amp;&amp;l.rtcpFeedback[i].parameter===t.parameter)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}</span>),t.headerExtensions.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;i.headerExtensions.length;l++){var p=<span class="cstat-no" title="statement not covered" >i.headerExtensions[l];<span class="cstat-no" title="statement not covered" ></span>if(t.uri===p.uri){<span class="cstat-no" title="statement not covered" >n.headerExtensions.push(p);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}</span>),n}</span>function <span class="fstat-no" title="function not covered" >v(</span>t,i,n){<span class="cstat-no" title="statement not covered" >return-1!=={offer:{setLocalDescription:["stable","have-local-offer"],setRemoteDescription:["stable","have-remote-offer"]},answer:{setLocalDescription:["have-remote-offer","have-local-pranswer"],setRemoteDescription:["have-local-offer","have-remote-pranswer"]}}[i][t].indexOf(n)}</span>function <span class="fstat-no" title="function not covered" >T(</span>t,i){var n=<span class="cstat-no" title="statement not covered" >t.getRemoteCandidates().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return i.foundation===t.foundation&amp;&amp;i.ip===t.ip&amp;&amp;i.port===t.port&amp;&amp;i.priority===t.priority&amp;&amp;i.protocol===t.protocol&amp;&amp;i.type===t.type}</span>);<span class="cstat-no" title="statement not covered" ></span>return n||t.addRemoteCandidate(i),!n}</span>function <span class="fstat-no" title="function not covered" >E(</span>t,i){var n=<span class="cstat-no" title="statement not covered" >new Error(i);<span class="cstat-no" title="statement not covered" ></span>return n.name=t,n.code={NotSupportedError:9,InvalidStateError:11,InvalidAccessError:15,TypeError:void 0,OperationError:void 0}[t],n}</span>i.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){function <span class="fstat-no" title="function not covered" >n(</span>i,n){<span class="cstat-no" title="statement not covered" >n.addTrack(i),n.dispatchEvent(new t.MediaStreamTrackEvent("addtrack",{track:i}))}</span>function <span class="fstat-no" title="function not covered" >S(</span>i,n,l,p){var e=<span class="cstat-no" title="statement not covered" >new Event("track");<span class="cstat-no" title="statement not covered" ></span>e.track=n,e.receiver=l,e.transceiver={receiver:l},e.streams=p,t.setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i._dispatchEvent("track",e)}</span>)}</span>var R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n){var p=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >document.createDocumentFragment();<span class="cstat-no" title="statement not covered" ></span>if(["addEventListener","removeEventListener","dispatchEvent"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p[t]=e[t].bind(e)}</span>),this.canTrickleIceCandidates=null,this.needNegotiation=!1,this.localStreams=[],this.remoteStreams=[],this._localDescription=null,this._remoteDescription=null,this.signalingState="stable",this.iceConnectionState="new",this.connectionState="new",this.iceGatheringState="new",n=JSON.parse(JSON.stringify(n||{})),this.usingBundle="max-bundle"===n.bundlePolicy,"negotiate"===n.rtcpMuxPolicy)<span class="cstat-no" title="statement not covered" >throw E("NotSupportedError","rtcpMuxPolicy 'negotiate' is not supported");<span class="cstat-no" title="statement not covered" >s</span></span>witch(n.rtcpMuxPolicy||(n.rtcpMuxPolicy="require"),n.iceTransportPolicy){case"all":case"relay":<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >n.iceTransportPolicy="all"}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(n.bundlePolicy){case"balanced":case"max-compat":case"max-bundle":<span class="cstat-no" title="statement not covered" >break;d</span>efault:<span class="cstat-no" title="statement not covered" >n.bundlePolicy="balanced"}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.iceServers=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return(t=JSON.parse(JSON.stringify(t))).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;(t.urls||t.url)){var l=<span class="cstat-no" title="statement not covered" >t.urls||t.url;<span class="cstat-no" title="statement not covered" ></span>t.url&amp;&amp;!t.urls&amp;&amp;console.warn("RTCIceServer.url is deprecated! Use urls instead.");v</span>ar p=<span class="cstat-no" title="statement not covered" >"string"==typeof l;<span class="cstat-no" title="statement not covered" ></span>return p&amp;&amp;(l=[l]),l=l.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0!==t.indexOf("turn:")||-1===t.indexOf("transport=udp")||-1!==t.indexOf("turn:[")||n?0===t.indexOf("stun:")&amp;&amp;i&gt;=14393&amp;&amp;-1===t.indexOf("?transport=udp"):(n=!0,!0)}</span>),delete t.url,t.urls=p?l[0]:l,!!l.length}</span>}</span>)}</span>(n.iceServers||[],i),this._iceGatherers=[],n.iceCandidatePoolSize)<span class="cstat-no" title="statement not covered" >for(var v=n.iceCandidatePoolSize;v&gt;0;v--)<span class="cstat-no" title="statement not covered" >this._iceGatherers.push(new t.RTCIceGatherer({iceServers:n.iceServers,gatherPolicy:n.iceTransportPolicy}));e</span></span>lse <span class="cstat-no" title="statement not covered" >n.iceCandidatePoolSize=0;<span class="cstat-no" title="statement not covered" >t</span></span>his._config=n,this.transceivers=[],this._sdpSessionId=l.generateSessionId(),this._sdpSessionVersion=0,this._dtlsRole=void 0,this._isClosed=!1}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(R.prototype,"localDescription",{configurable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._localDescription}</span>}),Object.defineProperty(R.prototype,"remoteDescription",{configurable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._remoteDescription}</span>}),R.prototype.onicecandidate=null,R.prototype.onaddstream=null,R.prototype.ontrack=null,R.prototype.onremovestream=null,R.prototype.onsignalingstatechange=null,R.prototype.oniceconnectionstatechange=null,R.prototype.onconnectionstatechange=null,R.prototype.onicegatheringstatechange=null,R.prototype.onnegotiationneeded=null,R.prototype.ondatachannel=null,R.prototype._dispatchEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this._isClosed||(this.dispatchEvent(i),"function"==typeof this["on"+t]&amp;&amp;this["on"+t](i))}</span>,R.prototype._emitGatheringStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >new Event("icegatheringstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("icegatheringstatechange",t)}</span>,R.prototype.getConfiguration=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._config}</span>,R.prototype.getLocalStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.localStreams}</span>,R.prototype.getRemoteStreams=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.remoteStreams}</span>,R.prototype._createTransceiver=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this.transceivers.length&gt;0,</span>l=<span class="cstat-no" title="statement not covered" >{track:null,iceGatherer:null,iceTransport:null,dtlsTransport:null,localCapabilities:null,remoteCapabilities:null,rtpSender:null,rtpReceiver:null,kind:t,mid:null,sendEncodingParameters:null,recvEncodingParameters:null,stream:null,associatedRemoteMediaStreams:[],wantReceive:!0};<span class="cstat-no" title="statement not covered" ></span>if(this.usingBundle&amp;&amp;n)<span class="cstat-no" title="statement not covered" >l.iceTransport=this.transceivers[0].iceTransport,l.dtlsTransport=this.transceivers[0].dtlsTransport;e</span>lse{var p=<span class="cstat-no" title="statement not covered" >this._createIceAndDtlsTransports();<span class="cstat-no" title="statement not covered" ></span>l.iceTransport=p.iceTransport,l.dtlsTransport=p.dtlsTransport}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i||this.transceivers.push(l),l}</span>,R.prototype.addTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >if(this._isClosed)<span class="cstat-no" title="statement not covered" >throw E("InvalidStateError","Attempted to call addTrack on a closed peerconnection.");v</span></span>ar l,p=<span class="cstat-no" title="statement not covered" >this.transceivers.find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.track===i}</span>);<span class="cstat-no" title="statement not covered" ></span>if(p)<span class="cstat-no" title="statement not covered" >throw E("InvalidAccessError","Track already exists.");<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=0;e&lt;this.transceivers.length;e++)<span class="cstat-no" title="statement not covered" >this.transceivers[e].track||this.transceivers[e].kind!==i.kind||(l=this.transceivers[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn l||(l=this._createTransceiver(i.kind)),this._maybeFireNegotiationNeeded(),-1===this.localStreams.indexOf(n)&amp;&amp;this.localStreams.push(n),l.track=i,l.stream=n,l.rtpSender=new t.RTCRtpSender(i,l.dtlsTransport),l.rtpSender}</span>,R.prototype.addStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=15025)<span class="cstat-no" title="statement not covered" >t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >n.addTrack(i,t)}</span>);e</span>lse{var l=<span class="cstat-no" title="statement not covered" >t.clone();<span class="cstat-no" title="statement not covered" ></span>t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >l.getTracks()[i];<span class="cstat-no" title="statement not covered" ></span>t.addEventListener("enabled",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.enabled=t.enabled}</span>)}</span>),l.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.addTrack(t,l)}</span>)}</span>}</span>,R.prototype.removeTrack=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >if(this._isClosed)<span class="cstat-no" title="statement not covered" >throw E("InvalidStateError","Attempted to call removeTrack on a closed peerconnection.");<span class="cstat-no" title="statement not covered" >i</span></span>f(!(i instanceof t.RTCRtpSender))<span class="cstat-no" title="statement not covered" >throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.transceivers.find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.rtpSender===i}</span>);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw E("InvalidAccessError","Sender was not created by this connection.");v</span></span>ar l=<span class="cstat-no" title="statement not covered" >n.stream;<span class="cstat-no" title="statement not covered" ></span>n.rtpSender.stop(),n.rtpSender=null,n.track=null,n.stream=null;v</span>ar p=<span class="cstat-no" title="statement not covered" >this.transceivers.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stream}</span>);<span class="cstat-no" title="statement not covered" ></span>-1===p.indexOf(l)&amp;&amp;this.localStreams.indexOf(l)&gt;-1&amp;&amp;this.localStreams.splice(this.localStreams.indexOf(l),1),this._maybeFireNegotiationNeeded()}</span>,R.prototype.removeStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.getTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >i.getSenders().find(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i.track===t}</span>);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;i.removeTrack(n)}</span>)}</span>,R.prototype.getSenders=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.transceivers.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!!t.rtpSender}</span>).map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.rtpSender}</span>)}</span>,R.prototype.getReceivers=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.transceivers.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!!t.rtpReceiver}</span>).map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.rtpReceiver}</span>)}</span>,R.prototype._createIceGatherer=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){var l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;i&gt;0)<span class="cstat-no" title="statement not covered" >return this.transceivers[0].iceGatherer;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._iceGatherers.length)<span class="cstat-no" title="statement not covered" >return this._iceGatherers.shift();v</span></span>ar p=<span class="cstat-no" title="statement not covered" >new t.RTCIceGatherer({iceServers:this._config.iceServers,gatherPolicy:this._config.iceTransportPolicy});<span class="cstat-no" title="statement not covered" ></span>return Object.defineProperty(p,"state",{value:"new",writable:!0}),this.transceivers[i].bufferedCandidateEvents=[],this.transceivers[i].bufferCandidates=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >!t.candidate||0===Object.keys(t.candidate).length;<span class="cstat-no" title="statement not covered" ></span>p.state=n?"completed":"gathering",null!==l.transceivers[i].bufferedCandidateEvents&amp;&amp;l.transceivers[i].bufferedCandidateEvents.push(t)}</span>,p.addEventListener("localcandidate",this.transceivers[i].bufferCandidates),p}</span>,R.prototype._gather=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){var p=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this.transceivers[n].iceGatherer;<span class="cstat-no" title="statement not covered" ></span>if(!e.onlocalcandidate){var v=<span class="cstat-no" title="statement not covered" >this.transceivers[n].bufferedCandidateEvents;<span class="cstat-no" title="statement not covered" ></span>this.transceivers[n].bufferedCandidateEvents=null,e.removeEventListener("localcandidate",this.transceivers[n].bufferCandidates),e.onlocalcandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!(p.usingBundle&amp;&amp;n&gt;0)){var v=<span class="cstat-no" title="statement not covered" >new Event("icecandidate");<span class="cstat-no" title="statement not covered" ></span>v.candidate={sdpMid:i,sdpMLineIndex:n};v</span>ar T=<span class="cstat-no" title="statement not covered" >t.candidate,</span>E=<span class="cstat-no" title="statement not covered" >!T||0===Object.keys(T).length;<span class="cstat-no" title="statement not covered" ></span>if(E)<span class="cstat-no" title="statement not covered" >"new"!==e.state&amp;&amp;"gathering"!==e.state||(e.state="completed");e</span>lse{<span class="cstat-no" title="statement not covered" >"new"===e.state&amp;&amp;(e.state="gathering"),T.component=1,T.ufrag=e.getLocalParameters().usernameFragment;v</span>ar S=<span class="cstat-no" title="statement not covered" >l.writeCandidate(T);<span class="cstat-no" title="statement not covered" ></span>v.candidate=Object.assign(v.candidate,l.parseCandidate(S)),v.candidate.candidate=S,v.candidate.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{candidate:v.candidate.candidate,sdpMid:v.candidate.sdpMid,sdpMLineIndex:v.candidate.sdpMLineIndex,usernameFragment:v.candidate.usernameFragment}}</span>}</span>v</span>ar R=<span class="cstat-no" title="statement not covered" >l.getMediaSections(p._localDescription.sdp);<span class="cstat-no" title="statement not covered" ></span>R[v.candidate.sdpMLineIndex]+=E?"a=end-of-candidates\r\n":"a="+v.candidate.candidate+"\r\n",p._localDescription.sdp=l.getDescription(p._localDescription.sdp)+R.join("");v</span>ar r=<span class="cstat-no" title="statement not covered" >p.transceivers.every(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.iceGatherer&amp;&amp;"completed"===t.iceGatherer.state}</span>);<span class="cstat-no" title="statement not covered" ></span>"gathering"!==p.iceGatheringState&amp;&amp;(p.iceGatheringState="gathering",p._emitGatheringStateChange()),E||p._dispatchEvent("icecandidate",v),r&amp;&amp;(p._dispatchEvent("icecandidate",new Event("icecandidate")),p.iceGatheringState="complete",p._emitGatheringStateChange())}</span>}</span>,t.setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >v.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.onlocalcandidate(t)}</span>)}</span>,0)}</span>}</span>,R.prototype._createIceAndDtlsTransports=<span class="fstat-no" title="function not covered" >fu</span>nction(){var i=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >new t.RTCIceTransport(null);<span class="cstat-no" title="statement not covered" ></span>n.onicestatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i._updateIceConnectionState(),i._updateConnectionState()}</span>;v</span>ar l=<span class="cstat-no" title="statement not covered" >new t.RTCDtlsTransport(n);<span class="cstat-no" title="statement not covered" ></span>return l.ondtlsstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i._updateConnectionState()}</span>,l.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Object.defineProperty(l,"state",{value:"failed",writable:!0}),i._updateConnectionState()}</span>,{iceTransport:n,dtlsTransport:l}}</span>,R.prototype._disposeIceAndDtlsTransports=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this.transceivers[t].iceGatherer;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(delete i.onlocalcandidate,delete this.transceivers[t].iceGatherer);v</span>ar n=<span class="cstat-no" title="statement not covered" >this.transceivers[t].iceTransport;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(delete n.onicestatechange,delete this.transceivers[t].iceTransport);v</span>ar l=<span class="cstat-no" title="statement not covered" >this.transceivers[t].dtlsTransport;<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;(delete l.ondtlsstatechange,delete l.onerror,delete this.transceivers[t].dtlsTransport)}</span>,R.prototype._transceive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,p){var v=<span class="cstat-no" title="statement not covered" >e(t.localCapabilities,t.remoteCapabilities);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t.rtpSender&amp;&amp;(v.encodings=t.sendEncodingParameters,v.rtcp={cname:l.localCName,compound:t.rtcpParameters.compound},t.recvEncodingParameters.length&amp;&amp;(v.rtcp.ssrc=t.recvEncodingParameters[0].ssrc),t.rtpSender.send(v)),p&amp;&amp;t.rtpReceiver&amp;&amp;v.codecs.length&gt;0&amp;&amp;("video"===t.kind&amp;&amp;t.recvEncodingParameters&amp;&amp;i&lt;15019&amp;&amp;t.recvEncodingParameters.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >delete t.rtx}</span>),t.recvEncodingParameters.length?v.encodings=t.recvEncodingParameters:v.encodings=[{}],v.rtcp={compound:t.rtcpParameters.compound},t.rtcpParameters.cname&amp;&amp;(v.rtcp.cname=t.rtcpParameters.cname),t.sendEncodingParameters.length&amp;&amp;(v.rtcp.ssrc=t.sendEncodingParameters[0].ssrc),t.rtpReceiver.receive(v))}</span>,R.prototype.setLocalDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i,n,p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(-1===["offer","answer"].indexOf(t.type))<span class="cstat-no" title="statement not covered" >return Promise.reject(E("TypeError",'Unsupported type "'+t.type+'"'));<span class="cstat-no" title="statement not covered" >i</span></span>f(!v("setLocalDescription",t.type,p.signalingState)||p._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(E("InvalidStateError","Can not set local "+t.type+" in state "+p.signalingState));<span class="cstat-no" title="statement not covered" >i</span></span>f("offer"===t.type)<span class="cstat-no" title="statement not covered" >i=l.splitSections(t.sdp),n=i.shift(),i.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >l.parseRtpParameters(t);<span class="cstat-no" title="statement not covered" ></span>p.transceivers[i].localCapabilities=n}</span>),p.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >p._gather(t.mid,i)}</span>);e</span>lse <span class="cstat-no" title="statement not covered" >if("answer"===t.type){<span class="cstat-no" title="statement not covered" >i=l.splitSections(p._remoteDescription.sdp),n=i.shift();v</span>ar T=<span class="cstat-no" title="statement not covered" >l.matchPrefix(n,"a=ice-lite").length&gt;0;<span class="cstat-no" title="statement not covered" ></span>i.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var v=<span class="cstat-no" title="statement not covered" >p.transceivers[i],</span>E=<span class="cstat-no" title="statement not covered" >v.iceGatherer,</span>S=<span class="cstat-no" title="statement not covered" >v.iceTransport,</span>R=<span class="cstat-no" title="statement not covered" >v.dtlsTransport,</span>r=<span class="cstat-no" title="statement not covered" >v.localCapabilities,</span>h=<span class="cstat-no" title="statement not covered" >v.remoteCapabilities,</span>u=<span class="cstat-no" title="statement not covered" >l.isRejected(t)&amp;&amp;0===l.matchPrefix(t,"a=bundle-only").length;<span class="cstat-no" title="statement not covered" ></span>if(!u&amp;&amp;!v.rejected){var L=<span class="cstat-no" title="statement not covered" >l.getIceParameters(t,n),</span>M=<span class="cstat-no" title="statement not covered" >l.getDtlsParameters(t,n);<span class="cstat-no" title="statement not covered" ></span>T&amp;&amp;(M.role="server"),p.usingBundle&amp;&amp;0!==i||(p._gather(v.mid,i),"new"===S.state&amp;&amp;S.start(E,L,T?"controlling":"controlled"),"new"===R.state&amp;&amp;R.start(M));v</span>ar f=<span class="cstat-no" title="statement not covered" >e(r,h);<span class="cstat-no" title="statement not covered" ></span>p._transceive(v,f.codecs.length&gt;0,!1)}</span>}</span>)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn p._localDescription={type:t.type,sdp:t.sdp},"offer"===t.type?p._updateSignalingState("have-local-offer"):p._updateSignalingState("stable"),Promise.resolve()}</span>,R.prototype.setRemoteDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(p){var R=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(-1===["offer","answer"].indexOf(p.type))<span class="cstat-no" title="statement not covered" >return Promise.reject(E("TypeError",'Unsupported type "'+p.type+'"'));<span class="cstat-no" title="statement not covered" >i</span></span>f(!v("setRemoteDescription",p.type,R.signalingState)||R._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(E("InvalidStateError","Can not set remote "+p.type+" in state "+R.signalingState));v</span></span>ar r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>R.remoteStreams.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >r[t.id]=t}</span>);v</span>ar h=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >l.splitSections(p.sdp),</span>L=<span class="cstat-no" title="statement not covered" >u.shift(),</span>M=<span class="cstat-no" title="statement not covered" >l.matchPrefix(L,"a=ice-lite").length&gt;0,</span>f=<span class="cstat-no" title="statement not covered" >l.matchPrefix(L,"a=group:BUNDLE ").length&gt;0;<span class="cstat-no" title="statement not covered" ></span>R.usingBundle=f;v</span>ar U=<span class="cstat-no" title="statement not covered" >l.matchPrefix(L,"a=ice-options:")[0];<span class="cstat-no" title="statement not covered" ></span>return R.canTrickleIceCandidates=!!U&amp;&amp;U.substr(14).split(" ").indexOf("trickle")&gt;=0,u.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(v,E){var S=<span class="cstat-no" title="statement not covered" >l.splitLines(v),</span>u=<span class="cstat-no" title="statement not covered" >l.getKind(v),</span>U=<span class="cstat-no" title="statement not covered" >l.isRejected(v)&amp;&amp;0===l.matchPrefix(v,"a=bundle-only").length,</span>b=<span class="cstat-no" title="statement not covered" >S[0].substr(2).split(" ")[2],</span>w=<span class="cstat-no" title="statement not covered" >l.getDirection(v,L),</span>a=<span class="cstat-no" title="statement not covered" >l.parseMsid(v),</span>O=<span class="cstat-no" title="statement not covered" >l.getMid(v)||l.generateIdentifier();<span class="cstat-no" title="statement not covered" ></span>if(U||"application"===u&amp;&amp;("DTLS/SCTP"===b||"UDP/DTLS/SCTP"===b))<span class="cstat-no" title="statement not covered" >R.transceivers[E]={mid:O,kind:u,protocol:b,rejected:!0};e</span>lse{var N,D,A,k,x,H,j,G,V;<span class="cstat-no" title="statement not covered" >!U&amp;&amp;R.transceivers[E]&amp;&amp;R.transceivers[E].rejected&amp;&amp;(R.transceivers[E]=R._createTransceiver(u,!0));v</span>ar W,z,F=<span class="cstat-no" title="statement not covered" >l.parseRtpParameters(v);<span class="cstat-no" title="statement not covered" ></span>U||(W=l.getIceParameters(v,L),(z=l.getDtlsParameters(v,L)).role="client"),j=l.parseRtpEncodingParameters(v);v</span>ar J=<span class="cstat-no" title="statement not covered" >l.parseRtcpParameters(v),</span>Y=<span class="cstat-no" title="statement not covered" >l.matchPrefix(v,"a=end-of-candidates",L).length&gt;0,</span>Q=<span class="cstat-no" title="statement not covered" >l.matchPrefix(v,"a=candidate:").map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return l.parseCandidate(t)}</span>).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 1===t.component}</span>);<span class="cstat-no" title="statement not covered" ></span>if(("offer"===p.type||"answer"===p.type)&amp;&amp;!U&amp;&amp;f&amp;&amp;E&gt;0&amp;&amp;R.transceivers[E]&amp;&amp;(R._disposeIceAndDtlsTransports(E),R.transceivers[E].iceGatherer=R.transceivers[0].iceGatherer,R.transceivers[E].iceTransport=R.transceivers[0].iceTransport,R.transceivers[E].dtlsTransport=R.transceivers[0].dtlsTransport,R.transceivers[E].rtpSender&amp;&amp;R.transceivers[E].rtpSender.setTransport(R.transceivers[0].dtlsTransport),R.transceivers[E].rtpReceiver&amp;&amp;R.transceivers[E].rtpReceiver.setTransport(R.transceivers[0].dtlsTransport)),"offer"!==p.type||U){<span class="cstat-no" title="statement not covered" >if("answer"===p.type&amp;&amp;!U){<span class="cstat-no" title="statement not covered" >N=R.transceivers[E],D=N.iceGatherer,A=N.iceTransport,k=N.dtlsTransport,x=N.rtpReceiver,H=N.sendEncodingParameters,G=N.localCapabilities,R.transceivers[E].recvEncodingParameters=j,R.transceivers[E].remoteCapabilities=F,R.transceivers[E].rtcpParameters=J,Q.length&amp;&amp;"new"===A.state&amp;&amp;(!M&amp;&amp;!Y||f&amp;&amp;0!==E?Q.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >T(N.iceTransport,t)}</span>):A.setRemoteCandidates(Q)),f&amp;&amp;0!==E||("new"===A.state&amp;&amp;A.start(D,W,"controlling"),"new"===k.state&amp;&amp;k.start(z));v</span>ar Z=<span class="cstat-no" title="statement not covered" >e(N.localCapabilities,N.remoteCapabilities),</span>K=<span class="cstat-no" title="statement not covered" >Z.codecs.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"rtx"===t.name.toLowerCase()}</span>).length;<span class="cstat-no" title="statement not covered" ></span>!K&amp;&amp;N.sendEncodingParameters[0].rtx&amp;&amp;delete N.sendEncodingParameters[0].rtx,R._transceive(N,"sendrecv"===w||"recvonly"===w,"sendrecv"===w||"sendonly"===w),!x||"sendrecv"!==w&amp;&amp;"sendonly"!==w?delete N.rtpReceiver:(V=x.track,a?(r[a.stream]||(r[a.stream]=new t.MediaStream),n(V,r[a.stream]),h.push([V,x,r[a.stream]])):(r.default||(r.default=new t.MediaStream),n(V,r.default),h.push([V,x,r.default])))}</span>}</span>else{<span class="cstat-no" title="statement not covered" >(N=R.transceivers[E]||R._createTransceiver(u)).mid=O,N.iceGatherer||(N.iceGatherer=R._createIceGatherer(E,f)),Q.length&amp;&amp;"new"===N.iceTransport.state&amp;&amp;(!Y||f&amp;&amp;0!==E?Q.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >T(N.iceTransport,t)}</span>):N.iceTransport.setRemoteCandidates(Q)),G=t.RTCRtpReceiver.getCapabilities(u),i&lt;15019&amp;&amp;(G.codecs=G.codecs.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"rtx"!==t.name}</span>)),H=N.sendEncodingParameters||[{ssrc:1001*(2*E+2)}];v</span>ar X,$=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>"sendrecv"===w||"sendonly"===w?($=!N.rtpReceiver,x=N.rtpReceiver||new t.RTCRtpReceiver(N.dtlsTransport,u),$&amp;&amp;(V=x.track,a&amp;&amp;"-"===a.stream||(a?(r[a.stream]||(r[a.stream]=new t.MediaStream,Object.defineProperty(r[a.stream],"id",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.stream}</span>})),Object.defineProperty(V,"id",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.track}</span>}),X=r[a.stream]):(r.default||(r.default=new t.MediaStream),X=r.default)),X&amp;&amp;(n(V,X),N.associatedRemoteMediaStreams.push(X)),h.push([V,x,X]))):N.rtpReceiver&amp;&amp;N.rtpReceiver.track&amp;&amp;(N.associatedRemoteMediaStreams.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n,l,p=<span class="cstat-no" title="statement not covered" >i.getTracks().find(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.id===N.rtpReceiver.track.id}</span>);<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(n=p,(l=i).removeTrack(n),l.dispatchEvent(new t.MediaStreamTrackEvent("removetrack",{track:n})))}</span>),N.associatedRemoteMediaStreams=[]),N.localCapabilities=G,N.remoteCapabilities=F,N.rtpReceiver=x,N.rtcpParameters=J,N.sendEncodingParameters=H,N.recvEncodingParameters=j,R._transceive(R.transceivers[E],!1,$)}</span>}</span>}</span>),void 0===R._dtlsRole&amp;&amp;(R._dtlsRole="offer"===p.type?"active":"passive"),R._remoteDescription={type:p.type,sdp:p.sdp},"offer"===p.type?R._updateSignalingState("have-remote-offer"):R._updateSignalingState("stable"),Object.keys(r).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >r[i];<span class="cstat-no" title="statement not covered" ></span>if(n.getTracks().length){<span class="cstat-no" title="statement not covered" >if(-1===R.remoteStreams.indexOf(n)){<span class="cstat-no" title="statement not covered" >R.remoteStreams.push(n);v</span>ar l=<span class="cstat-no" title="statement not covered" >new Event("addstream");<span class="cstat-no" title="statement not covered" ></span>l.stream=n,t.setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >R._dispatchEvent("addstream",l)}</span>)}<span class="cstat-no" title="statement not covered" ></span>h</span>.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t[0],</span>l=<span class="cstat-no" title="statement not covered" >t[1];<span class="cstat-no" title="statement not covered" ></span>n.id===t[2].id&amp;&amp;S(R,i,l,[n])}</span>)}</span>}</span>),h.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t[2]||S(R,t[0],t[1],[])}</span>),t.setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >R&amp;&amp;R.transceivers&amp;&amp;R.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.iceTransport&amp;&amp;"new"===t.iceTransport.state&amp;&amp;t.iceTransport.getRemoteCandidates().length&gt;0&amp;&amp;(console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"),t.iceTransport.addRemoteCandidate({}))}</span>)}</span>,4e3),Promise.resolve()}</span>,R.prototype.close=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.iceTransport&amp;&amp;t.iceTransport.stop(),t.dtlsTransport&amp;&amp;t.dtlsTransport.stop(),t.rtpSender&amp;&amp;t.rtpSender.stop(),t.rtpReceiver&amp;&amp;t.rtpReceiver.stop()}</span>),this._isClosed=!0,this._updateSignalingState("closed")}</span>,R.prototype._updateSignalingState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.signalingState=t;v</span>ar i=<span class="cstat-no" title="statement not covered" >new Event("signalingstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("signalingstatechange",i)}</span>,R.prototype._maybeFireNegotiationNeeded=<span class="fstat-no" title="function not covered" >fu</span>nction(){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>"stable"===this.signalingState&amp;&amp;!0!==this.needNegotiation&amp;&amp;(this.needNegotiation=!0,t.setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(i.needNegotiation){<span class="cstat-no" title="statement not covered" >i.needNegotiation=!1;v</span>ar t=<span class="cstat-no" title="statement not covered" >new Event("negotiationneeded");<span class="cstat-no" title="statement not covered" ></span>i._dispatchEvent("negotiationneeded",t)}</span>}</span>,0))}</span>,R.prototype._updateIceConnectionState=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,i=<span class="cstat-no" title="statement not covered" >{new:0,closed:0,checking:0,connected:0,completed:0,disconnected:0,failed:0};<span class="cstat-no" title="statement not covered" ></span>if(this.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.iceTransport&amp;&amp;!t.rejected&amp;&amp;i[t.iceTransport.state]++}</span>),t="new",i.failed&gt;0?t="failed":i.checking&gt;0?t="checking":i.disconnected&gt;0?t="disconnected":i.new&gt;0?t="new":i.connected&gt;0?t="connected":i.completed&gt;0&amp;&amp;(t="completed"),t!==this.iceConnectionState){<span class="cstat-no" title="statement not covered" >this.iceConnectionState=t;v</span>ar n=<span class="cstat-no" title="statement not covered" >new Event("iceconnectionstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("iceconnectionstatechange",n)}</span>}</span>,R.prototype._updateConnectionState=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,i=<span class="cstat-no" title="statement not covered" >{new:0,closed:0,connecting:0,connected:0,completed:0,disconnected:0,failed:0};<span class="cstat-no" title="statement not covered" ></span>if(this.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.iceTransport&amp;&amp;t.dtlsTransport&amp;&amp;!t.rejected&amp;&amp;(i[t.iceTransport.state]++,i[t.dtlsTransport.state]++)}</span>),i.connected+=i.completed,t="new",i.failed&gt;0?t="failed":i.connecting&gt;0?t="connecting":i.disconnected&gt;0?t="disconnected":i.new&gt;0?t="new":i.connected&gt;0&amp;&amp;(t="connected"),t!==this.connectionState){<span class="cstat-no" title="statement not covered" >this.connectionState=t;v</span>ar n=<span class="cstat-no" title="statement not covered" >new Event("connectionstatechange");<span class="cstat-no" title="statement not covered" ></span>this._dispatchEvent("connectionstatechange",n)}</span>}</span>,R.prototype.createOffer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(n._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(E("InvalidStateError","Can not call createOffer after close"));v</span></span>ar e=<span class="cstat-no" title="statement not covered" >n.transceivers.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"audio"===t.kind}</span>).length,</span>v=<span class="cstat-no" title="statement not covered" >n.transceivers.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"video"===t.kind}</span>).length,</span>T=<span class="cstat-no" title="statement not covered" >arguments[0];<span class="cstat-no" title="statement not covered" ></span>if(T){<span class="cstat-no" title="statement not covered" >if(T.mandatory||T.optional)<span class="cstat-no" title="statement not covered" >throw new TypeError("Legacy mandatory/optional constraints not supported.");<span class="cstat-no" title="statement not covered" >v</span></span>oid 0!==T.offerToReceiveAudio&amp;&amp;(e=!0===T.offerToReceiveAudio?1:!1===T.offerToReceiveAudio?0:T.offerToReceiveAudio),void 0!==T.offerToReceiveVideo&amp;&amp;(v=!0===T.offerToReceiveVideo?1:!1===T.offerToReceiveVideo?0:T.offerToReceiveVideo)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(n.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"audio"===t.kind?--e&lt;0&amp;&amp;(t.wantReceive=!1):"video"===t.kind&amp;&amp;--v&lt;0&amp;&amp;(t.wantReceive=!1)}</span>);e&gt;0||v&gt;0;)<span class="cstat-no" title="statement not covered" >e&gt;0&amp;&amp;(n._createTransceiver("audio"),e--),v&gt;0&amp;&amp;(n._createTransceiver("video"),v--);v</span></span>ar S=<span class="cstat-no" title="statement not covered" >l.writeSessionBoilerplate(n._sdpSessionId,n._sdpSessionVersion++);<span class="cstat-no" title="statement not covered" ></span>n.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(p,e){var v=<span class="cstat-no" title="statement not covered" >p.track,</span>T=<span class="cstat-no" title="statement not covered" >p.kind,</span>E=<span class="cstat-no" title="statement not covered" >p.mid||l.generateIdentifier();<span class="cstat-no" title="statement not covered" ></span>p.mid=E,p.iceGatherer||(p.iceGatherer=n._createIceGatherer(e,n.usingBundle));v</span>ar S=<span class="cstat-no" title="statement not covered" >t.RTCRtpSender.getCapabilities(T);<span class="cstat-no" title="statement not covered" ></span>i&lt;15019&amp;&amp;(S.codecs=S.codecs.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"rtx"!==t.name}</span>)),S.codecs.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"H264"===t.name&amp;&amp;void 0===t.parameters["level-asymmetry-allowed"]&amp;&amp;(t.parameters["level-asymmetry-allowed"]="1"),p.remoteCapabilities&amp;&amp;p.remoteCapabilities.codecs&amp;&amp;p.remoteCapabilities.codecs.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.name.toLowerCase()===i.name.toLowerCase()&amp;&amp;t.clockRate===i.clockRate&amp;&amp;(t.preferredPayloadType=i.payloadType)}</span>)}</span>),S.headerExtensions.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >p.remoteCapabilities&amp;&amp;p.remoteCapabilities.headerExtensions||[];<span class="cstat-no" title="statement not covered" ></span>i.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.uri===i.uri&amp;&amp;(t.id=i.id)}</span>)}</span>);v</span>ar R=<span class="cstat-no" title="statement not covered" >p.sendEncodingParameters||[{ssrc:1001*(2*e+1)}];<span class="cstat-no" title="statement not covered" ></span>v&amp;&amp;i&gt;=15019&amp;&amp;"video"===T&amp;&amp;!R[0].rtx&amp;&amp;(R[0].rtx={ssrc:R[0].ssrc+1}),p.wantReceive&amp;&amp;(p.rtpReceiver=new t.RTCRtpReceiver(p.dtlsTransport,T)),p.localCapabilities=S,p.sendEncodingParameters=R}</span>),"max-compat"!==n._config.bundlePolicy&amp;&amp;(S+="a=group:BUNDLE "+n.transceivers.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.mid}</span>).join(" ")+"\r\n"),S+="a=ice-options:trickle\r\n",n.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >S+=p(t,t.localCapabilities,"offer",t.stream,n._dtlsRole),S+="a=rtcp-rsize\r\n",!t.iceGatherer||"new"===n.iceGatheringState||0!==i&amp;&amp;n.usingBundle||(t.iceGatherer.getLocalCandidates().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.component=1,S+="a="+l.writeCandidate(t)+"\r\n"}</span>),"completed"===t.iceGatherer.state&amp;&amp;(S+="a=end-of-candidates\r\n"))}</span>);v</span>ar R=<span class="cstat-no" title="statement not covered" >new t.RTCSessionDescription({type:"offer",sdp:S});<span class="cstat-no" title="statement not covered" ></span>return Promise.resolve(R)}</span>,R.prototype.createAnswer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(n._isClosed)<span class="cstat-no" title="statement not covered" >return Promise.reject(E("InvalidStateError","Can not call createAnswer after close"));<span class="cstat-no" title="statement not covered" >i</span></span>f("have-remote-offer"!==n.signalingState&amp;&amp;"have-local-pranswer"!==n.signalingState)<span class="cstat-no" title="statement not covered" >return Promise.reject(E("InvalidStateError","Can not call createAnswer in signalingState "+n.signalingState));v</span></span>ar v=<span class="cstat-no" title="statement not covered" >l.writeSessionBoilerplate(n._sdpSessionId,n._sdpSessionVersion++);<span class="cstat-no" title="statement not covered" ></span>n.usingBundle&amp;&amp;(v+="a=group:BUNDLE "+n.transceivers.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.mid}</span>).join(" ")+"\r\n"),v+="a=ice-options:trickle\r\n";v</span>ar T=<span class="cstat-no" title="statement not covered" >l.getMediaSections(n._remoteDescription.sdp).length;<span class="cstat-no" title="statement not covered" ></span>n.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,l){<span class="cstat-no" title="statement not covered" >if(!(l+1&gt;T)){<span class="cstat-no" title="statement not covered" >if(t.rejected)<span class="cstat-no" title="statement not covered" >return"application"===t.kind?"DTLS/SCTP"===t.protocol?v+="m=application 0 DTLS/SCTP 5000\r\n":v+="m=application 0 "+t.protocol+" webrtc-datachannel\r\n":"audio"===t.kind?v+="m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n":"video"===t.kind&amp;&amp;(v+="m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"),void(v+="c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:"+t.mid+"\r\n");v</span></span>ar E;<span class="cstat-no" title="statement not covered" >t.stream&amp;&amp;("audio"===t.kind?E=t.stream.getAudioTracks()[0]:"video"===t.kind&amp;&amp;(E=t.stream.getVideoTracks()[0]),E&amp;&amp;i&gt;=15019&amp;&amp;"video"===t.kind&amp;&amp;!t.sendEncodingParameters[0].rtx&amp;&amp;(t.sendEncodingParameters[0].rtx={ssrc:t.sendEncodingParameters[0].ssrc+1}));v</span>ar S=<span class="cstat-no" title="statement not covered" >e(t.localCapabilities,t.remoteCapabilities),</span>R=<span class="cstat-no" title="statement not covered" >S.codecs.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"rtx"===t.name.toLowerCase()}</span>).length;<span class="cstat-no" title="statement not covered" ></span>!R&amp;&amp;t.sendEncodingParameters[0].rtx&amp;&amp;delete t.sendEncodingParameters[0].rtx,v+=p(t,S,"answer",t.stream,n._dtlsRole),t.rtcpParameters&amp;&amp;t.rtcpParameters.reducedSize&amp;&amp;(v+="a=rtcp-rsize\r\n")}</span>}</span>);v</span>ar S=<span class="cstat-no" title="statement not covered" >new t.RTCSessionDescription({type:"answer",sdp:v});<span class="cstat-no" title="statement not covered" ></span>return Promise.resolve(S)}</span>,R.prototype.addIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i,n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;void 0===t.sdpMLineIndex&amp;&amp;!t.sdpMid?Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")):new Promise(<span class="fstat-no" title="function not covered" >fu</span>nction(p,e){<span class="cstat-no" title="statement not covered" >if(!n._remoteDescription)<span class="cstat-no" title="statement not covered" >return e(E("InvalidStateError","Can not add ICE candidate without a remote description"));<span class="cstat-no" title="statement not covered" >i</span></span>f(t&amp;&amp;""!==t.candidate){var v=<span class="cstat-no" title="statement not covered" >t.sdpMLineIndex;<span class="cstat-no" title="statement not covered" ></span>if(t.sdpMid)<span class="cstat-no" title="statement not covered" >for(var S=0;S&lt;n.transceivers.length;S++)<span class="cstat-no" title="statement not covered" >if(n.transceivers[S].mid===t.sdpMid){<span class="cstat-no" title="statement not covered" >v=S;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>v</span></span></span>ar R=<span class="cstat-no" title="statement not covered" >n.transceivers[v];<span class="cstat-no" title="statement not covered" ></span>if(!R)<span class="cstat-no" title="statement not covered" >return e(E("OperationError","Can not add ICE candidate"));<span class="cstat-no" title="statement not covered" >i</span></span>f(R.rejected)<span class="cstat-no" title="statement not covered" >return p();v</span></span>ar r=<span class="cstat-no" title="statement not covered" >Object.keys(t.candidate).length&gt;0?l.parseCandidate(t.candidate):{};<span class="cstat-no" title="statement not covered" ></span>if("tcp"===r.protocol&amp;&amp;(0===r.port||9===r.port))<span class="cstat-no" title="statement not covered" >return p();<span class="cstat-no" title="statement not covered" >i</span></span>f(r.component&amp;&amp;1!==r.component)<span class="cstat-no" title="statement not covered" >return p();<span class="cstat-no" title="statement not covered" >i</span></span>f((0===v||v&gt;0&amp;&amp;R.iceTransport!==n.transceivers[0].iceTransport)&amp;&amp;!T(R.iceTransport,r))<span class="cstat-no" title="statement not covered" >return e(E("OperationError","Can not add ICE candidate"));v</span></span>ar h=<span class="cstat-no" title="statement not covered" >t.candidate.trim();<span class="cstat-no" title="statement not covered" ></span>0===h.indexOf("a=")&amp;&amp;(h=h.substr(2)),(i=l.getMediaSections(n._remoteDescription.sdp))[v]+="a="+(r.type?h:"end-of-candidates")+"\r\n",n._remoteDescription.sdp=l.getDescription(n._remoteDescription.sdp)+i.join("")}</span>else <span class="cstat-no" title="statement not covered" >for(var u=0;u&lt;n.transceivers.length&amp;&amp;(n.transceivers[u].rejected||(n.transceivers[u].iceTransport.addRemoteCandidate({}),(i=l.getMediaSections(n._remoteDescription.sdp))[u]+="a=end-of-candidates\r\n",n._remoteDescription.sdp=l.getDescription(n._remoteDescription.sdp)+i.join(""),!n.usingBundle));u++);<span class="cstat-no" title="statement not covered" >p</span></span>()}</span>)}</span>,R.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >if(i&amp;&amp;i instanceof t.MediaStreamTrack){var n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.rtpSender&amp;&amp;t.rtpSender.track===i?n=t.rtpSender:t.rtpReceiver&amp;&amp;t.rtpReceiver.track===i&amp;&amp;(n=t.rtpReceiver)}</span>),!n)<span class="cstat-no" title="statement not covered" >throw E("InvalidAccessError","Invalid selector.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.getStats()}</span>v</span>ar l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.transceivers.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >["rtpSender","rtpReceiver","iceGatherer","iceTransport","dtlsTransport"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t[i]&amp;&amp;l.push(t[i].getStats())}</span>)}</span>),Promise.all(l).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.set(t.id,t)}</span>)}</span>),i}</span>)}</span>,["RTCRtpSender","RTCRtpReceiver","RTCIceGatherer","RTCIceTransport","RTCDtlsTransport"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >t[i];<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n.prototype&amp;&amp;n.prototype.getStats){var l=<span class="cstat-no" title="statement not covered" >n.prototype.getStats;<span class="cstat-no" title="statement not covered" ></span>n.prototype.getStats=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return l.apply(this).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(n){var l;<span class="cstat-no" title="statement not covered" >t[n].type={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[(l=t[n]).type]||l.type,i.set(n,t[n])}</span>),i}</span>)}</span>}</span>}</span>);v</span>ar r=<span class="cstat-no" title="statement not covered" >["createOffer","createAnswer"];<span class="cstat-no" title="statement not covered" ></span>return r.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >R.prototype[t];<span class="cstat-no" title="statement not covered" ></span>R.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof t[0]||"function"==typeof t[1]?i.apply(this,[arguments[2]]).then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >"function"==typeof t[0]&amp;&amp;t[0].apply(null,[i])}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >"function"==typeof t[1]&amp;&amp;t[1].apply(null,[i])}</span>):i.apply(this,arguments)}</span>}</span>),(r=["setLocalDescription","setRemoteDescription","addIceCandidate"]).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >R.prototype[t];<span class="cstat-no" title="statement not covered" ></span>R.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof t[1]||"function"==typeof t[2]?i.apply(this,arguments).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"function"==typeof t[1]&amp;&amp;t[1].apply(null)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >"function"==typeof t[2]&amp;&amp;t[2].apply(null,[i])}</span>):i.apply(this,arguments)}</span>}</span>),["getStats"].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >R.prototype[t];<span class="cstat-no" title="statement not covered" ></span>R.prototype[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof t[1]?i.apply(this,arguments).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"function"==typeof t[1]&amp;&amp;t[1].apply(null)}</span>):i.apply(this,arguments)}</span>}</span>),R}</span>},{sdp:17}],17:[function(t,i,n){"use strict";var l={generateIdentifier:function(){return Math.random().toString(36).substr(2,10)}};l.localCName=l.generateIdentifier(),l.splitLines=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.trim().split("\n").map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.trim()}</span>)}</span>,l.splitSections=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.split("\nm=");<span class="cstat-no" title="statement not covered" ></span>return i.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return(i&gt;0?"m="+t:t).trim()+"\r\n"}</span>)}</span>,l.getDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >l.splitSections(t);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;i[0]}</span>,l.getMediaSections=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >l.splitSections(t);<span class="cstat-no" title="statement not covered" ></span>return i.shift(),i}</span>,l.matchPrefix=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return l.splitLines(t).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0===t.indexOf(i)}</span>)}</span>,l.parseCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i,n={foundation:(i=0===t.indexOf("a=candidate:")?t.substring(12).split(" "):t.substring(10).split(" "))[0],component:parseInt(i[1],10),protocol:i[2].toLowerCase(),priority:parseInt(i[3],10),ip:i[4],address:i[4],port:parseInt(i[5],10),type:i[7]},l=8;l&lt;i.length;l+=2)<span class="cstat-no" title="statement not covered" >switch(i[l]){case"raddr":<span class="cstat-no" title="statement not covered" >n.relatedAddress=i[l+1];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rport":<span class="cstat-no" title="statement not covered" >n.relatedPort=parseInt(i[l+1],10);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"tcptype":<span class="cstat-no" title="statement not covered" >n.tcpType=i[l+1];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ufrag":<span class="cstat-no" title="statement not covered" >n.ufrag=i[l+1],n.usernameFragment=i[l+1];<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >n[i[l]]=i[l+1]}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn n}</span>,l.writeCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.push(t.foundation),i.push(t.component),i.push(t.protocol.toUpperCase()),i.push(t.priority),i.push(t.address||t.ip),i.push(t.port);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.type;<span class="cstat-no" title="statement not covered" ></span>return i.push("typ"),i.push(n),"host"!==n&amp;&amp;t.relatedAddress&amp;&amp;t.relatedPort&amp;&amp;(i.push("raddr"),i.push(t.relatedAddress),i.push("rport"),i.push(t.relatedPort)),t.tcpType&amp;&amp;"tcp"===t.protocol.toLowerCase()&amp;&amp;(i.push("tcptype"),i.push(t.tcpType)),(t.usernameFragment||t.ufrag)&amp;&amp;(i.push("ufrag"),i.push(t.usernameFragment||t.ufrag)),"candidate:"+i.join(" ")}</span>,l.parseIceOptions=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.substr(14).split(" ")}</span>,l.parseRtpMap=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.substr(9).split(" "),</span>n=<span class="cstat-no" title="statement not covered" >{payloadType:parseInt(i.shift(),10)};<span class="cstat-no" title="statement not covered" ></span>return i=i[0].split("/"),n.name=i[0],n.clockRate=parseInt(i[1],10),n.channels=3===i.length?parseInt(i[2],10):1,n.numChannels=n.channels,n}</span>,l.writeRtpMap=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.payloadType;<span class="cstat-no" title="statement not covered" ></span>void 0!==t.preferredPayloadType&amp;&amp;(i=t.preferredPayloadType);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.channels||t.numChannels||1;<span class="cstat-no" title="statement not covered" ></span>return"a=rtpmap:"+i+" "+t.name+"/"+t.clockRate+(1!==n?"/"+n:"")+"\r\n"}</span>,l.parseExtmap=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.substr(9).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{id:parseInt(i[0],10),direction:i[0].indexOf("/")&gt;0?i[0].split("/")[1]:"sendrecv",uri:i[1]}}</span>,l.writeExtmap=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"a=extmap:"+(t.id||t.preferredId)+(t.direction&amp;&amp;"sendrecv"!==t.direction?"/"+t.direction:"")+" "+t.uri+"\r\n"}</span>,l.parseFmtp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i,n={},l=t.substr(t.indexOf(" ")+1).split(";"),p=0;p&lt;l.length;p++)<span class="cstat-no" title="statement not covered" >i=l[p].trim().split("="),n[i[0].trim()]=i[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,l.writeFmtp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >"",</span>n=<span class="cstat-no" title="statement not covered" >t.payloadType;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t.preferredPayloadType&amp;&amp;(n=t.preferredPayloadType),t.parameters&amp;&amp;Object.keys(t.parameters).length){var l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>Object.keys(t.parameters).forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.parameters[i]?l.push(i+"="+t.parameters[i]):l.push(i)}</span>),i+="a=fmtp:"+n+" "+l.join(";")+"\r\n"}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>,l.parseRtcpFb=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.substr(t.indexOf(" ")+1).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{type:i.shift(),parameter:i.join(" ")}}</span>,l.writeRtcpFb=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >"",</span>n=<span class="cstat-no" title="statement not covered" >t.payloadType;<span class="cstat-no" title="statement not covered" ></span>return void 0!==t.preferredPayloadType&amp;&amp;(n=t.preferredPayloadType),t.rtcpFeedback&amp;&amp;t.rtcpFeedback.length&amp;&amp;t.rtcpFeedback.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i+="a=rtcp-fb:"+n+" "+t.type+(t.parameter&amp;&amp;t.parameter.length?" "+t.parameter:"")+"\r\n"}</span>),i}</span>,l.parseSsrcMedia=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.indexOf(" "),</span>n=<span class="cstat-no" title="statement not covered" >{ssrc:parseInt(t.substr(7,i-7),10)},</span>l=<span class="cstat-no" title="statement not covered" >t.indexOf(":",i);<span class="cstat-no" title="statement not covered" ></span>return l&gt;-1?(n.attribute=t.substr(i+1,l-i-1),n.value=t.substr(l+1)):n.attribute=t.substr(i+1),n}</span>,l.parseSsrcGroup=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.substr(13).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{semantics:i.shift(),ssrcs:i.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return parseInt(t,10)}</span>)}}</span>,l.getMid=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=mid:")[0];<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i.substr(6)}</span></span>,l.parseFingerprint=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.substr(14).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{algorithm:i[0].toLowerCase(),value:i[1]}}</span>,l.getDtlsParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t+i,"a=fingerprint:");<span class="cstat-no" title="statement not covered" ></span>return{role:"auto",fingerprints:n.map(l.parseFingerprint)}}</span>,l.writeDtlsParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >"a=setup:"+i+"\r\n";<span class="cstat-no" title="statement not covered" ></span>return t.fingerprints.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n+="a=fingerprint:"+t.algorithm+" "+t.value+"\r\n"}</span>),n}</span>,l.getIceParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >l.splitLines(t),</span>p=<span class="cstat-no" title="statement not covered" >{usernameFragment:(n=n.concat(l.splitLines(i))).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0===t.indexOf("a=ice-ufrag:")}</span>)[0].substr(12),password:n.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0===t.indexOf("a=ice-pwd:")}</span>)[0].substr(10)};<span class="cstat-no" title="statement not covered" ></span>return p}</span>,l.writeIceParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"a=ice-ufrag:"+t.usernameFragment+"\r\na=ice-pwd:"+t.password+"\r\n"}</span>,l.parseRtpParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},n=l.splitLines(t),p=n[0].split(" "),e=3;e&lt;p.length;e++){var v=<span class="cstat-no" title="statement not covered" >p[e],</span>T=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=rtpmap:"+v+" ")[0];<span class="cstat-no" title="statement not covered" ></span>if(T){var E=<span class="cstat-no" title="statement not covered" >l.parseRtpMap(T),</span>S=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=fmtp:"+v+" ");<span class="cstat-no" title="statement not covered" ></span>switch(E.parameters=S.length?l.parseFmtp(S[0]):{},E.rtcpFeedback=l.matchPrefix(t,"a=rtcp-fb:"+v+" ").map(l.parseRtcpFb),i.codecs.push(E),E.name.toUpperCase()){case"RED":case"ULPFEC":<span class="cstat-no" title="statement not covered" >i.fecMechanisms.push(E.name.toUpperCase())}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l.matchPrefix(t,"a=extmap:").forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.headerExtensions.push(l.parseExtmap(t))}</span>),i}</span>,l.writeRtpDescription=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>n+="m="+t+" ",n+=i.codecs.length&gt;0?"9":"0",n+=" UDP/TLS/RTP/SAVPF ",n+=i.codecs.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return void 0!==t.preferredPayloadType?t.preferredPayloadType:t.payloadType}</span>).join(" ")+"\r\n",n+="c=IN IP4 0.0.0.0\r\n",n+="a=rtcp:9 IN IP4 0.0.0.0\r\n",i.codecs.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n+=l.writeRtpMap(t),n+=l.writeFmtp(t),n+=l.writeRtcpFb(t)}</span>);v</span>ar p=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return i.codecs.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.maxptime&gt;p&amp;&amp;(p=t.maxptime)}</span>),p&gt;0&amp;&amp;(n+="a=maxptime:"+p+"\r\n"),n+="a=rtcp-mux\r\n",i.headerExtensions&amp;&amp;i.headerExtensions.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n+=l.writeExtmap(t)}</span>),n}</span>,l.parseRtpEncodingParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i,n=<span class="cstat-no" title="statement not covered" >[],</span>p=<span class="cstat-no" title="statement not covered" >l.parseRtpParameters(t),</span>e=<span class="cstat-no" title="statement not covered" >-1!==p.fecMechanisms.indexOf("RED"),</span>v=<span class="cstat-no" title="statement not covered" >-1!==p.fecMechanisms.indexOf("ULPFEC"),</span>T=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=ssrc:").map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return l.parseSsrcMedia(t)}</span>).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"cname"===t.attribute}</span>),</span>E=<span class="cstat-no" title="statement not covered" >T.length&gt;0&amp;&amp;T[0].ssrc,</span>S=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=ssrc-group:FID").map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.substr(17).split(" ");<span class="cstat-no" title="statement not covered" ></span>return i.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return parseInt(t,10)}</span>)}</span>);<span class="cstat-no" title="statement not covered" ></span>S.length&gt;0&amp;&amp;S[0].length&gt;1&amp;&amp;S[0][0]===E&amp;&amp;(i=S[0][1]),p.codecs.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("RTX"===t.name.toUpperCase()&amp;&amp;t.parameters.apt){var l=<span class="cstat-no" title="statement not covered" >{ssrc:E,codecPayloadType:parseInt(t.parameters.apt,10)};<span class="cstat-no" title="statement not covered" ></span>E&amp;&amp;i&amp;&amp;(l.rtx={ssrc:i}),n.push(l),e&amp;&amp;((l=JSON.parse(JSON.stringify(l))).fec={ssrc:E,mechanism:v?"red+ulpfec":"red"},n.push(l))}</span>}</span>),0===n.length&amp;&amp;E&amp;&amp;n.push({ssrc:E});v</span>ar R=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"b=");<span class="cstat-no" title="statement not covered" ></span>return R.length&amp;&amp;(R=0===R[0].indexOf("b=TIAS:")?parseInt(R[0].substr(7),10):0===R[0].indexOf("b=AS:")?1e3*parseInt(R[0].substr(5),10)*.95-16e3:void 0,n.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.maxBitrate=R}</span>)),n}</span>,l.parseRtcpParameters=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=ssrc:").map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return l.parseSsrcMedia(t)}</span>).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"cname"===t.attribute}</span>)[0];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(i.cname=n.value,i.ssrc=n.ssrc);v</span>ar p=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=rtcp-rsize");<span class="cstat-no" title="statement not covered" ></span>i.reducedSize=p.length&gt;0,i.compound=0===p.length;v</span>ar e=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=rtcp-mux");<span class="cstat-no" title="statement not covered" ></span>return i.mux=e.length&gt;0,i}</span>,l.parseMsid=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i,n=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=msid:");<span class="cstat-no" title="statement not covered" ></span>if(1===n.length)<span class="cstat-no" title="statement not covered" >return{stream:(i=n[0].substr(7).split(" "))[0],track:i[1]};v</span></span>ar p=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"a=ssrc:").map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return l.parseSsrcMedia(t)}</span>).filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"msid"===t.attribute}</span>);<span class="cstat-no" title="statement not covered" ></span>return p.length&gt;0?{stream:(i=p[0].value.split(" "))[0],track:i[1]}:void 0}</span>,l.generateSessionId=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Math.random().toString().substr(2,21)}</span>,l.writeSessionBoilerplate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var p,e=<span class="cstat-no" title="statement not covered" >void 0!==i?i:2;<span class="cstat-no" title="statement not covered" ></span>p=t||l.generateSessionId();v</span>ar v=<span class="cstat-no" title="statement not covered" >n||"thisisadapterortc";<span class="cstat-no" title="statement not covered" ></span>return"v=0\r\no="+v+" "+p+" "+e+" IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"}</span>,l.writeMediaSection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p){var e=<span class="cstat-no" title="statement not covered" >l.writeRtpDescription(t.kind,i);<span class="cstat-no" title="statement not covered" ></span>if(e+=l.writeIceParameters(t.iceGatherer.getLocalParameters()),e+=l.writeDtlsParameters(t.dtlsTransport.getLocalParameters(),"offer"===n?"actpass":"active"),e+="a=mid:"+t.mid+"\r\n",t.direction?e+="a="+t.direction+"\r\n":t.rtpSender&amp;&amp;t.rtpReceiver?e+="a=sendrecv\r\n":t.rtpSender?e+="a=sendonly\r\n":t.rtpReceiver?e+="a=recvonly\r\n":e+="a=inactive\r\n",t.rtpSender){var v=<span class="cstat-no" title="statement not covered" >"msid:"+p.id+" "+t.rtpSender.track.id+"\r\n";<span class="cstat-no" title="statement not covered" ></span>e+="a="+v,e+="a=ssrc:"+t.sendEncodingParameters[0].ssrc+" "+v,t.sendEncodingParameters[0].rtx&amp;&amp;(e+="a=ssrc:"+t.sendEncodingParameters[0].rtx.ssrc+" "+v,e+="a=ssrc-group:FID "+t.sendEncodingParameters[0].ssrc+" "+t.sendEncodingParameters[0].rtx.ssrc+"\r\n")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e+="a=ssrc:"+t.sendEncodingParameters[0].ssrc+" cname:"+l.localCName+"\r\n",t.rtpSender&amp;&amp;t.sendEncodingParameters[0].rtx&amp;&amp;(e+="a=ssrc:"+t.sendEncodingParameters[0].rtx.ssrc+" cname:"+l.localCName+"\r\n"),e}</span>,l.getDirection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >for(var n=l.splitLines(t),p=0;p&lt;n.length;p++)<span class="cstat-no" title="statement not covered" >switch(n[p]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":<span class="cstat-no" title="statement not covered" >return n[p].substr(2)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn i?l.getDirection(i):"sendrecv"}</span>,l.getKind=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >l.splitLines(t),</span>n=<span class="cstat-no" title="statement not covered" >i[0].split(" ");<span class="cstat-no" title="statement not covered" ></span>return n[0].substr(2)}</span>,l.isRejected=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"0"===t.split(" ",2)[1]}</span>,l.parseMLine=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >l.splitLines(t),</span>n=<span class="cstat-no" title="statement not covered" >i[0].substr(2).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{kind:n[0],port:parseInt(n[1],10),protocol:n[2],fmt:n.slice(3).join(" ")}}</span>,l.parseOLine=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >l.matchPrefix(t,"o=")[0],</span>n=<span class="cstat-no" title="statement not covered" >i.substr(2).split(" ");<span class="cstat-no" title="statement not covered" ></span>return{username:n[0],sessionId:n[1],sessionVersion:parseInt(n[2],10),netType:n[3],addressType:n[4],address:n[5]}}</span>,l.isValidSDP=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("string"!=typeof t||0===t.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=l.splitLines(t),n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >if(i[n].length&lt;2||"="!==i[n].charAt(1))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,"object"==typeof i&amp;&amp;(i.exports=l)},{}]},{},[1])(1)},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=function(){function <span class="fstat-no" title="function not covered" >t(</span>t){<span class="cstat-no" title="statement not covered" >this.delayTime=.1,this.fadeTime=.05,this.startTime=.1,this.previousPitch=-1,this.context=t,this.input=t.createGain(),this.output=t.createGain(),this.mod1=t.createBufferSource(),this.mod2=t.createBufferSource(),this.mod3=t.createBufferSource(),this.mod4=t.createBufferSource(),this.shiftDownBuffer=this.createDelayTimeBuffer(t,this.startTime,this.fadeTime,!1),this.shiftUpBuffer=this.createDelayTimeBuffer(t,this.startTime,this.fadeTime,!0),this.mod1.buffer=this.shiftDownBuffer,this.mod2.buffer=this.shiftDownBuffer,this.mod3.buffer=this.shiftUpBuffer,this.mod4.buffer=this.shiftUpBuffer,this.mod1.loop=!0,this.mod2.loop=!0,this.mod3.loop=!0,this.mod4.loop=!0,this.mod1Gain=t.createGain(),this.mod2Gain=t.createGain(),this.mod3Gain=t.createGain(),this.mod4Gain=t.createGain(),this.mod3Gain.gain.value=0,this.mod4Gain.gain.value=0,this.mod1.connect(this.mod1Gain),this.mod2.connect(this.mod2Gain),this.mod3.connect(this.mod3Gain),this.mod4.connect(this.mod4Gain),this.modGain1=t.createGain(),this.modGain2=t.createGain(),this.delay1=t.createDelay(),this.delay2=t.createDelay(),this.mod1Gain.connect(this.modGain1),this.mod2Gain.connect(this.modGain2),this.mod3Gain.connect(this.modGain1),this.mod4Gain.connect(this.modGain2),this.modGain1.connect(this.delay1.delayTime),this.modGain2.connect(this.delay2.delayTime),this.fade1=t.createBufferSource(),this.fade2=t.createBufferSource(),this.fadeBuffer=this.createFadeBuffer(t,this.startTime,this.fadeTime),this.fade1.buffer=this.fadeBuffer,this.fade2.buffer=this.fadeBuffer,this.fade1.loop=!0,this.fade2.loop=!0,this.mix1=t.createGain(),this.mix2=t.createGain(),this.mix1.gain.value=0,this.mix2.gain.value=0,this.fade1.connect(this.mix1.gain),this.fade2.connect(this.mix2.gain),this.input.connect(this.delay1),this.input.connect(this.delay2),this.delay1.connect(this.mix1),this.delay2.connect(this.mix2),this.mix1.connect(this.output),this.mix2.connect(this.output);v</span>ar i=<span class="cstat-no" title="statement not covered" >t.currentTime+.05,</span>n=<span class="cstat-no" title="statement not covered" >i+this.startTime-this.fadeTime;<span class="cstat-no" title="statement not covered" ></span>this.mod1.start(i),this.mod2.start(n),this.mod3.start(i),this.mod4.start(n),this.fade1.start(i),this.fade2.start(n),this.setDelay(this.delayTime)}</span>return t.prototype.createFadeBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >for(var l=i*t.sampleRate,p=l+(i-2*n)*t.sampleRate,e=t.createBuffer(1,p,t.sampleRate),v=e.getChannelData(0),T=n*t.sampleRate,E=l-T,S=0;S&lt;l;++S)<span class="cstat-no" title="statement not covered" >v[S]=S&lt;T?Math.sqrt(S/T):S&gt;=E?Math.sqrt(1-(S-E)/T):1;<span class="cstat-no" title="statement not covered" >f</span></span>or(S=l;S&lt;length;++S)<span class="cstat-no" title="statement not covered" >v[S]=0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,t.prototype.createDelayTimeBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >for(var p=i*t.sampleRate,e=p+(i-2*n)*t.sampleRate,v=t.createBuffer(1,e,t.sampleRate),T=v.getChannelData(0),E=0;E&lt;p;++E)<span class="cstat-no" title="statement not covered" >T[E]=l?(p-E)/e:E/p;<span class="cstat-no" title="statement not covered" >f</span></span>or(E=p;E&lt;e;++E)<span class="cstat-no" title="statement not covered" >T[E]=0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn v}</span>,t.prototype.setDelay=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.modGain1.gain.setTargetAtTime(.5*t,0,.01),this.modGain2.gain.setTargetAtTime(.5*t,0,.01)}</span>,t.prototype.setPitchOffset=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t&gt;0?(this.mod1Gain.gain.value=0,this.mod2Gain.gain.value=0,this.mod3Gain.gain.value=1,this.mod4Gain.gain.value=1):(this.mod1Gain.gain.value=1,this.mod2Gain.gain.value=1,this.mod3Gain.gain.value=0,this.mod4Gain.gain.value=0),this.setDelay(this.delayTime*Math.abs(t)),this.previousPitch=t}</span>,t}();i.pitchUtil=l},function(t,i,n){"use strict";var l=this&amp;&amp;this.__assign||Object.assign||<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i,n=1,l=arguments.length;n&lt;l;n++)<span class="cstat-no" title="statement not covered" >for(var p in i=arguments[n])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(i,p)&amp;&amp;(t[p]=i[p]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>;</span>Object.defineProperty(i,"__esModule",{value:!0});var p=n(0),e=n(1),v=function(){function <span class="fstat-no" title="function not covered" >t(</span>t,i){<span class="cstat-no" title="statement not covered" >this.sendDataMap={},this.sendDataList=new p.LinkedList,this.sendDataCheckOnceCount=100,this.signalSeq=0,this.pushCallback={},this.sessionInfos={},this.tryHeartbeatCount=0,this.heartbeatInterval=1e4,this.sendDataTimeout=5e3,this.sendDataDropTimeout=1e4,this.tryConnectCount=1,this.tryConnectTimer=null,this.tryConnectInterval=3e3,this.state=p.ENUM_CONNECT_STATE.disconnect,this.tokenType=0,this.browser=this.getBrowserAndVersion(),this.platform=navigator.platform,this.negoInterval=25e3,this.negoTryCount=1,this.negoTryMaxCount=2,this.logger=t,this.stateCenter=i}</span>return t.prototype.getBrowserAndVersion=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,i=<span class="cstat-no" title="statement not covered" >navigator.userAgent,</span>n=<span class="cstat-no" title="statement not covered" >i.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i)||[];<span class="cstat-no" title="statement not covered" ></span>return/trident/i.test(n[1])?{name:"IE",version:(t=/\brv[ :]+([\d\.]+)/g.exec(i)||[])[1]||""}:"Chrome"===n[1]&amp;&amp;null!=(t=i.match(/\bOPR|Edge\/([\d\.]+)/))?{name:"Opera",version:t[1]}:(n=n[2]?[n[1],n[2]]:[navigator.appName,navigator.appVersion,"-?"],null!=(t=i.match(/version\/([\d+\.]+)/i))&amp;&amp;n.splice(1,1,t[1]),{name:n[0],version:n[1]})}</span>,t.prototype.setSessionInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.ssi.0 call"),this.appid=t+"",this.userid=i}</span>,t.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.onUpdateHeartBeartInterval=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.resetConnectTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zs.rct.0 call"),clearTimeout(this.tryConnectTimer),this.tryConnectTimer=null,this.tryConnectCount=0}</span>,t.prototype.bindWebSocketHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.tryHeartbeatCount=0,this.websocket.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(i){var n=<span class="cstat-no" title="statement not covered" >JSON.parse(i.data);<span class="cstat-no" title="statement not covered" ></span>t.logger.info("zs.bsh.0 signmsg= ",n.header.cmd),t.logger.info("zs.bsh.0 signmsg= "+JSON.stringify(n)),n.header.appid==t.appid&amp;&amp;n.header.user_id===t.userid?t.handleServerPush(n):t.logger.warn("zs.bsh.0 check header failed")}</span>,this.websocket.onclose=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.logger.info("zs.bsh.0 signal close msg = "+JSON.stringify(i.code)),t.state!=p.ENUM_CONNECT_STATE.disconnect&amp;&amp;(t.resetConnectTimer(),t.startConnectTimer(),t.resetCheckMessage())}</span>,this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.logger.error("zs.bsh.0 msg = "+JSON.stringify(i))}</span>}</span>,t.prototype.resetCheckMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.rcm.0 call");<span class="cstat-no" title="statement not covered" >f</span>or(var t=this.sendDataList.getFirst();null!=t;)<span class="cstat-no" title="statement not covered" >this.sendDataList.remove(t),t._data.error&amp;&amp;t._data.error(p.SEND_MSG_RESET,t._data.seq),t=this.sendDataList.getFirst();<span class="cstat-no" title="statement not covered" >t</span></span>his.sendDataMap={}}</span>,t.prototype.handleServerPush=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(t.header.cmd){case"LoginRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("LoginReq",t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CreateSessionRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("CreateSessionReq",t),0===t.body.result&amp;&amp;this.addSession(t.header.session_id,t.body.session_token);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"MediaDescRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("MediaDescReq",t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CandidateInfoRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("CandidateInfoReq",t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CloseSessionRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("CloseSessionReq",t),this.removeSession(t.header.session_id);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ClientHBRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("ClientHBReq",t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"MediaDescPush":case"CandidateInfoPush":<span class="cstat-no" title="statement not covered" >this.handlePushData(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CloseSessionPush":<span class="cstat-no" title="statement not covered" >this.handlePushData(t),this.removeSession(t.header.session_id);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"QualityReportRsp":<span class="cstat-no" title="statement not covered" >this.handleRespondData("QualityReportReq",t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SessionResetPush":<span class="cstat-no" title="statement not covered" >this.handlePushResetSessionData(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"StreamStatusNotifyPush":case"PublishEventPush":case"PlayEventPush":<span class="cstat-no" title="statement not covered" >this.handlePushData(t)}</span>}</span>,t.prototype.disconnectCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.connectCallback&amp;&amp;(this.connectCallback(-1,this.server,void 0),this.connectCallback=null);v</span>ar t=<span class="cstat-no" title="statement not covered" >this.server;<span class="cstat-no" title="statement not covered" ></span>this.disconnectServer(),this.onDisconnect(t)}</span>,t.prototype.updateToken=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zs.ut.0 call");v</span>ar i=<span class="cstat-no" title="statement not covered" >{token:this.token,tokenType:this.tokenType,roomid:this.stateCenter.roomid,anchorname:this.stateCenter.anchor_info.anchor_id,sdkversion:p.PROTO_VERSION,osinfo:navigator.appVersion};<span class="cstat-no" title="statement not covered" ></span>if(0!=Object.keys(this.sessionInfos).length){var n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var l in this.sessionInfos){var v=<span class="cstat-no" title="statement not covered" >parseInt(l);<span class="cstat-no" title="statement not covered" ></span>n.push({session_id:v,session_token:this.sessionInfos[v].token})}<span class="cstat-no" title="statement not covered" ></span>i</span>.sessions=n}<span class="cstat-no" title="statement not covered" ></span>t</span>his.sendMessageWithCallback("LoginReq",e.getSeq(),0,i,<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >if(0==l.result){<span class="cstat-no" title="statement not covered" >t.token=l.token,t.tokenType=l.tokenType;v</span>ar p=<span class="cstat-no" title="statement not covered" >{report:l.report,report_interval:l.report_interval_ms};<span class="cstat-no" title="statement not covered" ></span>l.negoInterval&amp;&amp;(t.negoInterval=l.negoInterval),l.negoTryCount&amp;&amp;(t.negoTryCount=l.negoTryCount),l.negoTryMaxCount&amp;&amp;(t.negoTryMaxCount=l.negoTryMaxCount),null!=t.connectCallback&amp;&amp;(t.connectCallback(0,t.server,p),t.connectCallback=null)}</span>else{var e=<span class="cstat-no" title="statement not covered" >{error:l.strError};<span class="cstat-no" title="statement not covered" ></span>null!=t.connectCallback&amp;&amp;(t.connectCallback(l.result,t.server,e),t.connectCallback=null)}</span>}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >null!=t.connectCallback&amp;&amp;(t.connectCallback(-1,t.server,void 0),t.connectCallback=null)}</span>)}</span>,t.prototype.sendMessageWithCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,e,v){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zs.smwc.0 call "+t),!this.websocket||1!==this.websocket.readyState)<span class="cstat-no" title="statement not covered" >return this.logger.error("zs.smwc.0 connect not establish"),void(v&amp;&amp;v(p.SEND_MSG_TIMEOUT,i));v</span></span>ar T=<span class="cstat-no" title="statement not covered" >{header:this.getHeader(t,i,n),body:l};<span class="cstat-no" title="statement not covered" ></span>null==e&amp;&amp;(e=null),null==v&amp;&amp;(v=null);v</span>ar E=<span class="cstat-no" title="statement not covered" >{seq:i,deleted:!1,cmd:t,time:Date.parse(new Date+""),success:e,error:v},</span>S=<span class="cstat-no" title="statement not covered" >this.sendDataList.push(E);<span class="cstat-no" title="statement not covered" ></span>this.sendDataMap[E.seq]=S;v</span>ar R=<span class="cstat-no" title="statement not covered" >JSON.stringify(T);<span class="cstat-no" title="statement not covered" ></span>this.websocket.send(R),this.logger.debug("zs.smwc.0 success")}</span>,t.prototype.getHeader=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return this.globalHeader={version:"1.0.1",cmd:t,appid:this.appid+"",seq:i,user_id:this.userid,session_id:n},this.globalHeader}</span>,t.prototype.connectServer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.token=t,this.server=i,this.state=p.ENUM_CONNECT_STATE.connecting,this.connectCallback=n,this.websocket&amp;&amp;1===this.websocket.readyState)<span class="cstat-no" title="statement not covered" >this.resetConnectTimer(),this.state=p.ENUM_CONNECT_STATE.connected;e</span>lse{<span class="cstat-no" title="statement not covered" >this.logger.info("zs.cs.0 need new websocket");<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.websocket&amp;&amp;(this.logger.warn("zs.cs.0 close error websocket"),this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null),this.websocket=new WebSocket(this.server),this.websocket.onopen=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l.resetConnectTimer(),l.logger.info("zs.cs.0 websocket open call"),l.bindWebSocketHandle(),l.updateToken(),l.state=p.ENUM_CONNECT_STATE.connected}</span>,this.websocket.onclose=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.logger.info("zs.cs.0 signal websocket close code "+JSON.stringify(t.code))}</span>,this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >l.logger.info("zs.cs.0 websocket onerror call  "+JSON.stringify(t))}</span>}</span>catch(t){<span class="cstat-no" title="statement not covered" >this.logger.error("zs.cs.0 websocket error "+t)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.tryConnectTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l.startConnectTimer(n)}</span>,this.tryConnectInterval)}</span>,t.prototype.startConnectTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zs.sct.0 call"),this.tryConnectCount&gt;=p.MAX_TRY_CONNECT_COUNT)<span class="cstat-no" title="statement not covered" >return this.logger.info("zs.sct.0 beyond "+this.server+" max limit"),void this.disconnectCallback();<span class="cstat-no" title="statement not covered" >t</span></span>his.websocket&amp;&amp;1===this.websocket.readyState?this.resetConnectTimer():(this.tryConnectCount+=1,this.connectServer(this.token,this.server,t))}</span>,t.prototype.disconnectServer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.ds.0 call"),this.connectCallback=null,this.resetCheckMessage(),this.resetConnectTimer(),this.websocket&amp;&amp;(this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null),this.token="",this.sessionInfos={},this.tokenType=0,this.tryHeartbeatCount=0,this.tryConnectCount=0,this.state=p.ENUM_CONNECT_STATE.disconnect}</span>,t.prototype.isServerConnected=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!(!this.websocket||1!==this.websocket.readyState)}</span>,t.prototype.createSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,e,v,T){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=""),this.logger.debug("zs.cs.1 call: ",l);v</span>ar E=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>p.PROTO_VERSION.split(".").forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return 1==t.length&amp;&amp;1==i?E+="0"+t:E+=t}</span>);v</span>ar S=<span class="cstat-no" title="statement not covered" >{type:i,stream_id:l,platform:this.platform,browser:this.browser.name,version:this.browser.version,app_id:this.appid,negotiate_mode:n,strAuthParam:e,sdk_version:1*E};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("CreateSessionReq",t,0,S,v,T)}</span>,t.prototype.removeSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.info("zs.rs.0 call"),this.sessionInfos[t]&amp;&amp;delete this.sessionInfos[t]}</span>,t.prototype.sendCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.scs.0 call: ",i);v</span>ar e=<span class="cstat-no" title="statement not covered" >{reason:n};<span class="cstat-no" title="statement not covered" ></span>this.removeSession(i),this.sendMessageWithCallback("CloseSessionReq",t,i,e,l,p)}</span>,t.prototype.sendMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zs.sm.0 call "+t),this.websocket&amp;&amp;1===this.websocket.readyState){var p=<span class="cstat-no" title="statement not covered" >{header:this.getHeader(t,i,n),body:l},</span>e=<span class="cstat-no" title="statement not covered" >JSON.stringify(p);<span class="cstat-no" title="statement not covered" ></span>this.websocket.send(e),this.logger.debug("zs.sm.0 success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zs.sm.0 connect not establish")}</span></span>,t.prototype.handleRespondData=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.hrd.0 call");v</span>ar n=<span class="cstat-no" title="statement not covered" >this.sendDataMap[i.header.seq];<span class="cstat-no" title="statement not covered" ></span>if(null!=n){var l=<span class="cstat-no" title="statement not covered" >n._data;<span class="cstat-no" title="statement not covered" ></span>l.cmd!==t?this.logger.error("sz.hrd.0 command is not match"):l.success&amp;&amp;l.success(i.header.seq,i.header.session_id,i.body),delete this.sendDataMap[i.header.seq],this.sendDataList.remove(n)}</span>else{<span class="cstat-no" title="statement not covered" >if("CloseSessionRsp"==i.header.cmd)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.error("zs.hrd.0 cannot find data "+t)}</span>}</span>,t.prototype.addSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.logger.info("zs.as.0 call"),this.sessionInfos[t]={token:i}}</span>,t.prototype.handlePushData=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.hpd.0 call "+t.header.cmd+" session "+t.header.session_id);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.pushCallback[t.header.cmd+t.header.session_id];<span class="cstat-no" title="statement not covered" ></span>i?i.callback&amp;&amp;i.callback(t.header.seq,t.header.session_id,t.body):this.logger.info("zs.hpd.0 no callbackData "+t.header.cmd+" session: "+t.header.session_id)}</span>,t.prototype.handlePushResetSessionData=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.hprsd.0 call ");v</span>ar i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(0==t.body.cResetType)<span class="cstat-no" title="statement not covered" >i=Object.keys(this.sessionInfos);e</span>lse <span class="cstat-no" title="statement not covered" >if(1==t.body.cResetType)<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;t.body.session_ids.length;n++)<span class="cstat-no" title="statement not covered" >i.push(t.body.session_ids[n]);<span class="cstat-no" title="statement not covered" >i</span></span></span></span>f(this.sendResetSessionAck(t.header.seq,0,0),0!=i.length)<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;i.length;l++){var p=<span class="cstat-no" title="statement not covered" >this.pushCallback[t.header.cmd+i[l]];<span class="cstat-no" title="statement not covered" ></span>null==p?this.logger.info("zs.hprsd.0 no callbackData "+i[l]):p.callback&amp;&amp;p.callback(t.header.seq,i[l],t.body)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >this.logger.info("zs.hprsd.0 no session to callback")}</span></span>,t.prototype.sendMediaDesc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p,e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.smd.0 call: ",i);v</span>ar v=<span class="cstat-no" title="statement not covered" >{type:n,sdp:l.sdp};<span class="cstat-no" title="statement not covered" ></span>null!=l.width&amp;&amp;(v.width=l.width),null!=l.height&amp;&amp;(v.height=l.height),null!=l.frameRate&amp;&amp;(v.framerate=l.frameRate),null!=l.video_min_kpbs&amp;&amp;(v.video_min_kpbs=l.video_min_kpbs),null!=l.video_max_kpbs&amp;&amp;(v.video_max_kpbs=l.video_max_kpbs),null!=l.audio_kpbs&amp;&amp;(v.audio_kpbs=l.audio_kpbs),null!=l.keyframe_intv&amp;&amp;(v.keyframe_intv=l.keyframe_intv),this.sendMessageWithCallback("MediaDescReq",t,i,v,p,e)}</span>,t.prototype.sendCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.sci.0 call: ",i);<span class="cstat-no" title="statement not covered" >f</span>or(var e=[],v=0;v&lt;n.length;v++){var T=<span class="cstat-no" title="statement not covered" >{candidate:n[v].candidate,sdpMid:n[v].sdpMid,sdpMLineIndex:n[v].sdpMLineIndex};<span class="cstat-no" title="statement not covered" ></span>e.push(T)}</span>v</span>ar E=<span class="cstat-no" title="statement not covered" >{infos:e};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("CandidateInfoReq",t,i,E,l,p)}</span>,t.prototype.sendMediaDescAck=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.smda.0 call: ",i);v</span>ar l=<span class="cstat-no" title="statement not covered" >{result:n};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("MediaDescAck",t,i,l)}</span>,t.prototype.sendCandidateInfoAck=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.scia.0 call: ",i);v</span>ar l=<span class="cstat-no" title="statement not covered" >{result:n};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("CandidateInfoAck",t,i,l)}</span>,t.prototype.sendCloseSessionAck=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.scsa.0 call: ",i);v</span>ar l=<span class="cstat-no" title="statement not covered" >{result:n};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("CloseSessionAck",t,i,l)}</span>,t.prototype.sendResetSessionAck=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.ssra.0 call: ",i);v</span>ar l=<span class="cstat-no" title="statement not covered" >{result:n};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("SessionResetAck",t,i,l)}</span>,t.prototype.registerPushCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >n&amp;&amp;"function"==typeof n&amp;&amp;(this.logger.debug("zs.rpc.0 setcallback"),this.pushCallback[t+i]={callback:n})}</span>,t.prototype.unregisterPushCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >delete this.pushCallback[t+i]}</span>,t.prototype.checkMessageTimeout=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=this.sendDataList.getFirst(),i=Date.parse(new Date+""),n=0,l=0,e=0;!(null==t||t._data.time+this.sendDataTimeout&gt;i||(delete this.sendDataMap[t._data.seq],this.sendDataList.remove(t),++l,null==t._data.error||this.sendDataDropTimeout&gt;0&amp;&amp;t._data.time+this.sendDataDropTimeout&lt;i?++e:t._data.error&amp;&amp;t._data.error(p.SEND_MSG_TIMEOUT,t._data.seq),++n&gt;=this.sendDataCheckOnceCount));)<span class="cstat-no" title="statement not covered" >t=this.sendDataList.getFirst();<span class="cstat-no" title="statement not covered" >0</span></span>==l&amp;&amp;0==e||this.logger.debug("zs.cmt.0 call success, state: timeout=",l," drop=",e)}</span>,t.prototype.sendHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zs.shb.0 call tryHeartbeatCount:"+this.tryHeartbeatCount),0!=Object.keys(this.sessionInfos).length){<span class="cstat-no" title="statement not covered" >if(++this.tryHeartbeatCount&gt;p.MAX_TRY_HEARTBEAT_COUNT)<span class="cstat-no" title="statement not covered" >return this.logger.error("zs.shb.0 heartbeat try limit"),void this.disconnectCallback();v</span></span>ar i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var n in this.sessionInfos)<span class="cstat-no" title="statement not covered" >i.push(parseInt(n));v</span></span>ar l=<span class="cstat-no" title="statement not covered" >{session_ids:i};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("ClientHBReq",e.getSeq(),0,l,<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.heartbeatInterval!=l.hb_interval&amp;&amp;(t.heartbeatInterval=l.hb_interval,t.onUpdateHeartBeartInterval(l.hb_interval)),t.tryHeartbeatCount=0}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){})}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zs.shb.0 no need to heartbeat")}</span></span>,t.prototype.QualityReport=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p,e){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.qr.0 call");v</span>ar v=<span class="cstat-no" title="statement not covered" >{streams:[l({},n,{aid:i})]};<span class="cstat-no" title="statement not covered" ></span>this.sendMessageWithCallback("QualityReportReq",t,i,v,p,e)}</span>,t.prototype.sendStreamStatus=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.sss.0 call");v</span>ar p=<span class="cstat-no" title="statement not covered" >{mic_status:l,camera_status:n};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zs.sss.0 stream status "+JSON.stringify(p)),this.sendMessage("StreamStatusNotify",t,i,p)}</span>,t.prototype.sendBroadcasterStatus=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.debug("zs.sss.0 call");v</span>ar l=<span class="cstat-no" title="statement not covered" >{status:n};<span class="cstat-no" title="statement not covered" ></span>this.sendMessage("BroadcasterStatusNotify",t,i,l)}</span>,t}();i.ZegoSignal=v},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(1),e=n(4),v=function(){function <span class="fstat-no" title="function not covered" >t(</span>t,i,n,e,v){<span class="cstat-no" title="statement not covered" >this.state=l.ENUM_PLAY_STATE.stop,this.candidateInfo=[],this.waitICETimer=null,this.waitingICETimeInterval=5e3,this.waitingOfferTimer=null,this.waitingOfferTimeInterval=5e3,this.waitingServerTimer=null,this.waitingServerTimerInterval=3e3,this.qualityTimer=null,this.playQualityList=[],this.maxQualityListCount=10,this.lastPlayStats={audioPacketsLost:0,videoPacketsLost:0,time:0,audioTime:0,videoTime:0,audioBytesReceived:0,videoBytesReceived:0,framesDecoded:0,framesReceived:0,framesDropped:0,audioBitrate:0},this.reportSeq=p.getSeq(),this.videoSizeCallback=!1,this.qualityUpload=!1,this.qualityUploadInterval=3e4,this.qualityUploadLastTime=0,this.maxRetryCount=3,this.currentRetryCount=0,this.retryState=l.ENUM_RETRY_STATE.didNotStart,this.closeSessionSignal=!1,this.stateNego=l.ENUM_PLAY_STATE_NEGO.stop,this.negoInterval=25e3,this.negoTryCount=1,this.negoTryMaxCount=2,this.broadcasterStatus=l.ENUM_BROADCASTER_STATUS.stop,this.cameraStatus=null,this.micStatus=null,this.playEvent=!1,this.nextSignalTryCount=1,this.waittingConnectedTimer=null,this.waittingConnectedInerval=15e3,this.gotStreamStatus=!1,this.tryingNexitSignal=!1,this.ac=null,this.soundLevel=0,this.mic=null,this.script=null,this.logger=t,this.signal=i,this.dataReport=n,this.qualityTimeInterval=e,this.streamCenter=v,n.newReport(this.reportSeq)}</span>return t.prototype.setAudioDestination=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return this.remoteVideo?"undefined"!==this.remoteVideo.sinkId?(this.remoteVideo.setSinkId(t).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.sad.1 success device: "+t)}</span>).catch(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.sad.1 "+t.name)}</span>),!0):(this.logger.error("zp.sad.1 browser does not suppport"),!1):(this.logger.info("zp.sad.1 no remoteVideo"),!1)}</span>,t.prototype.startPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,e){var v=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sp.1 called ",t),this.playEvent=!1,this.signal&amp;&amp;this.signal.negoInterval&amp;&amp;(this.negoInterval=this.signal.negoInterval),this.signal&amp;&amp;this.signal.negoTryCount&amp;&amp;(this.negoTryCount=this.signal.negoTryCount),this.signal&amp;&amp;this.signal.negoTryMaxCount&amp;&amp;(this.negoTryMaxCount=this.signal.negoTryMaxCount),t?(this.streamId=t,this.remoteVideo=i,this.audioOutput=n,this.playOption=e||{},e&amp;&amp;e.videoDecodeType&amp;&amp;(this.playOption.videoDecodeType=e.videoDecodeType),this.sessionSeq=p.getSeq(),this.dataReport.eventStart(this.reportSeq,"CreateSession"),this.signal.createSession(this.sessionSeq,1,0,t,e&amp;&amp;e.streamParams,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >v.dataReport.eventEndWithMsg(v.reportSeq,"CreateSession",{sessionId:n.session_id}),v.logger.info("zp.sp.1 sessionId:"+n.session_id),v.sessionSeq==t?0!==n.result?(v.logger.error("zp.sp.1 create error"),v.playStateUpdateError(p.playErrorList.CREATE_SESSION_ERROR)):(v.sessionId=n.session_id,v.onCreatePlaySessionSuccess(n)):v.logger.error("zp.sp.1 seq is not match.")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >v.dataReport.eventEndWithMsg(v.reportSeq,"CreateSession",{error:t}),v.playStateUpdateError(p.playErrorList.SEND_SESSION_TIMEOUT)}</span>),this.state=l.ENUM_PLAY_STATE.waitingSessionRsp,this.logger.debug("zp.sp.1 called success"),this.stateNego=l.ENUM_PLAY_STATE_NEGO.start,this.negoTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >v.stateNego!==l.ENUM_PLAY_STATE_NEGO.iceConnected&amp;&amp;v.negoTryCount&lt;v.negoTryMaxCount?(v.signal.sendCloseSession(p.getSeq(),v.sessionId,1),v.resetPlay(),v.startPlay(t,i,n,e),++v.negoTryCount):v.stateNego!==l.ENUM_PLAY_STATE_NEGO.iceConnected&amp;&amp;v.negoTryCount===v.negoTryMaxCount&amp;&amp;(v.logger.error("zp.sp.1 waiting timeout"),v.playStateUpdateError(p.playErrorList.SERVER_NEGO_TIMEOUT))}</span>,this.negoInterval)):this.logger.warn("zp.sp.1 streamId is null")}</span>,t.prototype.onCreatePlaySessionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.1 success");v</span>ar n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.turn_server&amp;&amp;n.push(t.turn_server),t.stun_server&amp;&amp;n.push(t.stun_server);v</span>ar l=<span class="cstat-no" title="statement not covered" >{iceTransportPolicy:"relay",iceServers:[{urls:n,username:t.turn_username,credential:t.turn_auth_key}]};<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.ops.1 username: "+t.turn_username),this.logger.info("zp.ops.1 credential: "+t.turn_auth_key),this.peerConnection=new RTCPeerConnection(l),this.peerConnection.onicecandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.onIceCandidate(t)}</span>,this.peerConnection.onsignalingstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.onConnectionStateChange(t)}</span>,this.peerConnection.oniceconnectionstatechange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.onIceConnectionStateChange(t)}</span>,this.peerConnection.ontrack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.onGotRemoteStream(t.streams[0])}</span>,this.remoteVideo.oncanplay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.logger.debug("zp.ops.1 "+i.remoteVideo.videoWidth+" X "+i.remoteVideo.videoHeight),i.videoSizeCallback||(i.logger.debug("zp.ops.1 onresize callback"),i.onVideoSizeChanged(i.streamId,i.remoteVideo.videoWidth,i.remoteVideo.videoHeight),i.videoSizeCallback=!0)}</span>;v</span>ar e=<span class="cstat-no" title="statement not covered" >{offerToReceiveAudio:1,offerToReceiveVideo:1};<span class="cstat-no" title="statement not covered" ></span>this.playOption&amp;&amp;"audio"===this.playOption.playType&amp;&amp;(e.offerToReceiveVideo=0),this.playOption&amp;&amp;"video"===this.playOption.playType&amp;&amp;(e.offerToReceiveAudio=0),this.logger.info("zp.ops.1 createOffer: "+JSON.stringify(e)),this.dataReport.eventStart(this.reportSeq,"CreateOffer"),this.peerConnection.createOffer(e).then(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEnd(i.reportSeq,"CreateOffer"),i.onCreateOfferSuccess(t)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEndWithMsg(i.reportSeq,"CreateOffer",{error:t.toString()}),i.logger.error("zp.ops.0 create offer error "+t.toString()),i.playStateUpdateError(p.playErrorList.CREATE_OFFER_ERROR,!0)}</span>),this.signal.registerPushCallback("MediaDescPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvMediaDesc(t,n,l)}</span>),this.signal.registerPushCallback("CandidateInfoPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvCandidateInfo(t,n,l)}</span>),this.signal.registerPushCallback("CloseSessionPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvCloseSession(t,n,l)}</span>),this.signal.registerPushCallback("SessionResetPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvResetSession(t,n,l)}</span>),this.signal.registerPushCallback("StreamStatusNotifyPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.gotStreamStatus=!0,i.streamStatus=l,i.remoteStream&amp;&amp;i.onRecvStreamStatus(l)}</span>),this.signal.registerPushCallback("PlayEventPush",this.sessionId,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.onRecvPlayEvent(t,n,l)}</span>),this.logger.debug("zp.ops.1 call success")}</span>,t.prototype.onCreateOfferSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.oco.1 localSdp1 "+t.sdp.substr(0,t.sdp.length/2)),this.logger.info("zp.oco.1 localSdp2 "+t.sdp.substr(t.sdp.length/2)),t.sdp=t.sdp.replace(/sendrecv/g,"recvonly"),this.playOption.videoDecodeType&amp;&amp;(t.sdp=e.sdpUtil.getSDPByVideDecodeType(t.sdp,this.playOption.videoDecodeType)),this.dataReport.eventStart(this.reportSeq,"SetLocalDescription"),this.peerConnection.setLocalDescription(t).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.dataReport.eventEnd(i.reportSeq,"SetLocalDescription"),i.onSetLocalDescriptionSuccess(t)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.logger.error("zp.oca.1 set error "+t.toString()),i.dataReport.eventEnd(i.reportSeq,"SetLocalDescription",{error:t.toString()}),i.playStateUpdateError(p.playErrorList.SET_LOCAL_DESC_ERROR,!0)}</span>)}</span>,t.prototype.onSetLocalDescriptionSuccess=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.osd.1 success");v</span>ar n=<span class="cstat-no" title="statement not covered" >{sdp:t.sdp};<span class="cstat-no" title="statement not covered" ></span>this.answerSeq=p.getSeq(),this.dataReport.eventStart(this.reportSeq,"SendMediaDesc"),this.signal.sendMediaDesc(this.answerSeq,this.sessionId,0,n,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,e){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.osd.1 sendMediaDesc resp"),i.answerSeq==t&amp;&amp;i.sessionId==n?(i.logger.info("zp.osd.1 send success stateNego:waiterAnswer"),i.stateNego=l.ENUM_PLAY_STATE_NEGO.waiterAnswer,i.dataReport.eventEnd(i.reportSeq,"SendMediaDesc"),i.waitingOfferTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.state==l.ENUM_PLAY_STATE.waitingOffserRsp&amp;&amp;(i.logger.error("zp.osd.1 waiting timeout"),i.playStateUpdateError(p.playErrorList.SERVER_CANDIDATE_TIMEOUT))}</span>,i.waitingOfferTimeInterval),i.state=l.ENUM_PLAY_STATE.waitingServerAnswer):i.logger.error("zp.osd.1 seq or sessionId is not equal "+i.answerSeq+" "+t,0+i.sessionId+" "+n)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.logger.error("zp.osd.1 failed to send "+t),i.dataReport.eventEndWithMsg(i.reportSeq,"SendMediaDesc",{error:t}),i.playStateUpdateError(p.playErrorList.SEND_MEDIA_DESC_TIMEOUT)}</span>),this.state=l.ENUM_PLAY_STATE.waitingOffserRsp}</span>,t.prototype.onRecvMediaDesc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.orm.1 received ",n),this.stateNego=l.ENUM_PLAY_STATE_NEGO.waitingCandidate,this.logger.info("zp.orm.1 received stateNego:waitingCandidate"),this.state===l.ENUM_PLAY_STATE.waitingServerAnswer){<span class="cstat-no" title="statement not covered" >null!=this.waitingOfferTimer&amp;&amp;(clearTimeout(this.waitingOfferTimer),this.waitingOfferTimer=null),this.dataReport.addEvent(this.reportSeq,"RecvMediaDesc"),this.signal.sendMediaDescAck(t,this.sessionId,0);v</span>ar v=<span class="cstat-no" title="statement not covered" >{type:"answer",sdp:n.sdp,toJSON:<span class="fstat-no" title="function not covered" >fu</span>nction(){}};<span class="cstat-no" title="statement not covered" ></span>this.dataReport.eventStart(this.reportSeq,"SetRemoteDescription"),this.logger.info("zp.orm.1 remoteSdp ",v.sdp),this.peerConnection.setRemoteDescription(new RTCSessionDescription(v)).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.dataReport.eventEnd(e.reportSeq,"SetRemoteDescription"),e.logger.info("zp.orm.1 set success")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.error("zp.orm.1 set remote error "+t.toString()),e.dataReport.eventEndWithMsg(e.reportSeq,"SetRemoteDescription",{error:t.toString()}),e.playStateUpdateError(p.playErrorList.SET_REMOTE_DESC_ERROR)}</span>),this.waitICETimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.state==l.ENUM_PLAY_STATE.waitingServerICE&amp;&amp;(e.logger.error("zp.orm.1 waiting server timeout"),e.playStateUpdateError(p.playErrorList.SERVER_CANDIDATE_TIMEOUT))}</span>,this.waitingICETimeInterval),this.state=l.ENUM_PLAY_STATE.waitingServerICE,this.logger.debug("zp.orm.1 call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zp.orm.1 current state "+this.state+" not allowed")}</span></span>,t.prototype.onRecvCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.orci.1 received "),this.state==l.ENUM_PLAY_STATE.waitingServerICE){<span class="cstat-no" title="statement not covered" >null!=this.waitICETimer&amp;&amp;(clearTimeout(this.waitICETimer),this.waitICETimer=null),this.dataReport.addEvent(this.reportSeq,"RecvIceCandidate"),this.signal.sendCandidateInfoAck(t,this.sessionId,0),this.sendCandidateInfo(this.candidateInfo),this.candidateInfo=[];<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;n.infos.length;v++){var T=<span class="cstat-no" title="statement not covered" >{sdpMid:n.infos[v].sdpMid,sdpMLineIndex:n.infos[v].sdpMLineIndex,candidate:n.infos[v].candidate};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zp.orci.1 candidate "+T.candidate),this.peerConnection.addIceCandidate(new RTCIceCandidate(T)).then(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.logger.debug("zp.orci.1 add success")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.logger.error("zp.orci.1 add error "+t.toString()),e.playStateUpdateError(p.playErrorList.SERVER_CANDIDATE_ERROR)}</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.state=l.ENUM_PLAY_STATE.connecting,this.logger.debug("zp.orci.1 call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zp.orci.1 current state "+this.state+" not allowed")}</span></span>,t.prototype.onRecvPlayEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.orpe.1 received"),!0===this.playEvent&amp;&amp;0==n.event){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orpe.1 retry: "+this.streamId);v</span>ar l=<span class="cstat-no" title="statement not covered" >this.streamId,</span>e=<span class="cstat-no" title="statement not covered" >this.remoteVideo,</span>v=<span class="cstat-no" title="statement not covered" >this.audioOutput,</span>T=<span class="cstat-no" title="statement not covered" >this.playOption;<span class="cstat-no" title="statement not covered" ></span>this.signal.sendCloseSession(p.getSeq(),this.sessionId,1),this.resetPlay(),this.startPlay(l,e,v,T)}</span>else <span class="cstat-no" title="statement not covered" >this.playEvent=!0}</span></span>,t.prototype.onIceCandidate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oic.1 called"),null!=t.candidate)<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zp.oic.1 candidate "+t.candidate.candidate),this.state&lt;l.ENUM_PLAY_STATE.connecting||this.state==l.ENUM_PLAY_STATE.stop)<span class="cstat-no" title="statement not covered" >this.logger.debug("zp.oic.1 cached"),this.candidateInfo.push({candidate:t.candidate.candidate,sdpMid:t.candidate.sdpMid,sdpMLineIndex:t.candidate.sdpMLineIndex});e</span>lse{<span class="cstat-no" title="statement not covered" >this.logger.debug("zp.oic.1 send");v</span>ar i=<span class="cstat-no" title="statement not covered" >{candidate:t.candidate.candidate,sdpMid:t.candidate.sdpMid,sdpMLineIndex:t.candidate.sdpMLineIndex};<span class="cstat-no" title="statement not covered" ></span>this.sendCandidateInfo([i])}</span>}</span></span>,t.prototype.onConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.oisc.1 called "+t.target.signalingState)}</span>,t.prototype.onIceConnectionStateChange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.state!=l.ENUM_PLAY_STATE.stop&amp;&amp;null!=this.peerConnection)<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.oisc.1  stateChanged "+this.peerConnection.iceConnectionState),"connected"===this.peerConnection.iceConnectionState){<span class="cstat-no" title="statement not covered" >for(var n in this.dataReport.addEvent(this.reportSeq,"IceConnected"),this.state!=l.ENUM_PLAY_STATE.playing&amp;&amp;this.onPlayStateUpdate(p.ENUM_PLAY_STATE_UPDATE.start,this.streamId),this.state=l.ENUM_PLAY_STATE.playing,this.tryingNexitSignal=!1,this.retryState!=l.ENUM_RETRY_STATE.didNotStart&amp;&amp;(this.retryState=l.ENUM_RETRY_STATE.finished,this.currentRetryCount=0),this.dataReport.eventStart(this.reportSeq,"PlayState"),this.streamCenter.publisherList){<span class="cstat-no" title="statement not covered" >if(this.streamCenter.publisherList[n].publisher.state==l.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.broadcasterStatus==l.ENUM_BROADCASTER_STATUS.stop){<span class="cstat-no" title="statement not covered" >this.signal&amp;&amp;this.signal.sendBroadcasterStatus(p.getSeq(),this.sessionId,1),this.broadcasterStatus=l.ENUM_BROADCASTER_STATUS.start;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.setPlayQualityTimer(),this.stateNego=l.ENUM_PLAY_STATE_NEGO.iceConnected,this.logger.info("zp.oisc.1  stateNego:iceConnected"),this.negoTryCount=1,this.nextSignalTryCount=1,this.waittingConnectedTimer&amp;&amp;clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null,this.negoTimer&amp;&amp;clearTimeout(this.negoTimer)}</span>else<span class="cstat-no" title="statement not covered" >"closed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(this.reportSeq,"IceClosed"),this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState)):"failed"===this.peerConnection.iceConnectionState?(this.dataReport.addEvent(this.reportSeq,"IceFailed"),this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState)):"disconnected"===this.peerConnection.iceConnectionState&amp;&amp;(this.dataReport.addEvent(this.reportSeq,"IceDisconnected"),this.waittingConnectedTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!i.tryingNexitSignal&amp;&amp;i.tryNextSignal(p.publishErrorList.MEDIA_CONNECTION_DISCONNECTED)}</span>,this.waittingConnectedInerval))}</span></span></span>,t.prototype.checkPlayConnectionFailedState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>"failed"==t?i=p.playErrorList.MEDIA_CONNECTION_FAILED:"closed"==t&amp;&amp;(i=p.playErrorList.MEDIA_CONNECTION_CLOSED),null!=i&amp;&amp;(this.state!=l.ENUM_PLAY_STATE.playing&amp;&amp;this.retryState==l.ENUM_PLAY_STATE.didNotStart?(this.logger.info("zp.oics.1  state "+this.state+" retryState "+this.retryState+" connectionState "+t),this.playStateUpdateError(i)):this.shouldRetryPlay()?(this.onPlayStateUpdate(p.ENUM_PLAY_STATE_UPDATE.retry,this.streamId),this.startRetryPlay()):this.playStateUpdateError(i))}</span>,t.prototype.shouldRetryPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.retryState==l.ENUM_RETRY_STATE.didNotStart&amp;&amp;this.state!=l.ENUM_PLAY_STATE.playing?(this.logger.info("zp.srp.1.0 connection didn't success"),!1):this.retryState==l.ENUM_RETRY_STATE.retrying?(this.logger.info("zp.srp.0.0 already retrying"),!1):this.currentRetryCount&gt;this.maxRetryCount?(this.logger.info("zp.srp.1.0 beyond max"),!1):(this.logger.debug("zp.srp.1.0 call success"),!0)}</span>,t.prototype.startRetryPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zp.srp.0 call");v</span>ar t=<span class="cstat-no" title="statement not covered" >this.streamId,</span>i=<span class="cstat-no" title="statement not covered" >this.remoteVideo,</span>n=<span class="cstat-no" title="statement not covered" >this.audioOutput;<span class="cstat-no" title="statement not covered" ></span>this.resetPlay(),this.tryStartPlay(t,i,n)}</span>,t.prototype.clearTryPlayTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.waitingServerTimer&amp;&amp;(clearTimeout(this.waitingServerTimer),this.waitingServerTimer=null)}</span>,t.prototype.tryStartPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zp.tsp.1 call"),this.clearTryPlayTimer(),this.streamId=t,this.remoteVideo=i,this.audioOutput=n,this.currentRetryCount&gt;this.maxRetryCount)<span class="cstat-no" title="statement not covered" >return this.logger.error("zp.tsp.1 beyond max limit"),void this.playStateUpdateError(p.playErrorList.WEBSOCKET_ERROR);<span class="cstat-no" title="statement not covered" >t</span></span>his.retryState=l.ENUM_RETRY_STATE.retrying,this.currentRetryCount+=1,this.signal.isServerConnected()?(this.logger.debug("zp.tsp.1 signal connected"),this.startPlay(t,this.remoteVideo,this.audioOputput,this.playOption)):(this.logger.debug("zp.tsp.1 signal server not connected"),this.waitingServerTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.tryStartPlay(t,e.remoteVideo,e.audioOputput)}</span>,this.waitingServerTimerInterval))}</span>,t.prototype.clearPlayQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >null!=this.qualityTimer&amp;&amp;(clearInterval(this.qualityTimer),this.qualityTimer=null),this.lastPlayStats={audioPacketsLost:null,videoPacketsLost:null,time:null,audioTime:null,videoTime:null,audioBytesReceived:null,videoBytesReceived:null,framesDecoded:null,framesDropped:null,framesReceived:null,audioBitrate:null}}</span>,t.prototype.resetPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.rp.1 call"),this.streamId=null,this.state=l.ENUM_PLAY_STATE.stop,this.playEvent=!1,null!=this.peerConnection&amp;&amp;(this.peerConnection.close(),this.peerConnection=null),null!=this.waitingOfferTimer&amp;&amp;(clearTimeout(this.waitingOfferTimer),this.waitingOfferTimer=null),null!=this.waitICETimer&amp;&amp;(clearTimeout(this.waitICETimer),this.waitICETimer=null),null!=this.negoTimer&amp;&amp;(clearTimeout(this.negoTimer),this.negoTimer=null),null!=this.waittingConnectedTimer&amp;&amp;(clearTimeout(this.waittingConnectedTimer),this.waittingConnectedTimer=null),this.clearPlayQualityTimer(),this.remoteVideo&amp;&amp;(this.remoteVideo.srcObject=null,this.remoteVideo.oncanplay=null,this.remoteVideo=null),this.audioOputput=null,this.signal&amp;&amp;(this.signal.unregisterPushCallback("MediaDescPush",this.sessionId),this.signal.unregisterPushCallback("CandidateInfoPush",this.sessionId),this.signal.unregisterPushCallback("CloseSessionPush",this.sessionId)),this.sessionSeq=0,this.answerSeq=0,this.videoSizeCallback=!1,this.script&amp;&amp;this.script.disconnect(),this.mic&amp;&amp;this.mic.disconnect(),this.currentRetryCount=0,this.retryState=l.ENUM_RETRY_STATE.didNotStart,this.clearTryPlayTimer()}</span>,t.prototype.setPlayQualityTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>null==this.qualityTimer&amp;&amp;(this.logger.debug("zp.spq.1 startTimer"),this.clearPlayQualityTimer(),this.qualityTimer=setInterval(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.peerConnection&amp;&amp;t.peerConnection.getStats(null).then(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.getPlayStats(i)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.logger.info("zp.spq.1 getStats error "+i.toString())}</span>)}</span>,this.qualityTimeInterval),this.lastPlayStats={audioPacketsLost:0,videoPacketsLost:0,time:0,audioTime:0,videoTime:0,audioBytesReceived:0,videoBytesReceived:0,framesDecoded:0,framesReceived:0,framesDropped:0,audioBitrate:0})}</span>,t.prototype.getPlayStats=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(null!=t){var n=<span class="cstat-no" title="statement not covered" >{audioFractionLost:null,audioPacketsLost:0,audioPacketsLostRate:0,audioBitrate:0,audioLevel:0,audioSendLevel:0,audioSamplingRate:0,audioCodecType:"opus",audioQuality:null,videoQuality:null,videoPacketsLostRate:0,videoBitrate:0,videoFPS:0,playData:0,nackCount:0,pliCount:0,audioJitter:0,videoFractionLost:null,videoFramesDecoded:0,frameHeight:0,frameWidth:0,videoTransferFPS:0,videoFramesDropped:0,totalRoundTripTime:0,currentRoundTripTime:0},</span>l=<span class="cstat-no" title="statement not covered" >this.lastPlayStats.time,</span>p=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >("inbound-rtp"==t.type||"ssrc"==t.type&amp;&amp;null!=t.bytesReceived)&amp;&amp;("audio"==t.mediaType||t.id.indexOf("AudioStream")&gt;=0)?(0!=l&amp;&amp;(n.audioBitrate=8*(t.bytesReceived-i.lastPlayStats.audioBytesReceived)/(t.timestamp-l)),n.audioBitrate&lt;0&amp;&amp;(n.audioBitrate=0),n.audioJitter=t.jitter,n.audioPacketsLost=t.packetsLost,n.audioFractionLost=t.fractionLost,n.audioPacketsLostRate=(t.packetsLost-i.lastPlayStats.audioPacketsLost)/(t.timestamp-i.lastPlayStats.audioTime),i.lastPlayStats.audioBytesReceived=t.bytesReceived,i.lastPlayStats.audioPacketsLost=t.packetsLost,i.lastPlayStats.audioTime=t.timestamp,i.lastPlayStats.time=t.timestamp,i.lastPlayStats.audioBitrate=n.audioBitrate):("inbound-rtp"==t.type||"ssrc"==t.type&amp;&amp;null!=t.bytesReceived)&amp;&amp;("video"==t.mediaType||t.id.indexOf("VideoStream")&gt;=0)?(0!=l&amp;&amp;(n.videoBitrate=8*(t.bytesReceived-i.lastPlayStats.videoBytesReceived)/(t.timestamp-l),n.videoFPS=1e3*(t.framesDecoded-i.lastPlayStats.framesDecoded)/(t.timestamp-l)),n.videoBitrate&lt;0&amp;&amp;(n.videoBitrate=0),n.videoFPS&lt;0&amp;&amp;(n.videoFPS=0),n.nackCount=t.nackCount,n.pliCount=t.pliCount,n.videoFractionLost=t.fractionLost,n.videoFramesDecoded=t.framesDecoded,n.videoPacketsLostRate=(t.packetsLost-i.lastPlayStats.videoPacketsLost)/(t.timestamp-i.lastPlayStats.videoTime),i.lastPlayStats.videoBytesReceived=t.bytesReceived,i.lastPlayStats.framesDecoded=t.framesDecoded,i.lastPlayStats.videoPacketsLost=t.packetsLost,i.lastPlayStats.videoTime=t.timestamp,i.lastPlayStats.time=t.timestamp):"track"==t.type&amp;&amp;("video"==t.kind||t.id.indexOf("video")&gt;=0)||t.frameWidth?(n.frameHeight=t.frameHeight,n.frameWidth=t.frameWidth,0!=l&amp;&amp;(n.videoTransferFPS=1e3*(t.framesReceived-i.lastPlayStats.framesReceived)/(t.timestamp-l),n.videoFramesDropped=t.framesDropped-i.lastPlayStats.framesDropped),n.videoTransferFPS&lt;0&amp;&amp;(n.videoTransferFPS=0),n.videoFramesDropped&lt;0&amp;&amp;(n.videoFramesDropped=0),i.lastPlayStats.framesReceived=t.framesReceived,i.lastPlayStats.framesDropped=t.framesDropped):"track"==t.type&amp;&amp;("audio"==t.kind||t.id.indexOf("audio")&gt;=0)?(n.audioLevel=t.audioLevel,n.audioSendLevel=t.totalAudioEnergy,n.audioSamplingRate=t.totalSamplesDuration):"candidate-pair"==t.type&amp;&amp;(null!=t.totalRoundTripTime&amp;&amp;(n.totalRoundTripTime=t.totalRoundTripTime),null!=t.currentRoundTripTime&amp;&amp;(n.currentRoundTripTime=t.currentRoundTripTime,p=1e3*n.currentRoundTripTime))}</span>),n.audioQuality=this.getNetQuality(p,n.audioFractionLost),n.videoQuality=this.getNetQuality(p,n.videoFractionLost),this.uploadPlayQuality(n),0!=l&amp;&amp;this.onPlayQualityUpdate(this.streamId,n)}</span>}</span>,t.prototype.getNetQuality=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t&lt;600?i&gt;.4?2:i&gt;.3?4:5:t&lt;900?i&gt;.4?2:i&gt;.2?3:4:i&gt;.2?2:3}</span>,t.prototype.uploadPlayQuality=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.qualityUpload){var n=<span class="cstat-no" title="statement not covered" >Date.parse(new Date+"");<span class="cstat-no" title="statement not covered" ></span>(0==this.qualityUploadLastTime||n-this.qualityUploadLastTime&gt;=this.qualityUploadInterval)&amp;&amp;(t.stream_type="play",t.stream_id=this.streamId,t.timeStamp=n/1e3,this.logger.info("zp.upq.1 upload"+JSON.stringify(t)),this.signal.QualityReport(p.getSeq(),this.sessionId,t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >void 0!==l.report&amp;&amp;(i.qualityUpload=l.report,i.qualityUploadInterval=l.report_interval_ms)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.logger.info("zp.upq.1 upload failed "+t)}</span>),this.qualityUploadLastTime=n)}</span>}</span>,t.prototype.onRecvResetSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zp.orrs.1 received "),i==this.sessionId){<span class="cstat-no" title="statement not covered" >this.dataReport.addEvent(this.reportSeq,"RecvResetSession"),this.signal.sendCloseSessionAck(t,this.sessionId,0);v</span>ar l=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(p.playErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>this.negoTimer&amp;&amp;clearTimeout(this.negoTimer),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(l)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.orrs.1 cannot find session")}</span></span>,t.prototype.onRecvCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.1 reason: "+n.reason),this.dataReport.addEvent(this.reportSeq,"RecvCloseSession"),this.signal.sendCloseSessionAck(t,this.sessionId,0);v</span>ar l=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify(p.playErrorList.SESSION_CLOSED));<span class="cstat-no" title="statement not covered" ></span>l.msg+=n.reason,this.negoTimer&amp;&amp;clearTimeout(this.negoTimer);v</span>ar e=<span class="cstat-no" title="statement not covered" >1*n.reason,</span>v=<span class="cstat-no" title="statement not covered" >n.err_info&amp;&amp;JSON.parse(n.err_info).action?JSON.parse(n.err_info).action:null;<span class="cstat-no" title="statement not covered" ></span>if("number"==typeof e&amp;&amp;[24,28].includes(e)&amp;&amp;this.negoTryCount&lt;this.negoTryMaxCount||5==v){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.orcs.1 retry: "+this.streamId);v</span>ar T=<span class="cstat-no" title="statement not covered" >this.streamId,</span>E=<span class="cstat-no" title="statement not covered" >this.remoteVideo,</span>S=<span class="cstat-no" title="statement not covered" >this.audioOutput,</span>R=<span class="cstat-no" title="statement not covered" >this.playOption;<span class="cstat-no" title="statement not covered" ></span>this.signal.sendCloseSession(p.getSeq(),this.sessionId,1),this.resetPlay(),this.startPlay(T,E,S,R),++this.negoTryCount}</span>else<span class="cstat-no" title="statement not covered" >[4,8,10,11,12,14,26,27].includes(e)||2==v?!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(l):this.playStateUpdateError(l,!0)}</span></span>,t.prototype.onRecvStreamStatus=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zp.orss.0 call"),this.cameraStatus!==t.camera_status&amp;&amp;this.onRemoteCameraStatusUpdate(this.streamId,t.camera_status),this.micStatus!==t.mic_status&amp;&amp;this.onRemoteMicStatusUpdate(this.streamId,t.mic_status),this.cameraStatus=t.camera_status,this.micStatus=t.mic_status,-1===["all","video","audio"].indexOf(this.playOption.playType)){var i=<span class="cstat-no" title="statement not covered" >this.remoteVideo.srcObject;<span class="cstat-no" title="statement not covered" ></span>0!==t.camera_status&amp;&amp;i&amp;&amp;0!==i.getVideoTracks().length&amp;&amp;(i.getVideoTracks().forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.stop(),i.removeTrack(t)}</span>),this.remoteVideo.srcObject=i),0==t.camera_status&amp;&amp;i&amp;&amp;0==i.getVideoTracks().length&amp;&amp;(this.remoteVideo.srcObject=this.remoteStream.clone()),this.logger.debug("zp.orss.0 call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.orss.0 has set playType, ignore stream status")}</span></span>,t.prototype.onGotRemoteStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ogrs.0 called "+t),this.remoteVideo?(this.remoteStream=t,this.remoteVideo.srcObject=t.clone(),this.audioOputput&amp;&amp;this.setAudioDestination(this.audioOputput),this.gotStreamStatus&amp;&amp;this.onRecvStreamStatus(this.streamStatus),this.streamCenter.soundLevelDelegate&amp;&amp;this.startSoundLevel(),this.dataReport.addEvent(this.reportSeq,"GetRemoteStream")):this.logger.error("zp.ogrs.0 no remoteVideo")}</span>,t.prototype.sendCandidateInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zp.sci.1 called"),!(t=t.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!(t.candidate.indexOf("tcp")&gt;0)&amp;&amp;(!!t.candidate||void 0)}</span>))||t.length&lt;1?this.logger.info("zp.sci.1 cancelled"):(this.dataReport.eventStart(this.reportSeq,"SendIceCandidate"),this.stateNego!==l.ENUM_PLAY_STATE_NEGO.iceConnected&amp;&amp;(this.stateNego=l.ENUM_PLAY_STATE_NEGO.sendCandidate),this.logger.info("zp.sci.1  stateNego:sendCandidate"),this.signal.sendCandidateInfo(p.getSeq(),this.sessionId,t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,l){<span class="cstat-no" title="statement not covered" >i.logger.debug("zp.sci.1 send success"),i.dataReport.eventEnd(i.reportSeq,"SendIceCandidate")}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i.logger.error("zp.sci.1 failed to send: "+t.toString()),i.dataReport.eventEndWithMsg(i.reportSeq,"SendIceCandidate",{error:t}),i.playStateUpdateError(p.playErrorList.SEND_CANDIDATE_ERROR)}</span>))}</span>,t.prototype.shouldSendCloseSession=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.state!=p.ENUM_PLAY_STATE_UPDATE.stop&amp;&amp;this.state!=l.ENUM_PLAY_STATE.waitingSessionRsp}</span>,t.prototype.playStateUpdateError=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.psue.1 called ",t.code),!i&amp;&amp;(this.state===l.ENUM_PLAY_STATE.stop||this.negoTryCount&lt;this.negoTryMaxCount&amp;&amp;this.stateNego&lt;l.ENUM_PLAY_STATE_NEGO.iceConnected)||(0!=this.sessionId&amp;&amp;this.shouldSendCloseSession(t)&amp;&amp;(this.signal.sendCloseSession(p.getSeq(),this.sessionId,1),this.closeSessionSignal=!0),this.state=l.ENUM_PLAY_STATE.stop,this.onPlayStateUpdate(p.ENUM_PLAY_STATE_UPDATE.error,this.streamId,t),this.resetPlay())}</span>,t.prototype.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t.prototype.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.onVideoSizeChanged=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t.prototype.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.stopPlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.logger.info("zp.sp.1.1 called"),this.streamCenter.publisherList){<span class="cstat-no" title="statement not covered" >if(this.streamCenter.publisherList[t].publisher.state==l.ENUM_PUBLISH_STATE.publishing&amp;&amp;this.broadcasterStatus==l.ENUM_BROADCASTER_STATUS.start){<span class="cstat-no" title="statement not covered" >this.signal&amp;&amp;this.signal.sendBroadcasterStatus(p.getSeq(),this.sessionId,0),this.broadcasterStatus=l.ENUM_BROADCASTER_STATUS.stop;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.sessionId&amp;&amp;!this.closeSessionSignal&amp;&amp;this.signal.sendCloseSession(p.getSeq(),this.sessionId,0),this.dataReport.eventEndWithMsg(this.reportSeq,"PlayState",{state:this.state+""}),this.dataReport.addEvent(this.reportSeq,"StopPlay"),this.dataReport.addMsgExt(this.reportSeq,{stream:this.streamId,sessionId:this.sessionId}),this.dataReport.uploadReport(this.reportSeq,"RTCPlayStream"),this.resetPlay()}</span>,t.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.od.1 call"),this.logger.info("zp.od.1 websocket disconnect"),this.dataReport.addEvent(this.reportSeq,"OnDisconnect"),!this.tryingNexitSignal&amp;&amp;this.tryNextSignal(p.playErrorList.WEBSOCKET_ERROR)}</span>,t.prototype.tryNextSignal=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.tryingNexitSignal=!0;v</span>ar i=<span class="cstat-no" title="statement not covered" >this.streamId,</span>n=<span class="cstat-no" title="statement not covered" >this.signal.server,</span>e=<span class="cstat-no" title="statement not covered" >this.streamCenter.playerList[i],</span>v=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.serverUrls&amp;&amp;(v=e.serverUrls),this.nextSignalTryCount&gt;3*v.length?(this.logger.error("zp.tns.1 try max limit"),this.playStateUpdateError(t)):(v.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return i&lt;=v.indexOf(n)&amp;&amp;v.push(t)}</span>),v.splice(0,v.indexOf(n)+1),this.logger.info("zp.tns.1 try next signal "+i),this.signal&amp;&amp;this.signal.state==l.ENUM_CONNECT_STATE.connected&amp;&amp;this.signal.sendCloseSession(p.getSeq(),this.sessionId,1),this.signal&amp;&amp;this.signal.removeSession(this.sessionId),this.resetPlay(),this.streamCenter.connectPlayServer(i),this.nextSignalTryCount++)}</span>,t.prototype.startSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zp.ssl.1 call streamID: "+this.streamId),this.remoteStream&amp;&amp;0!=this.remoteStream.getAudioTracks().length){<span class="cstat-no" title="statement not covered" >this.script&amp;&amp;this.script.disconnect()&amp;&amp;(this.script=null),this.mic&amp;&amp;this.mic.disconnect()&amp;&amp;(this.mic=null),this.ac&amp;&amp;this.ac.close()&amp;&amp;(this.ac=null);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.ac=new("undefined"!=typeof webkitAudioContext?webkitAudioContext:AudioContext),this.mic=this.ac.createMediaStreamSource(this.remoteVideo.srcObject),this.script=this.ac.createScriptProcessor(4096,1,1),this.mic.connect(this.script),this.script.connect(this.ac.destination),this.script.onaudioprocess=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >for(var n=i.inputBuffer.getChannelData(0),l=0,p=0;p&lt;n.length;p++)<span class="cstat-no" title="statement not covered" >l&lt;n[p]&amp;&amp;(l=n[p]);<span class="cstat-no" title="statement not covered" >t</span></span>.soundLevel=100*l}</span>}</span>catch(t){<span class="cstat-no" title="statement not covered" >this.logger.error("zp.ssl.1 get sound level failed "+t)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.1 remote stream no found")}</span></span>,t.prototype.stopSoundLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.info("zp.ssl.1.1 call streamID: "+this.streamId),this.script&amp;&amp;this.script.disconnect(),this.mic&amp;&amp;this.mic.disconnect(),this.ac&amp;&amp;this.ac.close(),this.script=null,this.mic=null,this.ac=null}</span>,t}();i.ZegoPlayWeb=v},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=function(){function t(t,i){this.playerList={},this.publisherList={}}return t.prototype.setSessionInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){},t}();i.ZegoStreamCenter=l},function(t,i,n){"use strict";var l,p=this&amp;&amp;this.__extends||(l=Object.setPrototypeOf||<span class="branch-1 cbranch-no" title="branch not covered" >{__proto__:[]}instanceof Array&amp;</span>&amp;<span class="fstat-no" title="function not covered" ><span class="branch-2 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >t.__proto__=i}</span>|</span>|<span class="fstat-no" title="function not covered" ><span class="branch-3 cbranch-no" title="branch not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >for(var n in i)<span class="cstat-no" title="statement not covered" >i.hasOwnProperty(n)&amp;&amp;(t[n]=i[n])}</span></span>,</span>function(t,i){function n(){this.constructor=t}l(t,i),t.prototype=null===i?<span class="branch-0 cbranch-no" title="branch not covered" >Object.create(i):</span>(n.prototype=i.prototype,new n)});Object.defineProperty(i,"__esModule",{value:!0});var e=n(18),v=n(0),T=n(2),E=n(19),S=n(20),R=n(21),r=n(23),h=n(24),u=n(25),L=function(t){function i(){return t.call(this)||this}return p(i,t),i.prototype.init=function(){this.bindSocketHandler(),this.bindStreamHandler(),this.bindHeatBeatHandler(),this.bindRoomHandler(),this.bindMessageHandler(),this.bindLiveHandler(),this.bindStreamCenterHandler()},i.prototype.bindSocketHandler=function(){var t=this;this.socketCenter=new E.SocketCenter(this.logger,this.stateCenter),this.socketCenter.registerRouter("push_signal",<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.liveHandler.handlePushSignalMsg(i)}</span>),this.socketCenter.getSocket=function(i){return t.getSocket(i)},this.socketCenter.handlePushKickout=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.logger.info("zb.cm.bsh.0  call hpk"),t.roomHandler.setRunState(v.ENUM_RUN_STATE.logout),t.roomHandler.resetRoom(),t.onKickOut({code:v.sdkErrorList.KICK_OUT.code,msg:v.sdkErrorList.KICK_OUT.msg+i.body.reason}),t.logger.debug("zb.cm.bsh.0  call hpk success")}</span>,this.socketCenter.handlePushCustomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.messageHandler.handlePushCustomMsg(i)}</span>,this.socketCenter.handlePushUserStateUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.roomHandler.handlePushUserStateUpdateMsg(i)}</span>,this.socketCenter.handlePushRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.onRecvRoomMsg(i.body.chat_data,i.body.server_msg_id,i.body.ret_msg_id)}</span>,this.socketCenter.handlePushMergeMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.messageHandler.handlePushMergeMsg(i)}</span>,this.socketCenter.handlePushTransMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.messageHandler.handlePushTransMsg(i)}</span>,this.socketCenter.handleBigImMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.messageHandler.handleBigImMsgRsp(i)}</span>},i.prototype.bindStreamHandler=function(){var t=this;this.streamHandler=new R.StreamHandler(this.logger,this.stateCenter,this.socketCenter),this.streamHandler.onStreamUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onStreamUpdated(i,n)}</span>,this.streamHandler.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onPublishStateUpdate(i,n,l)}</span>,this.streamHandler.onStreamExtraInfoUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.onStreamExtraInfoUpdated(i)}</span>,this.streamHandler.setCDNInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.setCDNInfo(i,n)}</span>},i.prototype.bindHeatBeatHandler=function(){var t=this;this.heartBeatHandler=new r.HeartBeatHandler(this.logger,this.stateCenter,this.socketCenter),this.heartBeatHandler.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onRecvReliableMessage(i,n,l)}</span>,this.heartBeatHandler.handleFetchStreamListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.streamHandler.handleFetchStreamListRsp(i)}</span>,this.heartBeatHandler.fetchUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.roomHandler.fetchUserList()}</span>,this.heartBeatHandler.onUpdateOnlineCount=function(i,n){t.onUpdateOnlineCount(i,n)},this.heartBeatHandler.updateStreamInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l,p){<span class="cstat-no" title="statement not covered" >void 0===l&amp;&amp;(l=""),t.streamHandler.updateStreamInfo(i,n,l,p)}</span>,this.heartBeatHandler.hbLogout=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.onDisconnect(i)}</span>},i.prototype.bindRoomHandler=function(){var t=this;this.roomHandler=new S.RoomHandler(this.logger,this.stateCenter,this.socketCenter),this.roomHandler.loginSuccessCallBack=function(i,n){var l=n.body.hearbeat_interval&lt;v.MINIUM_HEARTBEAT_INTERVAL?<span class="branch-0 cbranch-no" title="branch not covered" >v.MINIUM_HEARTBEAT_INTERVAL:</span>n.body.hearbeat_interval;t.stateCenter.tryHeartbeatCount=0,t.stateCenter.heartbeatTimer&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >clearTimeout(t.stateCenter.heartbeatTimer),</span>t.heartBeatHandler.start(l),t.heartBeatHandler.resetCheckMessage(),t.heartBeatHandler.startCheckMessageTimeout(),t.streamCenter.setSessionInfo(t.stateCenter.appid,t.stateCenter.idName,t.stateCenter.token,t.stateCenter.testEnvironment),n.body.anchor_info&amp;&amp;t.onGetAnchorInfo(n.body.anchor_info.anchor_id_name,n.body.anchor_info.anchor_nick_name),n.body.online_count&amp;&amp;t.onUpdateOnlineCount(t.stateCenter.roomid,n.body.online_count),t.logger.info("zb.cm.brh hls userStateUpdate "+t.stateCenter.userStateUpdate),t.stateCenter.userStateUpdate&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t.logger.info("zb.cm.brh hls fetch all new userlist"),t.roomHandler.fetchUserList())</span>,t.streamHandler.handleStreamStart(i,n)},this.roomHandler.onGetTotalUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onGetTotalUserList(i,n)}</span>,this.roomHandler.resetRoomCallBack=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.heartBeatHandler.resetHeartbeat(),t.heartBeatHandler.resetCheckMessage(),t.resetStreamCenter()}</span>,this.roomHandler.onUserStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onUserStateUpdate(i,n)}</span>,this.roomHandler.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.onDisconnect(i)}</span>,this.roomHandler.loginBodyData=function(){return t.loginBodyData()}},i.prototype.bindMessageHandler=function(){var t=this;this.messageHandler=new h.MessageHandler(this.logger,this.stateCenter,this.socketCenter),this.messageHandler.onRecvCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onRecvCustomCommand(i,n,l)}</span>,this.messageHandler.onRecvBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onRecvBigRoomMessage(i,n)}</span>,this.messageHandler.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onRecvReliableMessage(i,n,l)}</span>},i.prototype.bindLiveHandler=function(){var t=this;this.liveHandler=new u.LiveHandler(this.logger,this.stateCenter,this.socketCenter),this.liveHandler.onRecvEndJoinLiveCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l,p){<span class="cstat-no" title="statement not covered" >t.onRecvEndJoinLiveCommand(i,n,l,p)}</span>,this.liveHandler.onRecvInviteJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l,p){<span class="cstat-no" title="statement not covered" >t.onRecvInviteJoinLiveRequest(i,n,l,p)}</span>,this.liveHandler.onRecvJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l,p){<span class="cstat-no" title="statement not covered" >t.onRecvJoinLiveRequest(i,n,l,p)}</span>},i.prototype.bindStreamCenterHandler=function(){var t=this;this.streamCenter.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onPlayStateUpdateHandle(i,n,l)}</span>,this.streamCenter.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onPlayQualityUpdate(i,n)}</span>,this.streamCenter.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onPublishStateUpdateHandle(i,n,l)}</span>,this.streamCenter.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onPublishQualityUpdate(i,n)}</span>,this.streamCenter.onPlayerStreamUrlUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onStreamUrlUpdate(i,n,l)}</span>,this.streamCenter.onVideoSizeChanged=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n,l){<span class="cstat-no" title="statement not covered" >t.onVideoSizeChanged(i,n,l)}</span>,this.streamCenter.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onRemoteCameraStatusUpdate(i,n)}</span>,this.streamCenter.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >t.onRemoteMicStatusUpdate(i,n)}</span>,this.streamCenter.onSoundLevelUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.onSoundLevelUpdate(i)}</span>},i.prototype.config=function(t){return this.logger.debug("zb.cm.cf call"),T.ClientUtil.checkConfigParam(t,this.logger)?(this.stateCenter.appid=t.appid,"string"==typeof t.server?(<span class="branch-0 cbranch-no" title="branch not covered" >this.stateCenter.server=t.server,this.stateCenter.serverBak=t.server)</span>:Array.isArray(t.server)&amp;&amp;t.server.length&gt;0&amp;&amp;(this.stateCenter.server=t.server[0],this.stateCenter.serverBak=t.server[1]||t.server[0]),this.logger.info("zb.cm.cf server "+JSON.stringify(t.server)),this.stateCenter.idName=t.idName,this.stateCenter.nickName=t.nickName,this.logger.setLogLevel(t.logLevel),!1===t.audienceCreateRoom&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.roomCreateFlag=0)</span>,t.remoteLogLevel?<span class="branch-0 cbranch-no" title="branch not covered" >this.logger.setRemoteLogLevel(t.remoteLogLevel):</span>this.logger.setRemoteLogLevel(0),this.logger.setSessionInfo(t.appid,"","",t.idName,"",v.PROTO_VERSION),t.logUrl&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.openLogServer(t.logUrl),</span>-1==this.stateCenter.server.indexOf("test2-wsliveroom-api.zego.im")&amp;&amp;-1==this.stateCenter.server.indexOf("wsliveroom-test.zegocloud.com")&amp;&amp;-1==this.stateCenter.server.indexOf("wsliveroom-test.zego.im")||(<span class="branch-3 cbranch-no" title="branch not covered" >this.stateCenter.testEnvironment=!0)</span>,this.stateCenter.configOK=!0,navigator&amp;&amp;navigator.appVersion&amp;&amp;this.logger.info("zb.cm.cf "+navigator.appVersion),this.logger.debug("zb.cm.cf call success"),!0):(<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.error("zb.cm.cf param error"),!1)</span>},i.prototype.login=function(t,i,n,l,p){"string"==typeof t?"string"==typeof n?1===i||2===i?this.roomHandler.login(t,i,n,null,l,p):<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.error("zb.rh.lg role error"):<span class="branch-1 cbranch-no" title="branch not covered" ></span>this.logger.error("zb.rh.lg token type error"):<span class="branch-1 cbranch-no" title="branch not covered" ></span>this.logger.error("zb.rh.lg roomid  type error")}</span>,i.prototype.loginWithAuthor=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p,e){<span class="cstat-no" title="statement not covered" >"string"!=typeof t||"string"!=typeof n||"string"!=typeof l||1!==i&amp;&amp;2!==i?this.logger.error("zb.rh.lg params error"):this.roomHandler.login(t,i,n,l,p,e)}</span>,i.prototype.logout=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.roomHandler.logout()}</span>,i.prototype.setUserStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"boolean"==typeof t?this.roomHandler.setUserStateUpdate(t):console.error("setUserStateUpdate param error")}</span>,i.prototype.onUserStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onGetTotalUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onUpdateOnlineCount=function(t,i){},i.prototype.onGetAnchorInfo=function(t,i){},i.prototype.release=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.cm.rl call"),this.roomHandler.setRunState(v.ENUM_RUN_STATE.logout),this.roomHandler.resetRoom(),this.logger.stopLogServer(),this.logger.debug("zb.cm.rl call success")}</span>,i.prototype.sendCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >return"string"!=typeof i&amp;&amp;"object"!=typeof i?(this.logger.error("zb.mh.scc params error"),!1):this.messageHandler.sendCustomCommand(t,i,n,l)}</span>,i.prototype.onRecvCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.sendRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){<span class="cstat-no" title="statement not covered" >this.messageHandler.sendRoomMsg(t,i,n,l,p)}</span>,i.prototype.onRecvRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.sendReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.messageHandler.sendReliableMessage(t,i,n,l)}</span>,i.prototype.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.sendBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){<span class="cstat-no" title="statement not covered" >this.messageHandler.sendBigRoomMessage(t,i,n,l,p)}</span>,i.prototype.onRecvBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.sendRelayMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.messageHandler.sendRelayMessage(t,i,n,l)}</span>,i.prototype.requestJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >return this.liveHandler.requestJoinLive(t,i,n,l)}</span>,i.prototype.onRecvJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){},i.prototype.inviteJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >return this.liveHandler.inviteJoinLive(t,i,n,l)}</span>,i.prototype.onRecvInviteJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){},i.prototype.endJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return this.liveHandler.endJoinLive(t,i,n)}</span>,i.prototype.onRecvEndJoinLiveCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){},i.prototype.respondJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >return this.liveHandler.respondJoinLive(t,i,n,l)}</span>,i.prototype.updateMixStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return this.streamHandler.updateMixStream(t,i,n)}</span>,i.prototype.stopMixStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return this.streamHandler.stopMixStream(t,i,n)}</span>,i.prototype.publishTarget=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >return this.streamHandler.publishTarget(t,i,n)}</span>,i.prototype.updateStreamExtraInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return this.streamHandler.updateStreamExtraInfo(t,i)}</span>,i.prototype.onStreamUrlUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onStreamUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onStreamExtraInfoUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},i.prototype.onPlayStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onVideoSizeChanged=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onRemoteCameraStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onRemoteMicStatusUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onPlayQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},i.prototype.onPublishQualityUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},i.prototype.onSoundLevelUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},i.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},i.prototype.onKickOut=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},i.getCurrentVersion=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return v.PROTO_VERSION}</span>,i}(e.Common);i.BaseCenter=L},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(1),e=function(){function t(){}return t.prototype.onPlayStateUpdateHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >1==t&amp;&amp;this.stopPlayingStream(i),this.onPlayStateUpdate(t,i,n)}</span>,t.prototype.onPublishStateUpdateHandle=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>0==t?this.stateCenter.publishStreamList[i]&amp;&amp;(this.stateCenter.publishStreamList[i].state==l.ENUM_PUBLISH_STREAM_STATE.tryPublish?(this.stateCenter.publishStreamList[i].state=l.ENUM_PUBLISH_STREAM_STATE.update_info,this.streamHandler.updateStreamInfo(i,l.ENUM_STREAM_SUB_CMD.liveBegin,this.stateCenter.publishStreamList[i].extra_info,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.stateCenter.publishStreamList[i]&amp;&amp;p.stateCenter.publishStreamList[i].state==l.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;(p.stateCenter.publishStreamList[i].state=l.ENUM_PUBLISH_STREAM_STATE.stop,p.onPublishStateUpdate(1,i,t),p.streamCenter.stopPlayingStream(i))}</span>)):this.WebrtcOnPublishStateUpdateHandle(t,i,n)):(this.onPublishStateUpdate(t,i,n),1==t&amp;&amp;this.stopPublishingStream(i))}</span>,t.prototype.resetStreamCenter=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.customUrl&amp;&amp;(this.stateCenter.customUrl=null),this.streamCenter.reset(),!this.socketCenter.isDisConnect())<span class="cstat-no" title="statement not covered" >for(var t in this.stateCenter.publishStreamList)<span class="cstat-no" title="statement not covered" >this.stateCenter.publishStreamList[t].state==l.ENUM_PUBLISH_STREAM_STATE.publishing&amp;&amp;this.streamHandler.updateStreamInfo(t,l.ENUM_STREAM_SUB_CMD.liveEnd,this.stateCenter.publishStreamList[t].extra_info)}</span></span></span>,t.prototype.handleFetchWebRtcUrlRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.body.stream_id,</span>n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(t.body.urls&amp;&amp;Array.isArray(t.body.urls)&amp;&amp;t.body.urls.length&gt;0?n=!0:this.logger.error("cb.cm.hfwur signal url is empty"),"push"===t.body.ptype)<span class="cstat-no" title="statement not covered" >!n&amp;&amp;this.onPublishStateUpdate(1,i,p.publishErrorList.DISPATCH_ERROR)&amp;&amp;this.stopPublishingStream(i),this.stateCenter.publishStreamList[i]?this.streamCenter.startPublishingStream(i,t.body.urls):this.logger.error("cb.cm.hfwur no streamid to publish");e</span>lse <span class="cstat-no" title="statement not covered" >if("pull"==t.body.ptype){<span class="cstat-no" title="statement not covered" >!n&amp;&amp;this.onPlayStateUpdate(1,i,p.playErrorList.DISPATCH_ERROR)&amp;&amp;this.stopPlayingStream(i);<span class="cstat-no" title="statement not covered" >f</span>or(var l=!1,e=0;e&lt;this.stateCenter.streamList.length;e++)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.streamList[e].stream_id===i){<span class="cstat-no" title="statement not covered" >l=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>0</span></span>==l&amp;&amp;this.logger.warn("cb.cm.hfwur cannot find stream, continue to play"),this.streamCenter.startPlayingStream(i,t.body.urls)}</span>}</span></span>,t}();i.Common=e},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(2),e=function(){function t(t,i){var n=this;this.cmdSeq=0,this.responseRouters={},this.logger=t,this.stateCenter=i,this.responseRouters={push_kickout:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handlePushKickout(t)}</span>,push_custommsg:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handlePushCustomMsg(t)}</span>,push_im_chat:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handlePushRoomMsg(t)}</span>,push_userlist_update:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handlePushUserStateUpdateMsg(t)}</span>,push_merge_message:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handlePushMergeMsg(t)}</span>,trans:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handleTransRsp(t)}</span>,push_trans:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handlePushTransMsg(t)}</span>}}return t.prototype.handlePushKickout=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handlePushCustomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handlePushRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handlePushUserStateUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handlePushMergeMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handlePushTransMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handleBigImMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handleTransRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(0==t.body.err_code){var i=<span class="cstat-no" title="statement not covered" >t.body.trans_type;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.transSeqMap[i]?(this.stateCenter.transSeqMap[i].seq=t.body.trans_seq,this.logger.debug("zb.sc.htr trans "+i+" seq "+t.body.trans_seq)):this.logger.error("zb.sc.htr cannot match send info")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sc.htr trans send error "+t.body.err_code);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sc.htr not login")}</span></span>,t.prototype.handleBizChannelRspCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >0===t.body.err_code?null!=i.success&amp;&amp;i.success(t.header.seq,t.body.cmd,t.body.rsp_body):null!=i.error&amp;&amp;i.error(t.body.err_code,t.header.seq,t.body.rsp_body)}</span>,t.prototype.registerRouter=function(t,i){this.responseRouters[t]=i},t.prototype.getSocket=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null}</span>,t.prototype.getHeaderV2=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{Protocol:"req_v2",cmd:t,appid:this.stateCenter.appid,seq:++this.cmdSeq,user_id:this.stateCenter.userid,session_id:this.stateCenter.sessionid||"",room_id:this.stateCenter.roomid||""}}</span>,t.prototype.getHeader=function(t){return{Protocol:"req",cmd:t,appid:this.stateCenter.appid,seq:++this.cmdSeq,user_id:this.stateCenter.userid,session_id:this.stateCenter.sessionid||"",room_id:this.stateCenter.roomid||<span class="branch-1 cbranch-no" title="branch not covered" >""}</span>},t.prototype.sendMessage=function(t,i,n,p){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.logger.debug("zb.sc.sm call "+t),this.isDisConnect())<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sc.sm error  "+t+"websocket is disconnected"),-1;v</span>ar e="V1"===l.ROOMVERSION?this.getHeader(t):<span class="branch-1 cbranch-no" title="branch not covered" >this.getHeaderV2(t),</span>v={header:e,body:i};<span class="missing-if-branch" title="if path not taken" >I</span>if(null==n&amp;&amp;(n=null),null==p&amp;&amp;(p=null),null!=n||null!=p){var T=<span class="cstat-no" title="statement not covered" >{data:v,seq:e.seq,deleted:!1,time:Date.parse(new Date+""),success:n,error:p},</span>E=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendCommandList.push(T);<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.sendCommandMap[T.seq]=E}</span>return this.websocket.send(JSON.stringify(v)),this.logger.debug("zb.sc.sm success"),e.seq},t.prototype.sendCustomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.sc.scm call"),this.isDisConnect())<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sc.scm error"),!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >"V1"===l.ROOMVERSION?this.getHeader(t):this.getHeaderV2(t),</span>v=<span class="cstat-no" title="statement not covered" >{header:e,body:i},</span>T=<span class="cstat-no" title="statement not covered" >JSON.stringify(v);<span class="cstat-no" title="statement not covered" ></span>null==n&amp;&amp;(n=null),null==p&amp;&amp;(p=null);v</span>ar E=<span class="cstat-no" title="statement not covered" >{data:v,seq:e.seq,deleted:!1,time:Date.parse(new Date+""),success:n,error:p},</span>S=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendDataList.push(E);<span class="cstat-no" title="statement not covered" ></span>return this.stateCenter.sendDataMap[E.seq]=S,this.websocket.send(T),this.logger.debug("zb.sc.scm success seq: ",e.seq),!0}</span>,t.prototype.isDisConnect=function(){return!this.websocket||1!==this.websocket.readyState},t.prototype.closeSocket=function(){this.websocket&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.info("zb.sc.cs close websocket"),this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null)</span>},t.prototype.createSocket=function(t){this.websocket=this.getSocket(t)},t.prototype.openHandler=function(t){this.websocket.onopen=t},t.prototype.closeHandler=function(t){this.websocket.onclose=t},t.prototype.errorHandler=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.websocket.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.logger.error("zb.sc.oe msg="+JSON.stringify(i))}</span>}</span>,t.prototype.checkResponse=function(t){return(t.header.appid!==this.stateCenter.appid||t.header.session_id!==this.stateCenter.sessionid||t.header.user_id!==this.stateCenter.userid||t.header.room_id!==this.stateCenter.roomid||this.stateCenter.runState!==l.ENUM_RUN_STATE.login)&amp;&amp;(<span class="branch-5 cbranch-no" title="branch not covered" >this.logger.error("zb.sc.crp check session fail."),!0)</span>},t.prototype.responseHandler=function(){var t=this;this.websocket.onmessage=function(i){var n=JSON.parse(i.data);t.logger.info("zb.sc.ws.rph jsonmsg= ",n.header.cmd),t.logger.info("zb.sc.ws.rph jsonmsg= ",i.data),0!==n.body.err_code&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >n.body.err_message&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >t.logger.error("zb.sc.ws.rph cmd="+n.header.cmd+", err_code="+n.body.err_code+", err_message="+n.body.err_message+" "),</span>"login"!==n.header.cmd?"logout"!==n.header.cmd?t.stateCenter.isLogin()?t.checkResponse(n)?<span class="branch-0 cbranch-no" title="branch not covered" >t.logger.error("zb.sc.ws.rph check session fail."):</span>(t.handleSendCommandMsgRsp(n),t.logger.info("zb.sc.ws.rph cmd="+n.header.cmd+",function="+!!t.responseRouters[n.header.cmd]),t.responseRouters[n.header.cmd]&amp;&amp;t.responseRouters[n.header.cmd](n)):<span class="branch-1 cbranch-no" title="branch not covered" >t.logger.warn("zb.sc.ws.rph  already logout"):<span class="branch-1 cbranch-no" title="branch not covered" ></span>t.responseRouters.logout(n,t.cmdSeq):</span>t.responseRouters.login(n,t.cmdSeq)}},t.prototype.handleSendCommandMsgRsp=function(t){this.logger.debug("zb.sc.hscmr call");var i,n=this.stateCenter.sendCommandMap[t.header.seq];null!=n&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >"login"==(i=n._data).data.header.cmd?this.logger.debug("zb.sc.hscmr don't check "+i.data.header.cmd):"relay"==i.data.header.cmd?this.handleRelayRspCallback(t,i):"bigim_chat"==i.data.header.cmd?this.handleBigImRspCallback(t,i):"biz_channel"==i.data.header.cmd?this.handleBizChannelRspCallback(t,i):0===t.body.err_code?null!=i.success&amp;&amp;i.success(t.header.seq):null!=i.error&amp;&amp;i.error(p.ClientUtil.getServerError(t.body.err_code),t.header.seq),delete this.stateCenter.sendCommandMap[t.header.seq],this.stateCenter.sendCommandList.remove(n))</span>,this.logger.debug("zb.sc.hscmr call success")},t.prototype.handleRelayRspCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >0===t.body.err_code?null!=i.success&amp;&amp;i.success(t.header.seq,t.body.relay_result):null!=i.error&amp;&amp;i.error(p.ClientUtil.getServerError(t.body.err_code),t.header.seq)}</span>,t.prototype.handleBigImRspCallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >0===t.body.err_code?null!=i.success&amp;&amp;this.handleBigImMsgRsp(t):null!=i.error&amp;&amp;i.error(p.ClientUtil.getServerError(t.body.err_code),t.header.seq)}</span>,t}();i.SocketCenter=e},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(2),e=function(){function t(t,i,n){this.logger=t,this.socketCenter=n,this.stateCenter=i}return t.prototype.setRunState=function(t){this.logger.debug("zb.rh.srs old="+this.stateCenter.runState+", new="+t),this.stateCenter.lastRunState=this.stateCenter.runState,this.stateCenter.runState=t},t.prototype.resetTryLogin=function(){this.logger.debug("zb.rh.rtl call"),clearTimeout(this.stateCenter.tryLoginTimer),this.stateCenter.tryLoginTimer=null,this.stateCenter.tryLoginCount=0,this.logger.debug("zb.rh.rtl call success")},t.prototype.resetBigRoomInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.stateCenter.transSeqMap={},this.stateCenter.realyMessageList=[],this.stateCenter.relayTimer&amp;&amp;(clearTimeout(this.stateCenter.relayTimer),this.stateCenter.relayTimer=null),this.stateCenter.bigImLastTimeIndex=0,this.stateCenter.bigIMmessageList=[],this.stateCenter.bigImCallbackMap={},this.stateCenter.bigImTimer&amp;&amp;(clearTimeout(this.stateCenter.bigImTimer),this.stateCenter.bigImTimer=null),this.stateCenter.serverTimeOffset=0,this.stateCenter.datiTimeWindow=0,this.stateCenter.bigimTimeWindow=0}</span>,t.prototype.resetRoom=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zb.rh.rr call"),this.resetTryLogin(),this.resetRoomCallBack(),this.stateCenter.streamList=[],this.stateCenter.streamQuerying=!1,this.stateCenter.publishStreamList={},this.stateCenter.joinLiveCallbackMap={},this.stateCenter.joinLiveRequestMap={},this.stateCenter.streamUrlMap={},this.resetBigRoomInfo(),this.stateCenter.cmdCallback={},this.logger.debug("zb.rh.rr call send logout=",this.stateCenter.sessionid),"0"!==this.stateCenter.sessionid&amp;&amp;this.stateCenter.runState!==l.ENUM_RUN_STATE.logout){<span class="cstat-no" title="statement not covered" >this.socketCenter.registerRouter("logout",<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.handleLogoutRsp(i)}</span>),this.socketCenter.sendMessage("logout",{reserve:0})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.socketCenter.closeSocket(),this.setRunState(l.ENUM_RUN_STATE.logout),this.stateCenter.userid="",this.stateCenter.sessionid="",this.logger.setSessionInfo(this.stateCenter.appid,this.stateCenter.roomid,this.stateCenter.sessionid,this.stateCenter.userid,this.stateCenter.idName,l.PROTO_VERSION),this.logger.debug("zb.rh.rr call success")}</span>,t.prototype.resetRoomCallBack=<span class="fstat-no" title="function not covered" >fu</span>nction(){},t.prototype.onDisconnect=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.loginSuccessCallBack=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.onGetTotalUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.login=function(t,i,n,e,v,T){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.logger.setSessionInfo(this.stateCenter.appid,t,"","",this.stateCenter.idName,l.PROTO_VERSION),this.logger.info("zb.rh.lg call:",t,n),e&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.third_token=e)</span>,!this.stateCenter.configOK||!p.ClientUtil.checkLoginParam(t,n))<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.rh.lg param error"),void T({code:"",msg:"param error"});t</span>his.stateCenter.runState!==l.ENUM_RUN_STATE.logout&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.debug("zb.rh.lg reset"),this.setRunState(l.ENUM_RUN_STATE.logout),this.resetRoom())</span>,this.logger.debug("zb.rh.lg begin"),this.setRunState(l.ENUM_RUN_STATE.trylogin),this.stateCenter.roomid=t,this.stateCenter.token=n,this.stateCenter.role=i,p.ClientUtil.registerCallback("login",{success:v,error:T},this.stateCenter.callbackList),this.resetTryLogin(),this.tryLogin(),this.logger.info("zb.rh.lg call success")},t.prototype.loginBodyData=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return null}</span>,t.prototype.tryLogin=function(){var t=this;<span class="missing-if-branch" title="else path not taken" >E</span>if(this.logger.debug("zb.rh.tl call"),this.stateCenter.runState===l.ENUM_RUN_STATE.trylogin){<span class="missing-if-branch" title="if path not taken" >I</span>if(++this.stateCenter.tryLoginCount&gt;l.MAX_TRY_LOGIN_COUNT){<span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.tl fail times limit");v</span>ar i=<span class="cstat-no" title="statement not covered" >this.stateCenter.lastRunState;<span class="cstat-no" title="statement not covered" ></span>return this.setRunState(l.ENUM_RUN_STATE.logout),this.resetRoom(),void(i==l.ENUM_RUN_STATE.login?(this.logger.error("zb.rh.tl fail and disconnect"),this.onDisconnect(l.sdkErrorList.LOGIN_DISCONNECT)):(this.logger.info("zb.rh.tl fail and callback user"),p.ClientUtil.actionErrorCallback("login",this.stateCenter.callbackList)(l.sdkErrorList.LOGIN_TIMEOUT)))}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(this.stateCenter.startConnceTime=(new Date).getTime(),console.warn("start connect",this.stateCenter.startConnceTime),this.socketCenter.isDisConnect()){this.logger.debug("zb.rh.tl need new websocket");try{this.socketCenter.closeSocket(),this.logger.debug("zb.rh.tl new websocket"),this.socketCenter.createSocket(this.stateCenter.tryLoginCount%2==1?this.stateCenter.server:<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.serverBak)</span>,this.socketCenter.registerRouter("login",function(i,n){t.handleLoginRsp(i,n)}),this.socketCenter.closeHandler(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.socketCenter.closeSocket(),t.closeHandler(i)}</span>),this.socketCenter.openHandler(function(){t.openHandler()})}catch(t){<span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.tl websocket err:"+t)}</span>}else{var n=<span class="cstat-no" title="statement not covered" >this.loginBodyData();<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.rh.tl use current websocket and sent login"),this.socketCenter.sendMessage("login",n)}</span>this.stateCenter.tryLoginTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.tryLogin()}</span>,l.TRY_LOGIN_INTERVAL[this.stateCenter.tryLoginCount%l.MAX_TRY_LOGIN_COUNT]),this.logger.info("zb.rh.tl call success")}else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.tl state error")}</span>,t.prototype.handleLoginRsp=function(t,i){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.logger.debug("zb.rh.hlr call"),this.stateCenter.runState===l.ENUM_RUN_STATE.trylogin){<span class="missing-if-branch" title="else path not taken" >E</span>if(t.header.seq===i)return 0!==t.body.err_code?(<span class="branch-0 cbranch-no" title="branch not covered" >this.handleLoginFail(t),void this.logger.error("zb.rh.hlr server error=",t.body.err_code))</span>:(this.handleLoginSuccess(t),void this.logger.info("zb.rh.hlr call success."));<span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.hlr in wrong seq, local=",i,",recv=",t.header.seq)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.hlr state error")}</span>,t.prototype.handleLoginFail=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.rh.hlf call"),p.ClientUtil.isKeepTryLogin(t.body.err_code))<span class="cstat-no" title="statement not covered" >this.logger.warn("zb.rh.hlf KeepTry true");e</span>lse{var i=<span class="cstat-no" title="statement not covered" >this.stateCenter.lastRunState;<span class="cstat-no" title="statement not covered" ></span>this.setRunState(l.ENUM_RUN_STATE.logout),this.resetRoom();v</span>ar n=<span class="cstat-no" title="statement not covered" >p.ClientUtil.getServerError(t.body.err_code);<span class="cstat-no" title="statement not covered" ></span>i===l.ENUM_RUN_STATE.login?(this.logger.info("zb.rh.hlf callback disconnect"),this.onDisconnect(n)):(this.logger.info("zb.rh.hlf callback error"),p.ClientUtil.actionErrorCallback("login",this.stateCenter.callbackList)(n)),this.logger.debug("zb.rh.hlf call success")}</span>}</span>,t.prototype.handleLoginSuccess=function(t){this.stateCenter.startloginSucTime=(new Date).getTime(),console.warn("login suc",this.stateCenter.startloginSucTime,this.stateCenter.startloginSucTime-this.stateCenter.startloginTime,this.stateCenter.startloginSucTime-this.stateCenter.startConnceTime),this.logger.info("zb.rh.hls call");var i=this.stateCenter.lastRunState;<span class="missing-if-branch" title="else path not taken" >E</span>if(this.setRunState(l.ENUM_RUN_STATE.login),this.stateCenter.userid=t.body.user_id,this.stateCenter.sessionid=t.body.session_id,this.stateCenter.anchor_info=t.body.anchor_info||<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.anchor_info,</span>this.stateCenter.userListInterval=t.body.userlist_interval||<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.userListInterval,</span>this.stateCenter.userListMergeInterval=t.body.userlist_merge_timeout||<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.userListMergeInterval,</span>this.logger.setSessionInfo(this.stateCenter.appid,this.stateCenter.roomid,this.stateCenter.sessionid,this.stateCenter.userid,this.stateCenter.idName,l.PROTO_VERSION),t.body.config_info&amp;&amp;(this.logger.setRemoteLogLevel(t.body.config_info.log_level),""!=t.body.config_info.log_url&amp;&amp;this.logger.openLogServer(t.body.config_info.log_url)),null!=t.body.ret_timestamp&amp;&amp;"string"==typeof t.body.ret_timestamp){var n=parseFloat(t.body.ret_timestamp);this.stateCenter.serverTimeOffset=0==n?<span class="branch-0 cbranch-no" title="branch not covered" >0:</span>t.body.ret_timestamp-(new Date).getTime()}t.body.bigim_time_window&amp;&amp;"number"==typeof t.body.bigim_time_window&amp;&amp;(this.stateCenter.bigimTimeWindow=t.body.bigim_time_window),t.body.dati_time_window&amp;&amp;"number"==typeof t.body.dati_time_window&amp;&amp;(this.stateCenter.datiTimeWindow=t.body.dati_time_window),t.body.cluster_env&amp;&amp;1===t.body.cluster_env&amp;&amp;(this.stateCenter.testEnvironment=!0),this.resetTryLogin(),this.loginSuccessCallBack(i,t)},t.prototype.openHandler=function(){this.logger.info("zb.rh.oh websocket.onpen call"),this.socketCenter.responseHandler();var t=this.loginBodyData();this.logger.info("zb.rh.oh websocket.onpen send login"),this.stateCenter.startloginTime=(new Date).getTime(),console.warn("start login",this.stateCenter.startloginTime,this.stateCenter.startloginTime-this.stateCenter.startConnceTime),this.socketCenter.sendMessage("login",t),this.logger.debug("zb.rh.oh websocket.onpen call success")},t.prototype.closeHandler=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.rh.ws.oc room websocket close "+JSON.stringify(t.code)),this.stateCenter.runState!==l.ENUM_RUN_STATE.logout?this.stateCenter.runState===l.ENUM_RUN_STATE.trylogin&amp;&amp;this.stateCenter.tryLoginCount&lt;=l.MAX_TRY_LOGIN_COUNT?this.logger.info("zb.rh.ws.oc is called because of try login"):this.stateCenter.runState===l.ENUM_RUN_STATE.login?(this.logger.info("zb.rh.ws.oc is called because of network broken, try again"),this.setRunState(l.ENUM_RUN_STATE.trylogin),this.resetTryLogin(),this.tryLogin()):(this.logger.error("zb.rh.ws.oc out of think!!!"),this.setRunState(l.ENUM_RUN_STATE.logout),this.resetRoom(),this.onDisconnect(l.sdkErrorList.UNKNOWN)):this.logger.info("zb.rh.ws.oc onclose logout flow call websocket.close")}</span>,t.prototype.logout=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zb.rh.lo call"),this.stateCenter.runState===l.ENUM_RUN_STATE.logout?(this.logger.warn("zb.rh.lo at logout"),!1):(this.resetRoom(),this.logger.info("zb.rh.lo call success"),!0)}</span>,t.prototype.setUserStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.logger.debug("zb.rh.su call"),"boolean"!=typeof t?(this.logger.info("zb.rh.su param error"),!1):(this.stateCenter.userStateUpdate=t,this.logger.info("zb.rh.su call success "+t),!0)}</span>,t.prototype.fetchUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.rh.ful call"),this.stateCenter.userQuerying?this.logger.warn("zb.rh.ful is already querying"):(this.stateCenter.userQuerying=!0,this.stateCenter.userTempList=[],"V1"===l.ROOMVERSION?this.fetchUserListWithPage(0):this.fetchUserListWithPageV2(0),this.logger.info("zb.rh.ful the first time call"))}</span>,t.prototype.fetchUserListWithPageV2=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.rh.fulwp call"),this.socketCenter.registerRouter("user_list_v2",<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >i.handleFetchUserListRspV2(t,n)}</span>),this.socketCenter.sendMessage("user_list_v2",{marker:0===t?"":t+"",mode:0,limit:100}),this.logger.info("zb.rh.fulwp call success")}</span>,t.prototype.fetchUserListWithPage=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.rh.fulwp call"),this.socketCenter.registerRouter("user_list",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.handleFetchUserListRsp(t)}</span>),this.socketCenter.sendMessage("user_list",{user_index:t,sort_type:0}),this.logger.info("zb.rh.fulwp call success")}</span>,t.prototype.handleFetchUserListRspV2=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.rh.hfulr call"),0!=i.body.err_code)<span class="cstat-no" title="statement not covered" >return this.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,void this.logger.info("zb.rh.hfulr fetch error "+i.body.err_code);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.stateCenter.userStateUpdate){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.userTempList=this.stateCenter.userTempList.concat(i.body.user_baseinfos),t!=i.body.marker)<span class="cstat-no" title="statement not covered" >return this.logger.warn("zb.rh.hfulr fetch another page"),void this.fetchUserListWithPageV2(t+1);<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.userSeq=i.body.server_user_seq,this.logger.info("zb.rh.hfulr set user Seq "+this.stateCenter.userSeq);<span class="cstat-no" title="statement not covered" >f</span>or(var n=[],l=0;l&lt;this.stateCenter.userTempList.length;l++){var p=<span class="cstat-no" title="statement not covered" >{idName:this.stateCenter.userTempList[l].id_name,nickName:this.stateCenter.userTempList[l].nick_name,role:this.stateCenter.userTempList[l].role};<span class="cstat-no" title="statement not covered" ></span>n.push(p)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,this.onGetTotalUserList(this.stateCenter.roomid,n),this.stateCenter.userTempList=[],this.logger.info("zb.rh.hfulr call success user_list "+n+" count "+n.length)}</span>}</span>,t.prototype.handleFetchUserListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.rh.hfulr call"),0!=t.body.err_code)<span class="cstat-no" title="statement not covered" >return this.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,void this.logger.info("zb.rh.hfulr fetch error "+t.body.err_code);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.stateCenter.userStateUpdate){<span class="cstat-no" title="statement not covered" >this.stateCenter.userTempList=this.stateCenter.userTempList.concat(t.body.user_baseinfos);v</span>ar i=<span class="cstat-no" title="statement not covered" >t.body.ret_user_index;<span class="cstat-no" title="statement not covered" ></span>if(i!=t.body.server_user_index)<span class="cstat-no" title="statement not covered" >return this.logger.warn("zb.rh.hfulr fetch another page"),void this.fetchUserListWithPage(i+1);<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.userSeq=t.body.server_user_seq,this.logger.info("zb.rh.hfulr set user Seq "+this.stateCenter.userSeq);<span class="cstat-no" title="statement not covered" >f</span>or(var n=[],l=0;l&lt;this.stateCenter.userTempList.length;l++){var p=<span class="cstat-no" title="statement not covered" >{idName:this.stateCenter.userTempList[l].id_name,nickName:this.stateCenter.userTempList[l].nick_name,role:this.stateCenter.userTempList[l].role};<span class="cstat-no" title="statement not covered" ></span>n.push(p)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.stateCenter.userQuerying=!1,this.stateCenter.lastUserQueryTime=Date.now()+this.stateCenter.userListInterval,this.onGetTotalUserList(this.stateCenter.roomid,n),this.stateCenter.userTempList=[],this.logger.info("zb.rh.hfulr call success user_list "+n+" count "+n.length)}</span>}</span>,t.prototype.handleLogoutRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.rh.hlor result=",t.body.err_code)}</span>,t.prototype.handlePushUserStateUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.rh.hpus call"),this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(this.stateCenter.userStateUpdate)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.userSeq+t.body.user_actions.length===t.body.user_list_seq){<span class="cstat-no" title="statement not covered" >this.stateCenter.userSeq=t.body.user_list_seq,this.logger.debug("zb.rh.hpus push userSeq "+this.stateCenter.userSeq);<span class="cstat-no" title="statement not covered" >f</span>or(var i=[],n=0;n&lt;t.body.user_actions.length;n++){var l=<span class="cstat-no" title="statement not covered" >{action:t.body.user_actions[n].Action,idName:t.body.user_actions[n].IdName,nickName:t.body.user_actions[n].NickName,role:t.body.user_actions[n].Role,loginTime:t.body.user_actions[n].LoginTime};<span class="cstat-no" title="statement not covered" ></span>i.push(l)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.onUserStateUpdate(t.body.room_id,i),this.logger.info("zb.rh.hpus call success")}</span>else <span class="cstat-no" title="statement not covered" >this.mergeUserByUserSeq(t.body.user_list_seq,t.body.user_actions);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.info("zb.rh.hpus no userStateUpdate flag");e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.rh.hpus not login")}</span></span>,t.prototype.onUserStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.mergeUserByUserSeq=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.userSeqMergeMap||(this.logger.warn("zb.rh.hpus new merge userlist "+this.stateCenter.userSeq+" server "+t),this.stateCenter.userSeqMergeMap={},this.stateCenter.userSeqMergeTimer&amp;&amp;clearTimeout(this.stateCenter.userSeqMergeTimer),this.stateCenter.userSeqMergeTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object.keys(n.stateCenter.userSeqMergeMap).map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return+t}</span>).sort(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t-i}</span>);<span class="cstat-no" title="statement not covered" ></span>if(t[t.length-1]-t[0]+1===t.length)<span class="cstat-no" title="statement not covered" >n.mergeUser(t);e</span>lse{<span class="cstat-no" title="statement not covered" >n.stateCenter.userSeqMergeMap=null;v</span>ar i=<span class="cstat-no" title="statement not covered" >n.stateCenter.lastUserQueryTime-Date.now();<span class="cstat-no" title="statement not covered" ></span>n.logger.info("zb.rh.hpus fetch merge userlist "+n.stateCenter.userSeq+" userSeqList "+t.join(",")+" wait "+i),i&gt;0?(n.stateCenter.userQueryTimer&amp;&amp;clearTimeout(n.stateCenter.userQueryTimer),n.stateCenter.userQueryTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.fetchUserList()}</span>,i)):n.fetchUserList()}</span>}</span>,this.stateCenter.userListMergeInterval)),this.logger.warn("zb.rh.hpus merge userlist "+this.stateCenter.userSeq+" server "+t+" userlist "+i.length),this.stateCenter.userSeqMergeMap[t]=i}</span>,t.prototype.mergeUser=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.rh.hpus merge userlist "+this.stateCenter.userSeq+" userSeqList "+t.join(",")),this.stateCenter.userSeq=t[t.length-1];v</span>ar n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.stateCenter.userSeqMergeMap[t].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n[t.IdName]=t}</span>)}</span>),this.stateCenter.userSeqMergeMap=null;v</span>ar l=<span class="cstat-no" title="statement not covered" >Object.values(n).map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{action:t.Action,idName:t.IdName,nickName:t.NickName,role:t.Role,loginTime:t.LoginTime?String(t.LoginTime):""}}</span>);<span class="cstat-no" title="statement not covered" ></span>l.sort(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t.loginTime.localeCompare(i.loginTime)}</span>),this.onUserStateUpdate(this.stateCenter.roomid,l)}</span>,t}();i.RoomHandler=e},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(2),e=n(22),v=function(){function t(t,i,n){this.logger=t,this.socketCenter=n,this.stateCenter=i}return t.prototype.setCDNInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.onStreamUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.onStreamExtraInfoUpdated=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.handleStreamStart=function(t,i){var n=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(this.stateCenter.streamQuerying=!1,this.socketCenter.registerRouter("stream",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handleStreamUpdateRsp(t)}</span>),this.socketCenter.registerRouter("push_stream_update",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handlePushStreamUpdateMsg(t)}</span>),t==l.ENUM_RUN_STATE.login)<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hss recover from disconnect so call streamupdate"),this.handleFullUpdateStream(i.body.stream_seq,i.body.stream_info||[]);e</span>lse{this.logger.info("zb.sh.hss success callback user"),this.stateCenter.streamList=i.body.stream_info||<span class="branch-1 cbranch-no" title="branch not covered" >[],</span>this.stateCenter.streamSeq=i.body.stream_seq;for(var e=0;e&lt;this.stateCenter.streamList.length;e++)<span class="cstat-no" title="statement not covered" >this.stateCenter.streamList[e].anchor_id_name==this.stateCenter.idName&amp;&amp;(this.updateStreamInfo(this.stateCenter.streamList[e].stream_id,l.ENUM_STREAM_SUB_CMD.liveEnd),this.stateCenter.streamList.splice(e--,1));v</span>ar v=this.makeCallbackStreamList(this.stateCenter.streamList);p.ClientUtil.actionSuccessCallback("login",this.stateCenter.callbackList)(v)}},t.prototype.onPublishStateUpdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t.prototype.updateStreamInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>void 0===n&amp;&amp;(n=""),this.logger.debug("zb.sh.usi call");v</span>ar e=<span class="cstat-no" title="statement not covered" >{stream_id:t,extra_info:n},</span>v=<span class="cstat-no" title="statement not covered" >{sub_cmd:i,stream_msg:JSON.stringify(e)};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.registerRouter("stream",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >p.handleStreamUpdateRsp(t)}</span>),this.socketCenter.sendMessage("stream",v,void 0,l),this.logger.info("zb.sh.usi call success cmd "+i)}</span>,t.prototype.handleStreamUpdateRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(0==t.body.err_code){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hsur stream seq "+this.stateCenter.streamSeq+" server seq "+t.body.stream_seq),this.stateCenter.streamSeq=t.body.stream_seq;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;t.body.stream_info.length;i++){var n=<span class="cstat-no" title="statement not covered" >t.body.stream_info[i].stream_id;<span class="cstat-no" title="statement not covered" ></span>if(!this.stateCenter.publishStreamList[n])<span class="cstat-no" title="statement not covered" >return void this.logger.info("hsur.0 stream is not exist");<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.publishStreamList[n].state==l.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;(this.stateCenter.publishStreamList[n].state=l.ENUM_PUBLISH_STREAM_STATE.publishing,this.onPublishStateUpdate(0,n,0))}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.hsur stream update error "+t.body.err_code);e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.hsur not login")}</span></span>,t.prototype.handleFetchStreamListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hfslr call"),this.stateCenter.streamQuerying=!1,0===t.body.err_code?this.stateCenter.streamSeq!==t.body.stream_seq?(this.handleFullUpdateStream(t.body.stream_seq,t.body.stream_info),this.logger.debug("zb.sh.hfslr call success")):this.logger.info("zb.sh.hfslr same seq"):this.logger.info("zb.sh.hfslr server error=",t.body.err_code)}</span>,t.prototype.handleFullUpdateStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.sh.hfus call"),this.stateCenter.streamSeq=t,this.logger.debug("zb.sh.hfus server seq "+this.stateCenter.streamSeq),p.ClientUtil.mergeStreamList(this.logger,this.stateCenter.idName,this.stateCenter.streamList,i,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,p){<span class="cstat-no" title="statement not covered" >0!==t.length&amp;&amp;(n.logger.debug("zb.sh.hfus callback addstream"),n.onStreamUpdated(l.ENUM_STREAM_UPDATE_TYPE.added,n.makeCallbackStreamList(t))),0!==i.length&amp;&amp;(n.logger.debug("zb.sh.hfus callback delstream"),n.onStreamUpdated(l.ENUM_STREAM_UPDATE_TYPE.deleted,n.makeCallbackStreamList(i))),0!==p.length&amp;&amp;(n.logger.debug("zb.sh.hfus callback updatestream"),n.onStreamExtraInfoUpdated(n.makeCallbackStreamList(p)))}</span>),this.logger.info("zb.sh.hfus call success")}</span>,t.prototype.handlePushStreamUpdateMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.sh.hpsum call"),t.body.stream_info&amp;&amp;0!==t.body.stream_info.length){<span class="cstat-no" title="statement not covered" >if(t.body.stream_info.length+this.stateCenter.streamSeq!==t.body.stream_seq)<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.sh.hpsum call updatestream"),void this.fetchStreamList();<span class="cstat-no" title="statement not covered" >s</span></span>witch(this.stateCenter.streamSeq=t.body.stream_seq,t.body.stream_cmd){case l.ENUM_STREAM_UPDATE_CMD.added:<span class="cstat-no" title="statement not covered" >this.handleAddedStreamList(t.body.stream_info);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase l.ENUM_STREAM_UPDATE_CMD.deleted:<span class="cstat-no" title="statement not covered" >this.handleDeletedStreamList(t.body.stream_info);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase l.ENUM_STREAM_UPDATE_CMD.updated:<span class="cstat-no" title="statement not covered" >this.handleUpdatedStreamList(t.body.stream_info)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.info("zb.sh.hpsum call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.hpsum, emtpy list")}</span></span>,t.prototype.handleAddedStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hasl call");<span class="cstat-no" title="statement not covered" >f</span>or(var i,n=[],p=0;p&lt;t.length;p++)<span class="cstat-no" title="statement not covered" >if(t[p].anchor_id_name!=this.stateCenter.idName){<span class="cstat-no" title="statement not covered" >i=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var e=0;e&lt;this.stateCenter.streamList.length;e++)<span class="cstat-no" title="statement not covered" >if(t[p].stream_id===this.stateCenter.streamList[e].stream_id){<span class="cstat-no" title="statement not covered" >i=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span>||n.push(t[p])}</span>else <span class="cstat-no" title="statement not covered" >this.logger.debug("hdsl.0 have self stream added");<span class="cstat-no" title="statement not covered" >i</span></span></span>f(0!==n.length){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hasl callback addstream");<span class="cstat-no" title="statement not covered" >f</span>or(var v=0;v&lt;n.length;v++)<span class="cstat-no" title="statement not covered" >this.stateCenter.streamList.push(n[v]);<span class="cstat-no" title="statement not covered" >t</span></span>his.onStreamUpdated(l.ENUM_STREAM_UPDATE_TYPE.added,this.makeCallbackStreamList(n))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.info("zb.sh.hasl call success")}</span>,t.prototype.handleDeletedStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hdsl call");<span class="cstat-no" title="statement not covered" >f</span>or(var i=[],n=0;n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >if(t[n].anchor_id_name!=this.stateCenter.idName){<span class="cstat-no" title="statement not covered" >for(var p=this.stateCenter.streamList.length-1;p&gt;=0;p--)<span class="cstat-no" title="statement not covered" >if(t[n].stream_id===this.stateCenter.streamList[p].stream_id){<span class="cstat-no" title="statement not covered" >this.stateCenter.streamList.splice(p,1),i.push(t[n]);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.hdsl have self stream deleted");<span class="cstat-no" title="statement not covered" >0</span></span></span>!==i.length&amp;&amp;(this.logger.debug("zb.sh.hdsl callback delstream"),this.onStreamUpdated(l.ENUM_STREAM_UPDATE_TYPE.deleted,this.makeCallbackStreamList(i))),this.logger.info("zb.sh.hdsl call")}</span>,t.prototype.handleUpdatedStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.sh.husl call");<span class="cstat-no" title="statement not covered" >f</span>or(var i=[],n=0;n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >if(t[n].anchor_id_name!=this.stateCenter.idName){<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;this.stateCenter.streamList.length;l++)<span class="cstat-no" title="statement not covered" >if(t[n].stream_id===this.stateCenter.streamList[l].stream_id){<span class="cstat-no" title="statement not covered" >t[n].extra_info!==this.stateCenter.streamList[l].extra_info&amp;&amp;(this.stateCenter.streamList[l]=t[n],i.push(t[n]));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.debug("hsul.0 have self stream updated");<span class="cstat-no" title="statement not covered" >0</span></span></span>!==i.length&amp;&amp;(this.logger.debug("zb.sh.husl callback updatestream"),this.onStreamExtraInfoUpdated(this.makeCallbackStreamList(i))),this.logger.info("zb.sh.husl call success")}</span>,t.prototype.fetchStreamList=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.sh.fsl call"),this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >if(this.stateCenter.streamQuerying)<span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.fsl already doing");e</span>lse{<span class="cstat-no" title="statement not covered" >this.stateCenter.streamQuerying=!0,this.logger.debug("zb.sh.fsl send fetch request");<span class="cstat-no" title="statement not covered" >t</span>his.socketCenter.registerRouter("stream_info",this.handleFetchStreamListRsp),this.socketCenter.sendMessage("stream_info",{reserve:0}),this.logger.debug("zb.sh.fsl call success")}</span>e</span>lse <span class="cstat-no" title="statement not covered" >this.logger.info("zb.sh.fsl state error")}</span></span>,t.prototype.makeCallbackStreamList=function(t){var i=[];<span class="missing-if-branch" title="if path not taken" >I</span>if(t&amp;&amp;t.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;t.length;n++){var l=<span class="cstat-no" title="statement not covered" >{anchor_id_name:t[n].anchor_id_name,stream_gid:t[n].stream_gid,anchor_nick_name:t[n].anchor_nick_name,extra_info:t[n].extra_info,stream_id:t[n].stream_id,urls_flv:"",urls_rtmp:"",urls_hls:"",urls_https_flv:"",urls_https_hls:""};<span class="cstat-no" title="statement not covered" ></span>this.setCDNInfo(l,t[n]),i.push(l)}</span>r</span>eturn i},t.prototype.updateMixStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.info("zb.sh.ums call"),null==t.outputStreamId&amp;&amp;null==t.outputUrl)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no mix stream info"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(0==t.streamList.length)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no input stream"),!1;v</span></span>ar v=<span class="cstat-no" title="statement not covered" >{id_name:this.stateCenter.idName,live_channel:this.stateCenter.roomid,appid:this.stateCenter.appid,version:l.PROTO_VERSION};<span class="cstat-no" title="statement not covered" ></span>"string"==typeof t.userData&amp;&amp;t.userData.length&lt;=1e4&amp;&amp;(v.UserData=t.userData);<span class="cstat-no" title="statement not covered" >f</span>or(var T=[],E=0;E&lt;t.streamList.length;E++){var S=<span class="cstat-no" title="statement not covered" >t.streamList[E],</span>R=<span class="cstat-no" title="statement not covered" >S.streamId;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.testEnvironment&amp;&amp;(R="zegotest-"+this.stateCenter.appid+"-"+S.streamId),T.push({stream_id:R,rect:{layer:E,top:S.top,left:S.left,bottom:S.bottom,right:S.right}})}<span class="cstat-no" title="statement not covered" ></span>v</span>.MixInput=T;v</span>ar r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=t.outputStreamId?this.stateCenter.testEnvironment?r.stream_id="zegotest-"+this.stateCenter.appid+"-"+t.outputStreamId:r.stream_id=t.outputStreamId:null!=t.outputUrl&amp;&amp;(r.mixurl=t.outputUrl),!t.outputBitrate)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no bitrate param"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.bitrate=t.outputBitrate,!t.outputFps)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no fps param"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.fps=t.outputFps,!t.outputWidth)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no width param"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.width=t.outputWidth,!t.outputHeight)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums no height param"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.height=t.outputHeight,t.outputAudioConfig&amp;&amp;(r.audio_enc_id=t.outputAudioConfig),t.outputAudioBitrate&amp;&amp;(r.audio_bitrate=t.outputAudioBitrate),t.outputAudioChannels&amp;&amp;(r.audio_channel_cnt=t.outputAudioChannels),t.outputBgColor){<span class="cstat-no" title="statement not covered" >if("number"!=typeof t.outputBgColor)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums param outputBgColor error"),!1;<span class="cstat-no" title="statement not covered" >v</span></span>.output_bg_color=t.outputBgColor}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.outputBgImage){<span class="cstat-no" title="statement not covered" >if("string"!=typeof t.outputBgImage||!t.outputBgImage.startsWith("preset-id://"))<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.ums param outputBgImage error"),!1;<span class="cstat-no" title="statement not covered" >v</span></span>.output_bg_image=t.outputBgImage}<span class="cstat-no" title="statement not covered" ></span>t</span>his.stateCenter.testEnvironment?r.testenv=1:r.testenv=0,v.MixOutput=[r],t.extraParams&amp;&amp;(v.extra_params=t.extraParams);v</span>ar h=<span class="cstat-no" title="statement not covered" >{channel:"zeus",cmd:"start_mix",req_body:JSON.stringify(v)};<span class="cstat-no" title="statement not covered" ></span>return this.logger.debug("zb.sh.ums send command"),this.socketCenter.sendMessage("biz_channel",h,<span class="fstat-no" title="function not covered" >fu</span>nction(v,T,E){<span class="cstat-no" title="statement not covered" >e.logger.debug("zb.sh.ums receive message");v</span>ar S=<span class="cstat-no" title="statement not covered" >"zegotest-"+e.stateCenter.appid+"-";<span class="cstat-no" title="statement not covered" ></span>if(0!=E.length){<span class="cstat-no" title="statement not covered" >for(var R=JSON.parse(E),r=[],h=t.outputStreamId,u=0;u&lt;R.play.length;u++){var L=<span class="cstat-no" title="statement not covered" >{rtmpUrls:null,hlsUrls:null,flvUrls:null};<span class="cstat-no" title="statement not covered" ></span>e.stateCenter.testEnvironment&amp;&amp;h&amp;&amp;h.startsWith(S)&amp;&amp;(h=h.slice(S.length)),R.play[u].rtmp_url&amp;&amp;R.play[u].rtmp_url.length&gt;0&amp;&amp;(L.rtmpUrls=[R.play[u].rtmp_url]),R.play[u].hls_url&amp;&amp;R.play[u].hls_url.length&gt;0&amp;&amp;(L.hlsUrls=[R.play[u].hls_url]),R.play[u].hdl_url&amp;&amp;R.play[u].hdl_url.length&gt;0&amp;&amp;(L.flvUrls=[R.play[u].hdl_url]),r.push(L)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;i(h,r)}</span>else <span class="cstat-no" title="statement not covered" >n&amp;&amp;n(p.ClientUtil.getServerError(l.MIXSTREAM_ERROR_CODE+1))}</span></span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,v){<span class="cstat-no" title="statement not covered" >if("number"==typeof t){<span class="cstat-no" title="statement not covered" >e.logger.debug("zb.sh.ums error: "+t);v</span>ar T=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(1000000150==t&amp;&amp;0!=v.length)<span class="cstat-no" title="statement not covered" >for(var E=JSON.parse(v),S="zegotest-"+e.stateCenter.appid+"-",R=0;R&lt;E.non_exist_streams.length;R++){var r=<span class="cstat-no" title="statement not covered" >E.non_exist_streams[R];<span class="cstat-no" title="statement not covered" ></span>e.stateCenter.testEnvironment&amp;&amp;r.startsWith(S)?T.push(r.slice(S.length)):T.push(r)}<span class="cstat-no" title="statement not covered" ></span>n</span></span>&amp;&amp;n(p.ClientUtil.getServerError(l.MIXSTREAM_ERROR_CODE+t),T)}</span>else <span class="cstat-no" title="statement not covered" >e.logger.debug("zb.sh.ums error code "+t.code),n&amp;&amp;n(t)}</span></span>),!0}</span>,t.prototype.publishTarget=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var v=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(t.type&amp;&amp;-1!=["addpush","delpush","clearpush"].indexOf(t.type))<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.sh.ptcall"),t.streamId&amp;&amp;"string"==typeof t.streamId)<span class="cstat-no" title="statement not covered" >if(t.pushUrl&amp;&amp;"string"==typeof t.pushUrl)<span class="cstat-no" title="statement not covered" >if(t.appSecret&amp;&amp;"string"==typeof t.appSecret)<span class="cstat-no" title="statement not covered" >if(this.stateCenter.publishStreamList[t.streamId]){var T=<span class="cstat-no" title="statement not covered" >Math.ceil((new Date).getTime()/1e3),</span>E=<span class="cstat-no" title="statement not covered" >t.streamId;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.testEnvironment&amp;&amp;(E="zegotest-"+this.stateCenter.appid+"-"+t.streamId);v</span>ar S=<span class="cstat-no" title="statement not covered" >{appid:this.stateCenter.appid,biz_type:0,timestamp:T,signature:e(this.stateCenter.appid.toString()+T.toString()+t.appSecret),seq:this.stateCenter.cdnSeq++,version:1*l.PROTO_VERSION,stream_id:E,pushurl:t.pushUrl},</span>R=<span class="cstat-no" title="statement not covered" >{channel:"media",cmd:t.type,req_body:JSON.stringify(S)};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.sh.pt send command"),this.socketCenter.sendMessage("biz_channel",R,<span class="fstat-no" title="function not covered" >fu</span>nction(e,T,E){<span class="cstat-no" title="statement not covered" >if(v.logger.debug("zb.sh.pt receive message"),0!=E.length){var S=<span class="cstat-no" title="statement not covered" >JSON.parse(E),</span>R=<span class="cstat-no" title="statement not covered" >S.code,</span>r=<span class="cstat-no" title="statement not covered" >S.message;<span class="cstat-no" title="statement not covered" ></span>if(R&amp;&amp;0!=R)<span class="cstat-no" title="statement not covered" >return v.logger.error("zb.sh.pt "+t.type+" error code: "+R+" "+r),void(n&amp;&amp;n({code:R,message:r}));<span class="cstat-no" title="statement not covered" >v</span></span>.logger.info("zb.sh.pt "+t.type+" success"),i&amp;&amp;i()}</span>else <span class="cstat-no" title="statement not covered" >n&amp;&amp;n(p.ClientUtil.getServerError(l.MIXSTREAM_ERROR_CODE+1))}</span></span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,l){<span class="cstat-no" title="statement not covered" >v.logger.debug("zb.sh.pt error: "+n);v</span>ar p=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>2001==t?p="invalid channel":2002==t&amp;&amp;(p="bizchannel error"),n&amp;&amp;n({code:t,message:p})}</span>)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.pt publish stream no found");e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.pt appSecret error");e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.pt pushurl error");e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.pt streamid error");e</span></span>lse <span class="cstat-no" title="statement not covered" >this.logger.error("zb.sh.pt cdn push type error")}</span></span>,t.prototype.stopMixStream=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >if(this.logger.info("zb.sh.sms call"),null==t.outputStreamId&amp;&amp;null==t.outputUrl)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.sh.sms no mix stream info"),!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >{id_name:this.stateCenter.idName,live_channel:this.stateCenter.roomid,appid:this.stateCenter.appid,version:l.PROTO_VERSION};<span class="cstat-no" title="statement not covered" ></span>null!=t.outputStreamId?this.stateCenter.testEnvironment?e.stream_id="zegotest-"+this.stateCenter.appid+"-"+t.outputStreamId:e.stream_id=t.outputStreamId:null!=t.outputUrl&amp;&amp;(e.mixurl=t.outputUrl);v</span>ar v=<span class="cstat-no" title="statement not covered" >{channel:"zeus",cmd:"stop_mix",req_body:JSON.stringify(e)};<span class="cstat-no" title="statement not covered" ></span>return this.socketCenter.sendMessage("biz_channel",v,<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i()}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >"number"==typeof t?n&amp;&amp;n(p.ClientUtil.getServerError(l.MIXSTREAM_ERROR_CODE+t)):n&amp;&amp;n(t)}</span>),!0}</span>,t.prototype.updateStreamExtraInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.sh.usei call"),t?"string"==typeof i&amp;&amp;(this.stateCenter.publishStreamList[t]&amp;&amp;(this.stateCenter.publishStreamList[t].extra_info=i,this.stateCenter.publishStreamList[t].state&gt;=l.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;this.updateStreamInfo(t,l.ENUM_STREAM_SUB_CMD.liveUpdate,i)),!0):(this.logger.error("zb.sh.usei param error"),!1)}</span>,t}();i.StreamHandler=v},function(t,i,n){var l;!function(p){"use strict";function <span class="fstat-no" title="function not covered" >e(</span>t,i){var n=<span class="cstat-no" title="statement not covered" >(65535&amp;t)+(65535&amp;i);<span class="cstat-no" title="statement not covered" ></span>return(t&gt;&gt;16)+(i&gt;&gt;16)+(n&gt;&gt;16)&lt;&lt;16|65535&amp;n}</span>function <span class="fstat-no" title="function not covered" >v(</span>t,i,n,l,p,v){<span class="cstat-no" title="statement not covered" >return e(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return t&lt;&lt;p|t&gt;&gt;&gt;32-p}</span>(e(e(i,t),e(l,v))),n)}</span>function <span class="fstat-no" title="function not covered" >T(</span>t,i,n,l,p,e,T){<span class="cstat-no" title="statement not covered" >return v(i&amp;n|~i&amp;l,t,i,p,e,T)}</span>function <span class="fstat-no" title="function not covered" >E(</span>t,i,n,l,p,e,T){<span class="cstat-no" title="statement not covered" >return v(i&amp;l|n&amp;~l,t,i,p,e,T)}</span>function <span class="fstat-no" title="function not covered" >S(</span>t,i,n,l,p,e,T){<span class="cstat-no" title="statement not covered" >return v(i^n^l,t,i,p,e,T)}</span>function <span class="fstat-no" title="function not covered" >R(</span>t,i,n,l,p,e,T){<span class="cstat-no" title="statement not covered" >return v(n^(i|~l),t,i,p,e,T)}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,i){var n,l,p,v,r;<span class="cstat-no" title="statement not covered" >t[i&gt;&gt;5]|=128&lt;&lt;i%32,t[14+(i+64&gt;&gt;&gt;9&lt;&lt;4)]=i;v</span>ar h=<span class="cstat-no" title="statement not covered" >1732584193,</span>u=<span class="cstat-no" title="statement not covered" >-271733879,</span>L=<span class="cstat-no" title="statement not covered" >-1732584194,</span>M=<span class="cstat-no" title="statement not covered" >271733878;<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;t.length;n+=16)<span class="cstat-no" title="statement not covered" >u=R(u=R(u=R(u=R(u=S(u=S(u=S(u=S(u=E(u=E(u=E(u=E(u=T(u=T(u=T(u=T(p=u,L=T(v=L,M=T(r=M,h=T(l=h,u,L,M,t[n],7,-680876936),u,L,t[n+1],12,-389564586),h,u,t[n+2],17,606105819),M,h,t[n+3],22,-1044525330),L=T(L,M=T(M,h=T(h,u,L,M,t[n+4],7,-176418897),u,L,t[n+5],12,1200080426),h,u,t[n+6],17,-1473231341),M,h,t[n+7],22,-45705983),L=T(L,M=T(M,h=T(h,u,L,M,t[n+8],7,1770035416),u,L,t[n+9],12,-1958414417),h,u,t[n+10],17,-42063),M,h,t[n+11],22,-1990404162),L=T(L,M=T(M,h=T(h,u,L,M,t[n+12],7,1804603682),u,L,t[n+13],12,-40341101),h,u,t[n+14],17,-1502002290),M,h,t[n+15],22,1236535329),L=E(L,M=E(M,h=E(h,u,L,M,t[n+1],5,-165796510),u,L,t[n+6],9,-1069501632),h,u,t[n+11],14,643717713),M,h,t[n],20,-373897302),L=E(L,M=E(M,h=E(h,u,L,M,t[n+5],5,-701558691),u,L,t[n+10],9,38016083),h,u,t[n+15],14,-660478335),M,h,t[n+4],20,-405537848),L=E(L,M=E(M,h=E(h,u,L,M,t[n+9],5,568446438),u,L,t[n+14],9,-1019803690),h,u,t[n+3],14,-187363961),M,h,t[n+8],20,1163531501),L=E(L,M=E(M,h=E(h,u,L,M,t[n+13],5,-1444681467),u,L,t[n+2],9,-51403784),h,u,t[n+7],14,1735328473),M,h,t[n+12],20,-1926607734),L=S(L,M=S(M,h=S(h,u,L,M,t[n+5],4,-378558),u,L,t[n+8],11,-2022574463),h,u,t[n+11],16,1839030562),M,h,t[n+14],23,-35309556),L=S(L,M=S(M,h=S(h,u,L,M,t[n+1],4,-1530992060),u,L,t[n+4],11,1272893353),h,u,t[n+7],16,-155497632),M,h,t[n+10],23,-1094730640),L=S(L,M=S(M,h=S(h,u,L,M,t[n+13],4,681279174),u,L,t[n],11,-358537222),h,u,t[n+3],16,-722521979),M,h,t[n+6],23,76029189),L=S(L,M=S(M,h=S(h,u,L,M,t[n+9],4,-640364487),u,L,t[n+12],11,-421815835),h,u,t[n+15],16,530742520),M,h,t[n+2],23,-995338651),L=R(L,M=R(M,h=R(h,u,L,M,t[n],6,-198630844),u,L,t[n+7],10,1126891415),h,u,t[n+14],15,-1416354905),M,h,t[n+5],21,-57434055),L=R(L,M=R(M,h=R(h,u,L,M,t[n+12],6,1700485571),u,L,t[n+3],10,-1894986606),h,u,t[n+10],15,-1051523),M,h,t[n+1],21,-2054922799),L=R(L,M=R(M,h=R(h,u,L,M,t[n+8],6,1873313359),u,L,t[n+15],10,-30611744),h,u,t[n+6],15,-1560198380),M,h,t[n+13],21,1309151649),L=R(L,M=R(M,h=R(h,u,L,M,t[n+4],6,-145523070),u,L,t[n+11],10,-1120210379),h,u,t[n+2],15,718787259),M,h,t[n+9],21,-343485551),h=e(h,l),u=e(u,p),L=e(L,v),M=e(M,r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[h,u,L,M]}</span>function <span class="fstat-no" title="function not covered" >h(</span>t){var i,n=<span class="cstat-no" title="statement not covered" >"",</span>l=<span class="cstat-no" title="statement not covered" >32*t.length;<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;l;i+=8)<span class="cstat-no" title="statement not covered" >n+=String.fromCharCode(t[i&gt;&gt;5]&gt;&gt;&gt;i%32&amp;255);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >u(</span>t){var i,n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(n[(t.length&gt;&gt;2)-1]=void 0,i=0;i&lt;n.length;i+=1)<span class="cstat-no" title="statement not covered" >n[i]=0;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >8*t.length;<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;l;i+=8)<span class="cstat-no" title="statement not covered" >n[i&gt;&gt;5]|=(255&amp;t.charCodeAt(i/8))&lt;&lt;i%32;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >L(</span>t){var i,n,l=<span class="cstat-no" title="statement not covered" >"0123456789abcdef",</span>p=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;t.length;n+=1)<span class="cstat-no" title="statement not covered" >i=t.charCodeAt(n),p+=l.charAt(i&gt;&gt;&gt;4&amp;15)+l.charAt(15&amp;i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn p}</span>function <span class="fstat-no" title="function not covered" >M(</span>t){<span class="cstat-no" title="statement not covered" >return unescape(encodeURIComponent(t))}</span>function <span class="fstat-no" title="function not covered" >f(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return h(r(u(t),8*t.length))}</span>(M(t))}</span>function <span class="fstat-no" title="function not covered" >U(</span>t,i){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n,l,p=<span class="cstat-no" title="statement not covered" >u(t),</span>e=<span class="cstat-no" title="statement not covered" >[],</span>v=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(e[15]=v[15]=void 0,16&lt;p.length&amp;&amp;(p=r(p,8*t.length)),n=0;n&lt;16;n+=1)<span class="cstat-no" title="statement not covered" >e[n]=909522486^p[n],v[n]=1549556828^p[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn l=r(e.concat(u(i)),512+8*i.length),h(r(v.concat(l),640))}</span>(M(t),M(i))}</span>function <span class="fstat-no" title="function not covered" >b(</span>t,i,n){<span class="cstat-no" title="statement not covered" >return i?n?U(i,t):<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >return L(U(t,i))}</span>(i,t):n?f(t):<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return L(f(t))}</span>(t)}</span>void 0===(l=function(){return b}.call(i,n,i,t))||(t.exports=l)}()},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(2),e=function(){function t(t,i,n){this.logger=t,this.socketCenter=n,this.stateCenter=i}return t.prototype.resetHeartbeat=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.hb.rht call"),this.stateCenter.heartbeatTimer&amp;&amp;clearTimeout(this.stateCenter.heartbeatTimer),this.stateCenter.heartbeatTimer=null,this.stateCenter.tryHeartbeatCount=0,this.logger.debug("zb.hb.rht call success")}</span>,t.prototype.hbLogout=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.start=function(t){var i=this;<span class="missing-if-branch" title="else path not taken" >E</span>if(this.logger.debug("zb.hb.sht call"),this.stateCenter.isLogin()){<span class="missing-if-branch" title="if path not taken" >I</span>if(++this.stateCenter.tryHeartbeatCount&gt;3)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.hb.sht come to try limit"),void this.hbLogout(l.sdkErrorList.HEARTBEAT_TIMEOUT);t</span>his.logger.debug("zb.hb.sht send packet");this.socketCenter.registerRouter("hb",function(t){i.handleHeartbeatRsp(t)}),this.socketCenter.sendMessage("hb",{reserve:0}),this.logger.debug("zb.hb.sht call success"),this.stateCenter.heartbeatInterval=t,this.stateCenter.heartbeatTimer=setTimeout(function(){i.start(i.stateCenter.heartbeatInterval)},this.stateCenter.heartbeatInterval)}else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.hb.sht state error")}</span>,t.prototype.handleHeartbeatRsp=function(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.logger.debug("zb.hb.hhbr call"),0!==t.body.err_code)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.hb.hhbr call disconnect, server error=",t.body.err_code),void this.hbLogout(p.ClientUtil.getServerError(t.body.err_code));f</span>or(var i in this.stateCenter.tryHeartbeatCount=0,this.stateCenter.heartbeatInterval=t.body.hearbeat_interval,this.stateCenter.heartbeatInterval&lt;l.MINIUM_HEARTBEAT_INTERVAL&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.stateCenter.heartbeatInterval=l.MINIUM_HEARTBEAT_INTERVAL)</span>,t.body.bigim_time_window&amp;&amp;"number"==typeof t.body.bigim_time_window&amp;&amp;(this.stateCenter.bigimTimeWindow=t.body.bigim_time_window),t.body.dati_time_window&amp;&amp;"number"==typeof t.body.dati_time_window&amp;&amp;(this.stateCenter.datiTimeWindow=t.body.dati_time_window),this.ReliableMessageHandler(t),this.fetchStreamList(t),this.patchUserList(t),this.stateCenter.publishStreamList)<span class="cstat-no" title="statement not covered" >this.stateCenter.publishStreamList[i].state==l.ENUM_PUBLISH_STREAM_STATE.update_info&amp;&amp;(this.logger.info("zb.hb.hhbr try to update stream info"),this.updateStreamInfo(i,l.ENUM_STREAM_SUB_CMD.liveBegin,this.stateCenter.publishStreamList[i].extra_info));n</span>ull!=t.body.online_count&amp;&amp;0!=t.body.online_count&amp;&amp;this.onUpdateOnlineCount(this.stateCenter.roomid,t.body.online_count),this.logger.debug("zb.hb.hhbr call success")},t.prototype.ReliableMessageHandler=function(t){var i=this;<span class="missing-if-branch" title="else path not taken" >E</span>if(t.body.trans_seqs)for(var n=0;n&lt;t.body.trans_seqs.length;n++){var l=<span class="cstat-no" title="statement not covered" >t.body.trans_seqs[n].trans_channel,</span>p=<span class="cstat-no" title="statement not covered" >t.body.trans_seqs[n].trans_seq_array;<span class="cstat-no" title="statement not covered" ></span>(p=p.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.trans_type,</span>l=<span class="cstat-no" title="statement not covered" >t.trans_seq;<span class="cstat-no" title="statement not covered" ></span>return!i.stateCenter.transSeqMap[n]||i.stateCenter.transSeqMap[n].seq!==l}</span>)).length&gt;0&amp;&amp;this.fetchReliableMessage(l,p)}</span>},t.prototype.fetchReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.hb.frm call");v</span>ar l=<span class="cstat-no" title="statement not covered" >{trans_channel:t,fetch_array:i};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.registerRouter("trans_fetch",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.handleFetchTransRsp(t)}</span>),this.socketCenter.sendMessage("trans_fetch",l),this.logger.debug("zb.hb.frm call success")}</span>,t.prototype.handleFetchTransRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.isLogin()?0==t.body.err_code?t.body.trans_fetch_results.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.trans_type,</span>l=<span class="cstat-no" title="statement not covered" >t.trans_seq;<span class="cstat-no" title="statement not covered" ></span>i.stateCenter.transSeqMap[n]={seq:l},t.trans_user_idname!=i.stateCenter.idName&amp;&amp;t.trans_idname!=i.stateCenter.idName&amp;&amp;i.onRecvReliableMessage(n,l,t.trans_data),i.logger.debug("zb.hb.hftr trans "+n+" seq "+l)}</span>):this.logger.error("zb.hb.hftr trans send error "+t.body.err_code):this.logger.error("zb.hb.hftr not login")}</span>,t.prototype.fetchStreamList=function(t){var i=this;t.body.stream_seq!==this.stateCenter.streamSeq&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.debug("zb.hb.fsl current seq "+this.stateCenter.streamSeq+" server Seq "+t.body.stream_seq),this.logger.debug("zb.hb.fsl call"),this.stateCenter.isLogin()?this.stateCenter.streamQuerying?this.logger.warn("zb.hb.fsl already doing"):(this.stateCenter.streamQuerying=!0,this.logger.debug("zb.hb.fsl send fetch request"),this.socketCenter.registerRouter("stream_info",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.handleFetchStreamListRsp(t)}</span>),this.socketCenter.sendMessage("stream_info",{reserve:0}),this.logger.debug("zb.hb.fsl call success")):this.logger.error("zb.hb.fsl state error"))</span>},t.prototype.patchUserList=function(t){var i=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(t.body.server_user_seq!==this.stateCenter.userSeq&amp;&amp;this.stateCenter.userStateUpdate&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >!this.stateCenter.userSeqMergeMap)</span>{var n=<span class="cstat-no" title="statement not covered" >this.stateCenter.lastUserQueryTime-Date.now();<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.hb.hhbr call update user "+this.stateCenter.userSeq+" server "+t.body.server_user_seq+" wait "+n),n&gt;0?(this.stateCenter.userQueryTimer&amp;&amp;clearTimeout(this.stateCenter.userQueryTimer),this.stateCenter.userQueryTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.fetchUserList()}</span>,n)):this.fetchUserList()}</span>},t.prototype.handleFetchStreamListRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.fetchUserList=<span class="fstat-no" title="function not covered" >fu</span>nction(){},t.prototype.updateStreamInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n="")}</span>,t.prototype.onUpdateOnlineCount=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t.prototype.resetCheckMessage=function(){this.logger.debug("zb.hb.rcm call"),clearTimeout(this.stateCenter.sendDataCheckTimer),this.stateCenter.sendDataCheckTimer=null,this.checkSendMessageList(this.stateCenter.sendDataList),this.checkSendMessageList(this.stateCenter.sendCommandList),this.stateCenter.sendDataMap={},this.stateCenter.sendCommandMap={},this.logger.debug("zb.hb.rcm call success")},t.prototype.checkSendMessageList=function(t){for(var i=t.getFirst();null!=i;)<span class="cstat-no" title="statement not covered" >t.remove(i),i._data.error&amp;&amp;(i._data.data.body.custom_msg?i._data.error(l.sdkErrorList.SEND_MSG_TIMEOUT,i._data.data.header.seq,i._data.data.body.custom_msg):i._data.error(l.sdkErrorList.SEND_MSG_TIMEOUT,i._data.data.header.seq)),i=t.getFirst()}</span>,t.prototype.checkMessageListTimeout=function(t,i){for(var n=t.getFirst(),p=Date.parse(new Date+""),e=0,v=0,T=0;!(null==n||<span class="branch-1 cbranch-no" title="branch not covered" >n._data.time+this.stateCenter.sendDataTimeout&gt;p|</span>|(<span class="branch-2 cbranch-no" title="branch not covered" >delete i[n._data.data.header.seq],t.remove(n),++v,null==n._data.error||this.stateCenter.sendDataDropTimeout&gt;0&amp;&amp;n._data.time+this.stateCenter.sendDataDropTimeout&lt;p?++T:n._data.data.body.custom_msg?n._data.error(l.sdkErrorList.SEND_MSG_TIMEOUT,n._data.data.header.seq,n._data.data.body.custom_msg):n._data.error(l.sdkErrorList.SEND_MSG_TIMEOUT,n._data.data.header.seq),++e&gt;=this.stateCenter.sendDataCheckOnceCount)</span>);)<span class="cstat-no" title="statement not covered" >n=t.getFirst();0</span>==v&amp;&amp;0==T||<span class="branch-2 cbranch-no" title="branch not covered" >this.logger.debug("zb.hb.cmt call success, stat: timeout=",v,"drop=",T)}</span>,t.prototype.startCheckMessageTimeout=function(){var t=this;this.stateCenter.isLogin()?(this.checkMessageListTimeout(this.stateCenter.sendDataList,this.stateCenter.sendDataMap),this.checkMessageListTimeout(this.stateCenter.sendCommandList,this.stateCenter.sendCommandMap),this.stateCenter.sendDataCheckTimer=setTimeout(function(){t.startCheckMessageTimeout()},this.stateCenter.sendDataCheckInterval)):<span class="branch-1 cbranch-no" title="branch not covered" >this.logger.error("zb.hb.scmt state error")}</span>,t}();i.HeartBeatHandler=e},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(2),e=function(){function t(t,i,n){this.logger=t,this.socketCenter=n,this.stateCenter=i}return t.prototype.sendCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zb.mh.scc call"),!this.stateCenter.isLogin())<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.mh.scc state error"),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >return this.logger.error("zb.mh.scc dstMembers error"),!1;v</span></span>ar v=<span class="cstat-no" title="statement not covered" >{from_userid:this.stateCenter.idName,from_username:this.stateCenter.nickName,request_id:this.stateCenter.getRequestId(),custom_content:i||"",room_id:this.stateCenter.roomid},</span>T=<span class="cstat-no" title="statement not covered" >{dest_id_name:t,custom_msg:JSON.stringify(v)};<span class="cstat-no" title="statement not covered" ></span>return p.ClientUtil.checkCustomCommandParam(T)?(this.socketCenter.registerRouter("custommsg",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.handleSendCustomMsgRsp(t)}</span>),this.socketCenter.sendCustomMessage("custommsg",T,n,l),this.logger.info("zb.mh.scc call success"),!0):(this.logger.info("zb.mh.scc param error"),!1)}</span>,t.prototype.handleSendCustomMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.hscmrcall");v</span>ar i,n=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendDataMap[t.header.seq];<span class="cstat-no" title="statement not covered" ></span>null!=n?("custommsg"!=(i=n._data).data.header.cmd?this.logger.error("zb.mh.hscmrcmd wrong"+i.data.header.cmd):0===t.body.err_code?null!=i.success&amp;&amp;i.success(t.header.seq,i.data.body.custom_msg):null!=i.error&amp;&amp;i.error(p.ClientUtil.getServerError(t.body.err_code),t.header.seq,i.data.body.custom_msg),delete this.stateCenter.sendDataMap[t.header.seq],this.stateCenter.sendDataList.remove(n)):this.logger.error("zb.mh.hscmrno found seq="+t.header.seq),this.logger.debug("zb.mh.hscmr  call success")}</span>,t.prototype.handlePushCustomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >JSON.parse(t.body.custommsg);<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.mh.hpcm submsg=",i),this.onRecvCustomCommand(i.from_userid,i.from_username,i.custom_content)}</span>,t.prototype.onRecvCustomCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t.prototype.sendRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p,e){var v=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("zb.mh.srm call"),this.stateCenter.isLogin()){var T=<span class="cstat-no" title="statement not covered" >Date.parse(new Date+"");<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.sendRoomMsgTime&gt;0&amp;&amp;this.stateCenter.sendRoomMsgTime+this.stateCenter.SendRoomMsgInterval&gt;T)<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.mh.srm freq error"),void(e&amp;&amp;e(l.sdkErrorList.FREQ_LIMITED,0,t,i,n));<span class="cstat-no" title="statement not covered" >t</span></span>his.stateCenter.sendRoomMsgTime=T,this.logger.debug("zb.mh.srm send fetch request");v</span>ar E=<span class="cstat-no" title="statement not covered" >{msg_category:t,msg_type:i,msg_content:n};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.registerRouter("im_chat",<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >v.handleSendRoomMsgRsp(t)}</span>),this.socketCenter.sendCustomMessage("im_chat",E,p,e),this.logger.info("zb.mh.srm call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.mh.srm state error")}</span></span>,t.prototype.handleSendRoomMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.hsrmr call");v</span>ar i,n=<span class="cstat-no" title="statement not covered" >this.stateCenter.sendDataMap[t.header.seq];<span class="cstat-no" title="statement not covered" ></span>null!=n?("im_chat"!=(i=n._data).data.header.cmd?this.logger.error("zb.mh.hsrmr cmd wrong"+i.data.header.cmd):0===t.body.err_code?i.success&amp;&amp;i.success(t.header.seq,t.body.msg_id,i.data.body.msg_category,i.data.body.msg_type,i.data.body.msg_content):i.error&amp;&amp;i.error(p.ClientUtil.getServerError(t.body.err_code),t.header.seq,i.data.body.msg_category,i.data.body.msg_type,i.data.body.msg_content),delete this.stateCenter.sendDataMap[t.header.seq],this.stateCenter.sendDataList.remove(n)):this.logger.error("hzb.mh.hsrmr no found seq="+t.header.seq),this.logger.info("zb.mh.hsrmr call success")}</span>,t.prototype.onRecvRoomMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t.prototype.sendReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.srirm call"),this.stateCenter.transSeqMap[t]||(this.stateCenter.transSeqMap[t]={seq:0});v</span>ar p=<span class="cstat-no" title="statement not covered" >{trans_type:t,trans_data:i,trans_local_seq:this.stateCenter.transSeqMap[t].seq,trans_channel:"clt"};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("trans",p,n,l)}</span>,t.prototype.sendBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.mh.sbim call");v</span>ar v=<span class="cstat-no" title="statement not covered" >this.stateCenter.bigimTimeWindow,</span>T=<span class="cstat-no" title="statement not covered" >this.stateCenter.serverTimeOffset,</span>E=<span class="cstat-no" title="statement not covered" >(new Date).getTime()+T,</span>S=<span class="cstat-no" title="statement not covered" >(++this.stateCenter.cmdSeq).toString();<span class="cstat-no" title="statement not covered" ></span>if(null==l&amp;&amp;(l=null),null==p&amp;&amp;(p=null),this.stateCenter.bigImCallbackMap[S]={success:l,error:p},0==v){var R=<span class="cstat-no" title="statement not covered" >{msg_category:t,msg_type:i,msg_content:n,bigmsg_client_id:S};<span class="cstat-no" title="statement not covered" ></span>this.logger.debug("zb.mh.sbim no time window"),this.sendBigRoomMessageInternal([R],<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.handleBigImMsgRsp(t)}</span>,p)}</span>else{var r=<span class="cstat-no" title="statement not covered" >Math.floor(E/v);<span class="cstat-no" title="statement not covered" ></span>if(this.logger.debug("currentIndex "+r+" lastTimeIndex "+this.stateCenter.bigImLastTimeIndex),this.stateCenter.bigImLastTimeIndex&lt;r&amp;&amp;0==this.stateCenter.bigImMessageList.length){<span class="cstat-no" title="statement not covered" >this.stateCenter.bigImLastTimeIndex=r;v</span>ar h=<span class="cstat-no" title="statement not covered" >{msg_category:t,msg_type:i,msg_content:n,bigmsg_client_id:S};<span class="cstat-no" title="statement not covered" ></span>this.sendBigRoomMessageInternal([h],<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.handleBigImMsgRsp(t)}</span>,p)}</span>else <span class="cstat-no" title="statement not covered" >this.stateCenter.bigImMessageList.push({msg_category:t,msg_type:i,msg_content:n,bigmsg_client_id:S}),1==this.stateCenter.bigImMessageList.length&amp;&amp;this.setBigImTimer(T,v)}</span></span>}</span>,t.prototype.handlePushMergeMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){<span class="cstat-no" title="statement not covered" >for(var i=0;i&lt;t.body.messages.length;i++)<span class="cstat-no" title="statement not covered" >14001===t.body.messages[i].sub_cmd&amp;&amp;this.handlePushBigRooMsg(t.body.messages[i].msg_body);<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.debug("zb.mh.hpmm call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.mh.hpmmnot login")}</span></span>,t.prototype.handlePushBigRooMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=JSON.parse(t)}</span>catch(t){<span class="cstat-no" title="statement not covered" >return void this.logger.warn("zb.mh.hpbrm parse json error")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i){<span class="cstat-no" title="statement not covered" >for(var n=i.room_id,l=[],p=0;p&lt;i.msg_data.length;p++){var e=<span class="cstat-no" title="statement not covered" >i.msg_data[p];<span class="cstat-no" title="statement not covered" ></span>e.id_name!=this.stateCenter.idName?l.push({idName:e.id_name,nickName:e.nick_name,messageId:e.bigmsg_id,category:e.msg_category,type:e.msg_type,content:e.msg_content,time:e.send_time}):this.logger.debug("zb.mh.hpbrm self message")}<span class="cstat-no" title="statement not covered" ></span>0</span>==l.length?this.logger.debug("zb.mh.hpbrm no other pushData except self"):this.onRecvBigRoomMessage(l,n),this.logger.debug("zb.mh.hpbrm call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zb.mh.hpbrm cann't find message body")}</span></span>,t.prototype.onRecvBigRoomMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){},t.prototype.sendBigRoomMessageInternal=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.sbim call");v</span>ar l=<span class="cstat-no" title="statement not covered" >{msgs:t};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("bigim_chat",l,i,n)}</span>,t.prototype.handleBigImMsgRsp=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){<span class="cstat-no" title="statement not covered" >this.stateCenter.bigimTimeWindow!=t.body.bigim_time_window&amp;&amp;(this.stateCenter.bigimTimeWindow=t.body.bigim_time_window);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;t.body.msgs.length;i++){var n=<span class="cstat-no" title="statement not covered" >t.body.msgs[i].bigmsg_client_id,</span>l=<span class="cstat-no" title="statement not covered" >t.body.msgs[i].bigmsg_id;<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.bigImCallbackMap[n]){var p=<span class="cstat-no" title="statement not covered" >this.stateCenter.bigImCallbackMap[n].success;<span class="cstat-no" title="statement not covered" ></span>null!=p&amp;&amp;p(t.header.seq,l),delete this.stateCenter.bigImCallbackMap[n]}</span>}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.mh.hbmr not login")}</span></span>,t.prototype.setBigImTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >i-((new Date).getTime()+t)%i,</span>e=<span class="cstat-no" title="statement not covered" >p.ClientUtil.generateRandumNumber(i)+l;<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.mh.sbt setTimer "+e),this.stateCenter.bigImTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.onBigImTimer()}</span>,e)}</span>,t.prototype.onBigImTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >(new Date).getTime()+this.stateCenter.serverTimeOffset;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.bigImLastTimeIndex=Math.floor(i/this.stateCenter.bigimTimeWindow);<span class="cstat-no" title="statement not covered" >f</span>or(var n=[],l=[],p=0;p&lt;this.stateCenter.bigImMessageList.length&amp;&amp;!(p&gt;=20);p++){var e=<span class="cstat-no" title="statement not covered" >this.stateCenter.bigImMessageList[p];<span class="cstat-no" title="statement not covered" ></span>n.push({msg_category:e.msg_category,msg_type:e.msg_type,msg_content:e.msg_content,bigmsg_client_id:e.bigmsg_client_id}),l.push(e.bigmsg_client_id)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.stateCenter.bigImMessageList.length&gt;20?this.stateCenter.bigImMessageList.splice(0,20):this.stateCenter.bigImMessageList=[],this.sendBigRoomMessageInternal(n,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.handleBigImMsgRsp(i)}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(i,n){<span class="cstat-no" title="statement not covered" >for(var p=0;p&lt;l.length;p++){var e=<span class="cstat-no" title="statement not covered" >l[p],</span>v=<span class="cstat-no" title="statement not covered" >t.stateCenter.bigImCallbackMap[e];<span class="cstat-no" title="statement not covered" ></span>v&amp;&amp;(null!=v.error&amp;&amp;v.error(i,n),delete t.stateCenter.bigImCallbackMap[e])}</span>}</span>),clearTimeout(this.stateCenter.bigImTimer),this.stateCenter.bigImTimer=null,this.stateCenter.bigImMessageList.length&gt;0&amp;&amp;this.setBigImTimer(this.stateCenter.serverTimeOffset,this.stateCenter.bigimTimeWindow)}</span>,t.prototype.sendRelayMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.srm call");v</span>ar p=<span class="cstat-no" title="statement not covered" >this.stateCenter.datiTimeWindow,</span>e=<span class="cstat-no" title="statement not covered" >this.stateCenter.serverTimeOffset;<span class="cstat-no" title="statement not covered" ></span>p&gt;0?(this.stateCenter.realyMessageList.push({type:t,data:i,success:n,error:l}),1==this.stateCenter.realyMessageList.length&amp;&amp;this.setRelayTimer(e,p)):this.sendRelayMessageInternal(t,i,n,l)}</span>,t.prototype.sendRelayMessageInternal=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.mh.srmi call");v</span>ar p=<span class="cstat-no" title="statement not covered" >{relay_type:t,relay_data:i};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("relay",p,n,l)}</span>,t.prototype.setRelayTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){var n=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >2*i-((new Date).getTime()+t)%i,</span>e=<span class="cstat-no" title="statement not covered" >p.ClientUtil.generateRandumNumber(l);<span class="cstat-no" title="statement not covered" ></span>this.logger.info("zb.mh.srt setTimer "+e),this.stateCenter.relayTimer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.onRelayTimer()}</span>,e)}</span>,t.prototype.onRelayTimer=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(0!=this.stateCenter.realyMessageList.length){var t=<span class="cstat-no" title="statement not covered" >this.stateCenter.realyMessageList[0];<span class="cstat-no" title="statement not covered" ></span>this.sendRelayMessageInternal(t.type,t.data,t.success,t.error),clearTimeout(this.stateCenter.relayTimer),this.stateCenter.relayTimer=null,this.stateCenter.realyMessageList.splice(0,1),this.stateCenter.realyMessageList.length&gt;0&amp;&amp;this.setRelayTimer(this.stateCenter.serverTimeOffset,this.stateCenter.datiTimeWindow)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.mh.ort no relay data")}</span></span>,t.prototype.handlePushTransMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){var i=<span class="cstat-no" title="statement not covered" >t.body.trans_type,</span>n=<span class="cstat-no" title="statement not covered" >t.body.trans_seq;<span class="cstat-no" title="statement not covered" ></span>this.stateCenter.transSeqMap[i]?this.stateCenter.transSeqMap[i].seq=n:this.stateCenter.transSeqMap[i]={seq:n},t.body.trans_user_idname!=this.stateCenter.idName&amp;&amp;t.body.trans_idname!=this.stateCenter.idName?this.onRecvReliableMessage(i,n,t.body.trans_data):this.logger.debug("zb.mh.hptr receive self trans message"),this.logger.info("zb.mh.hptr trans "+i+" seq "+n)}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.mh.hptr not login")}</span></span>,t.prototype.onRecvReliableMessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){},t}();i.MessageHandler=e},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=function(){function t(t,i,n){this.logger=t,this.socketCenter=n,this.stateCenter=i}return t.prototype.requestJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.rjl call");v</span>ar e=<span class="cstat-no" title="statement not covered" >this.stateCenter.getRequestId(),</span>v=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(e,t);<span class="cstat-no" title="statement not covered" ></span>return null!=p&amp;&amp;(this.stateCenter.joinLiveCallbackMap[e]=p,this.sendSignalCmd(l.ENUM_SIGNAL_SUB_CMD.joinLiveRequest,v,t,i,n),!0)}</span>,t.prototype.inviteJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.ijl call");v</span>ar e=<span class="cstat-no" title="statement not covered" >this.stateCenter.getRequestId(),</span>v=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(e,t);<span class="cstat-no" title="statement not covered" ></span>return null!=p&amp;&amp;(this.stateCenter.joinLiveCallbackMap[e]=p,this.sendSignalCmd(l.ENUM_SIGNAL_SUB_CMD.joinLiveInvite,v,t,i,n),!0)}</span>,t.prototype.endJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.ejl call");v</span>ar p=<span class="cstat-no" title="statement not covered" >this.stateCenter.getRequestId(),</span>e=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(p,t);<span class="cstat-no" title="statement not covered" ></span>return this.sendSignalCmd(l.ENUM_SIGNAL_SUB_CMD.joinLiveStop,e,t,i,n),!0}</span>,t.prototype.respondJoinLive=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,p){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.rpjl call");v</span>ar e=<span class="cstat-no" title="statement not covered" >this.stateCenter.joinLiveRequestMap[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return this.logger.info("zb.lh.rpjl no dest id name"),!1;v</span></span>ar v=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>!0===i&amp;&amp;(v=1);v</span>ar T=<span class="cstat-no" title="statement not covered" >this.stateCenter.getSignalCmdContent(t,e,v);<span class="cstat-no" title="statement not covered" ></span>return this.sendSignalCmd(l.ENUM_SIGNAL_SUB_CMD.joinLiveResult,T,e,n,p),delete this.stateCenter.joinLiveRequestMap[t],!0}</span>,t.prototype.sendSignalCmd=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l,p){<span class="cstat-no" title="statement not covered" >if(this.logger.debug("zb.lh.ssc call"),this.stateCenter.isLogin()){<span class="cstat-no" title="statement not covered" >this.logger.debug("zb.lh.ssc send signal cmd "+t);v</span>ar e=<span class="cstat-no" title="statement not covered" >{sub_cmd:t,signal_msg:i,dest_id_name:[n]};<span class="cstat-no" title="statement not covered" ></span>this.socketCenter.sendMessage("signal",e,l,p),this.logger.info("zb.lh.ssc call success")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.ssc state error")}</span></span>,t.prototype.handlePushSignalMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.stateCenter.isLogin()){var i=<span class="cstat-no" title="statement not covered" >JSON.parse(t.body.signal_msg);<span class="cstat-no" title="statement not covered" ></span>switch(this.logger.debug("zb.lh.hpcm hpsm= ",i),t.body.sub_cmd){case l.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveRequest:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveRequestMsg(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase l.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveResult:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveResultMsg(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase l.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveInvite:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveInviteMsg(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase l.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveStop:<span class="cstat-no" title="statement not covered" >this.handlePushJoinLiveStopMsg(i)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.logger.debug("zb.lh.hpsm call end")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.warn("zb.lh.hpsm not login")}</span></span>,t.prototype.handlePushJoinLiveRequestMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.request_id;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof i){var n=<span class="cstat-no" title="statement not covered" >t.from_userid;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof n?(this.stateCenter.joinLiveRequestMap[i]=n,this.logger.info("zb.lh.hpjlrm onRecvJoinLiveRequest "+n),this.onRecvJoinLiveRequest(i,t.from_userid,t.from_username,t.room_id)):this.logger.error("zb.lh.hpjlrm no from user")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.hpjlrm no requestId")}</span></span>,t.prototype.onRecvJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){},t.prototype.handlePushJoinLiveInviteMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.request_id;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof i){var n=<span class="cstat-no" title="statement not covered" >t.from_userid;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof n?(this.stateCenter.joinLiveRequestMap[i]=n,this.logger.info("zb.lh.hpjlim onRecvInviteJoinLiveRequest "+n),this.onRecvInviteJoinLiveRequest(i,t.from_userid,t.from_username,t.room_id)):this.logger.error("zb.lh.hpjlim no from user")}</span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.hpjlim no requestId")}</span></span>,t.prototype.onRecvInviteJoinLiveRequest=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){},t.prototype.handlePushJoinLiveResultMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.request_id;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof i){var n=<span class="cstat-no" title="statement not covered" >t.result;<span class="cstat-no" title="statement not covered" ></span>if(null!=n){var l=<span class="cstat-no" title="statement not covered" >1==n;<span class="cstat-no" title="statement not covered" ></span>if(this.stateCenter.joinLiveCallbackMap[i]){var p=<span class="cstat-no" title="statement not covered" >this.stateCenter.joinLiveCallbackMap[i];<span class="cstat-no" title="statement not covered" ></span>if(!p)<span class="cstat-no" title="statement not covered" >return void this.logger.info("hpjlrm.o no callback");<span class="cstat-no" title="statement not covered" >t</span></span>his.logger.info("zb.lh.hpjlrm joinLiveRequest/invite result "+l),delete this.stateCenter.joinLiveCallbackMap[i],p(l,t.from_userid,t.from_username)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.logger.info("zb.lh.hpjlrm no result")}</span></span>else <span class="cstat-no" title="statement not covered" >this.logger.error("zb.lh.hpjlrm no requestId")}</span></span>,t.prototype.handlePushJoinLiveStopMsg=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >t.request_id;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof i?(this.logger.info("zb.lh.hpjlsm onRecvEndJoinLiveCommand "+t.from_userid),this.onRecvEndJoinLiveCommand(i,t.from_userid,t.from_username,t.room_id)):this.logger.error("zb.lh.hpjlsm no requestId")}</span>,t.prototype.onRecvEndJoinLiveCommand=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n,l){},t}();i.LiveHandler=p},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(0),p=n(1),e=function(){function t(){this.testEnvironment=!1,this.third_token="",this.pullLimited=!0,this.configOK=!1,this.roomCreateFlag=1,this.runState=l.ENUM_RUN_STATE.logout,this.lastRunState=l.ENUM_RUN_STATE.logout,this.callbackList={},this.streamList=[],this.publishStreamList={},this.userQuerying=!1,this.userTempList=[],this.userSeq=0,this.userSeqMergeMap=null,this.userSeqMergeTimer=null,this.userQueryTimer=null,this.lastUserQueryTime=0,this.userListInterval=3e4,this.userListMergeInterval=5e3,this.anchor_info={anchor_id:"",anchor_id_name:"",anchor_nick_name:""},this.sendCommandMap={},this.sendCommandList=new l.LinkedList,this.sendDataMap={},this.sendDataList=new l.LinkedList,this.joinLiveCallbackMap={},this.joinLiveRequestMap={},this.streamUrlMap={},this.cmdCallback={},this.transSeqMap={},this.realyMessageList=[],this.relayTimer=null,this.bigImLastTimeIndex=0,this.bigIMmessageList=[],this.bigImCallbackMap={},this.bigImTimer=null,this.serverTimeOffset=0,this.datiTimeWindow=0,this.bigimTimeWindow=0,this.bigImMessageList=[],this.screenShotStreamList=[],this.tryLoginCount=0,this.tryLoginTimer=null,this.heartbeatTimer=null,this.sendDataCheckTimer=null,this.sendDataCheckInterval=2e3,this.sendDataTimeout=5e3,this.sendDataDropTimeout=1e4,this.sendDataCheckOnceCount=100,this.sendRoomMsgTime=0,this.SendRoomMsgInterval=500,this.cmdSeq=0,this.audioEffectBuffer={},this.audioBitRate=48e3,this.cdnSeq=0}return t.prototype.isLogin=function(){return this.runState===l.ENUM_RUN_STATE.login},t.prototype.getRequestId=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.idName+"-"+p.getSeq()}</span>,t.prototype.getSignalCmdContent=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){var l=<span class="cstat-no" title="statement not covered" >{request_id:t,room_id:this.roomid,from_userid:this.idName,from_username:this.nickName,to_userid:i};<span class="cstat-no" title="statement not covered" ></span>return null!=n&amp;&amp;(l.result=n),JSON.stringify(l)}</span>,t}();i.StateCenter=e},function(t,i,n){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=n(2),p=function(){function <span class="fstat-no" title="function not covered" >t(</span>t){var i=<span class="cstat-no" title="statement not covered" >t.type,</span>n=<span class="cstat-no" title="statement not covered" >t.channels,</span>l=<span class="cstat-no" title="statement not covered" >void 0===n?1:n,</span>p=<span class="cstat-no" title="statement not covered" >t.bufferSize,</span>e=<span class="cstat-no" title="statement not covered" >void 0===p?0:p,</span>v=<span class="cstat-no" title="statement not covered" >t.sampleBit,</span>T=<span class="cstat-no" title="statement not covered" >void 0===v?16:v,</span>E=<span class="cstat-no" title="statement not covered" >t.sampleRate,</span>S=<span class="cstat-no" title="statement not covered" >void 0===E?44100:E,</span>R=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.instant=0,this.slow=0,this.clip=0;v</span>ar r=<span class="cstat-no" title="statement not covered" >new("undefined"!=typeof webkitAudioContext?webkitAudioContext:AudioContext);<span class="cstat-no" title="statement not covered" ></span>this.context=r,this.type=i,this.channels=l,this.bufferSize=e,this.sampleBit=T,this.sampleRate=S,this.script=r.createScriptProcessor(e,l,l);<span class="cstat-no" title="statement not covered" >(</span>new Date).getTime();<span class="cstat-no" title="statement not covered" >t</span>his.script.addEventListener("audioprocess",<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n,l=<span class="cstat-no" title="statement not covered" >t.inputBuffer.getChannelData(0),</span>p=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;l.length;++n)<span class="cstat-no" title="statement not covered" >p+=l[n]*l[n],Math.abs(l[n])&gt;.99&amp;&amp;(e+=1);<span class="cstat-no" title="statement not covered" >i</span></span>f(R.instant=Math.sqrt(p/l.length),R.slow=.95*R.slow+.05*R.instant,R.clip=e/l.length,"pcm"===i||"wav"===i){<span class="cstat-no" title="statement not covered" >for(var v=[],T=0;T&lt;R.channels;T++)<span class="cstat-no" title="statement not covered" >v.push(t.inputBuffer.getChannelData(T));<span class="cstat-no" title="statement not covered" >R</span></span>.recorderBuffer(v)}</span>}</span>),"pcm"!==i&amp;&amp;"wav"!==i||this.initRecorderBuffer(i)}</span>return t.prototype.connectToSource=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >console.log("SoundMeter connecting");<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.mic=this.context.createMediaStreamSource(t),this.mic.connect(this.script),this.script.connect(this.context.destination),void 0!==i&amp;&amp;i(null)}</span>catch(t){<span class="cstat-no" title="statement not covered" >console.error(t),void 0!==i&amp;&amp;i(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,t.prototype.recorderBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.worker.postMessage({command:"record",val:t})}</span>,t.prototype.initRecorderBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.worker=l.ClientUtil.inlineWorker(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,i,n,l,p,e,v=<span class="cstat-no" title="statement not covered" >[],</span>T=<span class="cstat-no" title="statement not covered" >this;</span>function <span class="fstat-no" title="function not covered" >E(</span>i){var n,l;<span class="cstat-no" title="statement not covered" >if(1==t)<span class="cstat-no" title="statement not covered" >n=R(v[0],p,v),1!=i&amp;&amp;(l=S(i,n));e</span>lse <span class="cstat-no" title="statement not covered" >if(2==t){var e=<span class="cstat-no" title="statement not covered" >R(v[0],p,v),</span>T=<span class="cstat-no" title="statement not covered" >R(v[1],p,v);<span class="cstat-no" title="statement not covered" ></span>1!=i?l=r(S(i,e),S(i,T)):n=r(e,T)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn 1!=i?l:n}</span>function <span class="fstat-no" title="function not covered" >S(</span>t,i){<span class="cstat-no" title="statement not covered" >for(var n=new Float32Array(i.length/t),l=0,p=0;l&lt;n.length;)<span class="cstat-no" title="statement not covered" >n[l]=i[p],p+=t,l++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >R(</span>t,i,n){<span class="cstat-no" title="statement not covered" >for(var l=new Float32Array(i*t.length),p=0,e=0;e&lt;n[0].length;e++)<span class="cstat-no" title="statement not covered" >l.set(n[0][e],p),p+=n[0][e].length;<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,i){<span class="cstat-no" title="statement not covered" >for(var n=new Float32Array(t.length+i.length),l=0;l&lt;t.length+i.length;l+=2)<span class="cstat-no" title="statement not covered" >n[l]=t[l/2&gt;&gt;0],n[l+1]=i[l/2&gt;&gt;0];<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >h(</span>t,i,n){<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;n.length;l++)<span class="cstat-no" title="statement not covered" >t.setUint8(i+l,n.charCodeAt(l))}</span></span>function <span class="fstat-no" title="function not covered" >u(</span>t,i,n){<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;n.length;l++,i+=2){var p=<span class="cstat-no" title="statement not covered" >Math.max(-1,Math.min(1,n[l]));<span class="cstat-no" title="statement not covered" ></span>t.setInt16(i,p&lt;0?32768*p:32767*p,!0)}</span>}</span>function <span class="fstat-no" title="function not covered" >L(</span>t,i,n){<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;n.length;l++,i++){var p=<span class="cstat-no" title="statement not covered" >Math.max(-1,Math.min(1,n[l])),</span>e=<span class="cstat-no" title="statement not covered" >p&lt;0?128*p:127*p;<span class="cstat-no" title="statement not covered" ></span>e+=128,t.setInt8(i,e)}</span>}<span class="cstat-no" title="statement not covered" ></span>this.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(S){<span class="cstat-no" title="statement not covered" >switch(S.data.command){case"init":<span class="cstat-no" title="statement not covered" >R=S.data.val,t=R.sampleChannel,i=R.sampleBit,n=R.sampleRate,l=R.oldSampleRate,p=R.bufferSize,e=R.type;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"record":<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(p){<span class="cstat-no" title="statement not covered" >for(var S=0;S&lt;t;S++)<span class="cstat-no" title="statement not covered" >v[S]||(v[S]=[]),v[S].push(p[S]);v</span></span>ar R=<span class="cstat-no" title="statement not covered" >Math.round(l/n);<span class="cstat-no" title="statement not covered" ></span>"pcm"===e?<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,n){var l;<span class="cstat-no" title="statement not covered" >8==n?l=t.length:16==n&amp;&amp;(l=t.length,l*=2);v</span>ar p=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(l),</span>e=<span class="cstat-no" title="statement not covered" >new DataView(p);<span class="cstat-no" title="statement not covered" ></span>8==n?L(e,0,t):16==i&amp;&amp;u(e,0,t);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>(E(t),i);<span class="cstat-no" title="statement not covered" ></span>T.postMessage({command:"exportPcmLive",val:n})}</span>(R):"wav"===e&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(l){var p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(l,p){var e;<span class="cstat-no" title="statement not covered" >8==p?e=l.length:16==i&amp;&amp;(e=l.length,e*=2);v</span>ar v=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(e+44),</span>T=<span class="cstat-no" title="statement not covered" >new DataView(v),</span>E=<span class="cstat-no" title="statement not covered" >n,</span>S=<span class="cstat-no" title="statement not covered" >i,</span>R=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>h(T,0,"RIFF"),T.setUint32(4,36+e,!0),h(T,8,"WAVE"),h(T,12,"fmt "),T.setUint32(16,16,!0),T.setUint16(20,1,!0),T.setUint16(22,R,!0),T.setUint32(24,E,!0),T.setUint32(28,E*R*(S/8),!0),T.setUint16(32,R*(S/8),!0),T.setUint16(34,S,!0),h(T,36,"data"),T.setUint32(40,e,!0),8==i?L(T,44,l):16==i&amp;&amp;u(T,44,l);<span class="cstat-no" title="statement not covered" >r</span>eturn T}</span>(E(l),i);<span class="cstat-no" title="statement not covered" ></span>T.postMessage({command:"exportWav",val:p})}</span>(R);<span class="cstat-no" title="statement not covered" >v</span>=[]}</span>(S.data.val)}</span>v</span>ar R}}</span>),this.worker.postMessage({command:"init",val:{sampleChannel:this.channels,sampleBit:this.sampleBit,sampleRate:this.sampleRate,oldSampleRate:this.context.sampleRate,bufferSize:this.bufferSize,type:t}}),this.worker.onmessage=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(t.data.command){case"exportPcmLive":<span class="cstat-no" title="statement not covered" >i.onReceiveBuffer(t.data.val);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"exportWav":<span class="cstat-no" title="statement not covered" >i.onReceiveWav(t.data.val)}</span>}</span>}</span>,t.prototype.onReceiveBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.onReceiveWav=<span class="fstat-no" title="function not covered" >fu</span>nction(t){},t.prototype.writeString=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;n.length;l++)<span class="cstat-no" title="statement not covered" >t.setUint8(i+l,n.charCodeAt(l))}</span></span>,t.prototype.writeBuffer=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,n){<span class="cstat-no" title="statement not covered" >for(var l=0;l&lt;n.byteLength;l++)<span class="cstat-no" title="statement not covered" >t.setUint8(i+l,n[l])}</span></span>,t.prototype.concatenation=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var i=0,n=0;n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >i+=t[n].buffer.byteLength;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >new Uint8Array(i),</span>p=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >l.set(new Uint8Array(t[n].buffer),p),p+=t[n].buffer.byteLength;<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>,t.prototype.encodeWave=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var i=<span class="cstat-no" title="statement not covered" >this.concatenation(t),</span>n=<span class="cstat-no" title="statement not covered" >i.byteLength,</span>l=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(n+44),</span>p=<span class="cstat-no" title="statement not covered" >new DataView(l),</span>e=<span class="cstat-no" title="statement not covered" >this.sampleRate,</span>v=<span class="cstat-no" title="statement not covered" >this.sampleBit,</span>T=<span class="cstat-no" title="statement not covered" >this.channels;<span class="cstat-no" title="statement not covered" ></span>return this.writeString(p,0,"RIFF"),p.setUint32(4,36+n,!0),this.writeString(p,8,"WAVE"),this.writeString(p,12,"fmt "),p.setUint32(16,16,!0),p.setUint16(20,1,!0),p.setUint16(22,T,!0),p.setUint32(24,e,!0),p.setUint32(28,e*T*(v/8),!0),p.setUint16(32,T*(v/8),!0),p.setUint16(34,v,!0),this.writeString(p,36,"data"),p.setUint32(40,n,!0),this.writeBuffer(p,44,i),p}</span>,t.prototype.stop=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.mic.disconnect(),this.script.disconnect()}</span>,t}();i.MediaUtil=p}])});</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Mon Jul 27 2020 21:05:22 GMT+0800 (GMT+08:00)
            </div>
        </div>
        <script src="../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../sorter.js"></script>
        <script src="../block-navigation.js"></script>
    </body>
</html>
    